System.registerDynamic('npm:sweetjs-min@2.2.3/dist/store.js', ['vm', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 });var _vm = $__require('vm'),
      _vm2 = _interopRequireDefault(_vm);function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class Store {
    constructor() {
      this.map = new Map(), this.nodeContext = _vm2.default.createContext();
    }has(a) {
      return this.map.has(a);
    }get(a) {
      return this.map.get(a);
    }set(a, b) {
      return this.nodeContext[a] = b, this.map.set(a, b);
    }getNodeContext() {
      return this.nodeContext;
    }
  }exports.default = Store;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/apply-scope-in-params-reducer.js", ["./terms", "./symbol", "./transforms", "./errors", "./syntax", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms),
      _symbol = $__require("./symbol"),
      _transforms = $__require("./transforms"),
      _errors = $__require("./errors"),
      _syntax = $__require("./syntax");function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class ScopeApplyingReducer {
    constructor(a, b) {
      this.context = b, this.scope = a;
    }transform(a) {
      let b = "transform" + a.type;return "function" == typeof this[b] ? this[b](a) : void (0, _errors.assert)(!1, "transform not implemented yet for: " + a.type);
    }transformFormalParameters(a) {
      let b = null == a.rest ? null : this.transform(a.rest);return new _terms2.default("FormalParameters", { items: a.items.map(c => this.transform(c)), rest: b });
    }transformBindingWithDefault(a) {
      return new _terms2.default("BindingWithDefault", { binding: this.transform(a.binding), init: a.init });
    }transformObjectBinding(a) {
      return a;
    }transformBindingPropertyIdentifier(a) {
      return new _terms2.default("BindingPropertyIdentifier", { binding: this.transform(a.binding), init: a.init });
    }transformBindingPropertyProperty(a) {
      return new _terms2.default("BindingPropertyProperty", { name: a.name, binding: this.transform(a.binding) });
    }transformArrayBinding(a) {
      return new _terms2.default("ArrayBinding", { elements: a.elements.map(b => this.transform(b)), restElement: null == a.restElement ? null : this.transform(a.restElement) });
    }transformBindingIdentifier(a) {
      let b = a.name.addScope(this.scope, this.context.bindings, _syntax.ALL_PHASES),
          c = (0, _symbol.gensym)(b.val());return this.context.env.set(c.toString(), new _transforms.VarBindingTransform(b)), this.context.bindings.add(b, { binding: c, phase: this.context.phase, skipDup: !0 }), new _terms2.default("BindingIdentifier", { name: b });
    }
  }exports.default = ScopeApplyingReducer;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/term-expander.js", ["immutable", "./terms", "./scope", "./apply-scope-in-params-reducer", "./compiler", "./syntax", "./serializer", "./enforester", "./template-processor.js", "./ast-dispatcher", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _immutable = $__require("immutable"),
      _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms),
      _scope = $__require("./scope"),
      _applyScopeInParamsReducer = $__require("./apply-scope-in-params-reducer"),
      _applyScopeInParamsReducer2 = _interopRequireDefault(_applyScopeInParamsReducer),
      _compiler = $__require("./compiler"),
      _compiler2 = _interopRequireDefault(_compiler),
      _syntax = $__require("./syntax"),
      _syntax2 = _interopRequireDefault(_syntax),
      _serializer = $__require("./serializer"),
      _enforester = $__require("./enforester"),
      _templateProcessor = $__require("./template-processor.js"),
      _astDispatcher = $__require("./ast-dispatcher"),
      _astDispatcher2 = _interopRequireDefault(_astDispatcher);function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class TermExpander extends _astDispatcher2.default {
    constructor(a) {
      super("expand", !0), this.context = a;
    }expand(a) {
      return this.dispatch(a);
    }expandPragma(a) {
      return a;
    }expandTemplateExpression(a) {
      return new _terms2.default("TemplateExpression", { tag: null == a.tag ? null : this.expand(a.tag), elements: a.elements.toArray() });
    }expandBreakStatement(a) {
      return new _terms2.default("BreakStatement", { label: a.label ? a.label.val() : null });
    }expandDoWhileStatement(a) {
      return new _terms2.default("DoWhileStatement", { body: this.expand(a.body), test: this.expand(a.test) });
    }expandWithStatement(a) {
      return new _terms2.default("WithStatement", { body: this.expand(a.body), object: this.expand(a.object) });
    }expandDebuggerStatement(a) {
      return a;
    }expandContinueStatement(a) {
      return new _terms2.default("ContinueStatement", { label: a.label ? a.label.val() : null });
    }expandSwitchStatementWithDefault(a) {
      return new _terms2.default("SwitchStatementWithDefault", { discriminant: this.expand(a.discriminant), preDefaultCases: a.preDefaultCases.map(e => this.expand(e)).toArray(), defaultCase: this.expand(a.defaultCase), postDefaultCases: a.postDefaultCases.map(e => this.expand(e)).toArray() });
    }expandComputedMemberExpression(a) {
      return new _terms2.default("ComputedMemberExpression", { object: this.expand(a.object), expression: this.expand(a.expression) });
    }expandSwitchStatement(a) {
      return new _terms2.default("SwitchStatement", { discriminant: this.expand(a.discriminant), cases: a.cases.map(e => this.expand(e)).toArray() });
    }expandFormalParameters(a) {
      let e = null == a.rest ? null : this.expand(a.rest);return new _terms2.default("FormalParameters", { items: a.items.map(f => this.expand(f)), rest: e });
    }expandArrowExpression(a) {
      return this.doFunctionExpansion(a, "ArrowExpression");
    }expandSwitchDefault(a) {
      return new _terms2.default("SwitchDefault", { consequent: a.consequent.map(e => this.expand(e)).toArray() });
    }expandSwitchCase(a) {
      return new _terms2.default("SwitchCase", { test: this.expand(a.test), consequent: a.consequent.map(e => this.expand(e)).toArray() });
    }expandForInStatement(a) {
      return new _terms2.default("ForInStatement", { left: this.expand(a.left), right: this.expand(a.right), body: this.expand(a.body) });
    }expandTryCatchStatement(a) {
      return new _terms2.default("TryCatchStatement", { body: this.expand(a.body), catchClause: this.expand(a.catchClause) });
    }expandTryFinallyStatement(a) {
      let e = null == a.catchClause ? null : this.expand(a.catchClause);return new _terms2.default("TryFinallyStatement", { body: this.expand(a.body), catchClause: e, finalizer: this.expand(a.finalizer) });
    }expandCatchClause(a) {
      return new _terms2.default("CatchClause", { binding: this.expand(a.binding), body: this.expand(a.body) });
    }expandThrowStatement(a) {
      return new _terms2.default("ThrowStatement", { expression: this.expand(a.expression) });
    }expandForOfStatement(a) {
      return new _terms2.default("ForOfStatement", { left: this.expand(a.left), right: this.expand(a.right), body: this.expand(a.body) });
    }expandBindingIdentifier(a) {
      return a;
    }expandBindingPropertyIdentifier(a) {
      return a;
    }expandBindingPropertyProperty(a) {
      return new _terms2.default("BindingPropertyProperty", { name: this.expand(a.name), binding: this.expand(a.binding) });
    }expandComputedPropertyName(a) {
      return new _terms2.default("ComputedPropertyName", { expression: this.expand(a.expression) });
    }expandObjectBinding(a) {
      return new _terms2.default("ObjectBinding", { properties: a.properties.map(e => this.expand(e)).toArray() });
    }expandArrayBinding(a) {
      let e = null == a.restElement ? null : this.expand(a.restElement);return new _terms2.default("ArrayBinding", { elements: a.elements.map(f => null == f ? null : this.expand(f)).toArray(), restElement: e });
    }expandBindingWithDefault(a) {
      return new _terms2.default("BindingWithDefault", { binding: this.expand(a.binding), init: this.expand(a.init) });
    }expandShorthandProperty(a) {
      return new _terms2.default("DataProperty", { name: new _terms2.default("StaticPropertyName", { value: a.name }), expression: new _terms2.default("IdentifierExpression", { name: a.name }) });
    }expandForStatement(a) {
      let e = null == a.init ? null : this.expand(a.init),
          f = null == a.test ? null : this.expand(a.test),
          g = null == a.update ? null : this.expand(a.update),
          h = this.expand(a.body);return new _terms2.default("ForStatement", { init: e, test: f, update: g, body: h });
    }expandYieldExpression(a) {
      let e = null == a.expression ? null : this.expand(a.expression);return new _terms2.default("YieldExpression", { expression: e });
    }expandYieldGeneratorExpression(a) {
      let e = null == a.expression ? null : this.expand(a.expression);return new _terms2.default("YieldGeneratorExpression", { expression: e });
    }expandWhileStatement(a) {
      return new _terms2.default("WhileStatement", { test: this.expand(a.test), body: this.expand(a.body) });
    }expandIfStatement(a) {
      let e = null == a.consequent ? null : this.expand(a.consequent),
          f = null == a.alternate ? null : this.expand(a.alternate);return new _terms2.default("IfStatement", { test: this.expand(a.test), consequent: e, alternate: f });
    }expandBlockStatement(a) {
      return new _terms2.default("BlockStatement", { block: this.expand(a.block) });
    }expandBlock(a) {
      let e = (0, _scope.freshScope)("block");this.context.currentScope.push(e);let g,
          h,
          f = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);return g = a.statements.map(j => j.addScope(e, this.context.bindings, _syntax.ALL_PHASES)), h = new _terms2.default("Block", { statements: f.compile(g) }), this.context.currentScope.pop(), h;
    }expandVariableDeclarationStatement(a) {
      return new _terms2.default("VariableDeclarationStatement", { declaration: this.expand(a.declaration) });
    }expandReturnStatement(a) {
      return null == a.expression ? a : new _terms2.default("ReturnStatement", { expression: this.expand(a.expression) });
    }expandClassDeclaration(a) {
      return new _terms2.default("ClassDeclaration", { name: null == a.name ? null : this.expand(a.name), super: null == a.super ? null : this.expand(a.super), elements: a.elements.map(e => this.expand(e)).toArray() });
    }expandClassExpression(a) {
      return new _terms2.default("ClassExpression", { name: null == a.name ? null : this.expand(a.name), super: null == a.super ? null : this.expand(a.super), elements: a.elements.map(e => this.expand(e)).toArray() });
    }expandClassElement(a) {
      return new _terms2.default("ClassElement", { isStatic: a.isStatic, method: this.expand(a.method) });
    }expandThisExpression(a) {
      return a;
    }expandSyntaxTemplate(a) {
      let e = (0, _templateProcessor.processTemplate)(a.template.inner()),
          f = _syntax2.default.from("string", _serializer.serializer.write(e.template)),
          g = new _terms2.default("IdentifierExpression", { name: _syntax2.default.from("identifier", "syntaxTemplate") }),
          h = e.interp.map(k => {
        let l = new _enforester.Enforester(k, (0, _immutable.List)(), this.context);return this.expand(l.enforest("expression"));
      }),
          j = _immutable.List.of(new _terms2.default("LiteralStringExpression", { value: f })).concat(h);return new _terms2.default("CallExpression", { callee: g, arguments: j });
    }expandSyntaxQuote(a) {
      let e = new _terms2.default("LiteralStringExpression", { value: _syntax2.default.from("string", _serializer.serializer.write(a.name)) });return new _terms2.default("TemplateExpression", { tag: a.template.tag, elements: a.template.elements.push(e).push(new _terms2.default("TemplateElement", { rawValue: "" })).toArray() });
    }expandStaticMemberExpression(a) {
      return new _terms2.default("StaticMemberExpression", { object: this.expand(a.object), property: a.property });
    }expandArrayExpression(a) {
      return new _terms2.default("ArrayExpression", { elements: a.elements.map(e => null == e ? e : this.expand(e)) });
    }expandImport(a) {
      return a;
    }expandImportNamespace(a) {
      return a;
    }expandExport(a) {
      return new _terms2.default("Export", { declaration: this.expand(a.declaration) });
    }expandExportDefault(a) {
      return new _terms2.default("ExportDefault", { body: this.expand(a.body) });
    }expandExportFrom(a) {
      return a;
    }expandExportAllFrom(a) {
      return a;
    }expandExportSpecifier(a) {
      return a;
    }expandStaticPropertyName(a) {
      return a;
    }expandDataProperty(a) {
      return new _terms2.default("DataProperty", { name: this.expand(a.name), expression: this.expand(a.expression) });
    }expandObjectExpression(a) {
      return new _terms2.default("ObjectExpression", { properties: a.properties.map(e => this.expand(e)) });
    }expandVariableDeclarator(a) {
      let e = null == a.init ? null : this.expand(a.init);return new _terms2.default("VariableDeclarator", { binding: this.expand(a.binding), init: e });
    }expandVariableDeclaration(a) {
      return "syntax" === a.kind || "syntaxrec" === a.kind ? a : new _terms2.default("VariableDeclaration", { kind: a.kind, declarators: a.declarators.map(e => this.expand(e)) });
    }expandParenthesizedExpression(a) {
      if (0 === a.inner.size) throw new Error("unexpected end of input");let e = new _enforester.Enforester(a.inner, (0, _immutable.List)(), this.context),
          f = e.peek(),
          g = e.enforestExpression();if (null == g || 0 < e.rest.size) throw e.createError(f, "unexpected syntax");return this.expand(g);
    }expandUnaryExpression(a) {
      return new _terms2.default("UnaryExpression", { operator: a.operator, operand: this.expand(a.operand) });
    }expandUpdateExpression(a) {
      return new _terms2.default("UpdateExpression", { isPrefix: a.isPrefix, operator: a.operator, operand: this.expand(a.operand) });
    }expandBinaryExpression(a) {
      let e = this.expand(a.left),
          f = this.expand(a.right);return new _terms2.default("BinaryExpression", { left: e, operator: a.operator, right: f });
    }expandConditionalExpression(a) {
      return new _terms2.default("ConditionalExpression", { test: this.expand(a.test), consequent: this.expand(a.consequent), alternate: this.expand(a.alternate) });
    }expandNewTargetExpression(a) {
      return a;
    }expandNewExpression(a) {
      let e = this.expand(a.callee),
          f = new _enforester.Enforester(a.arguments, (0, _immutable.List)(), this.context),
          g = f.enforestArgumentList().map(h => this.expand(h));return new _terms2.default("NewExpression", { callee: e, arguments: g.toArray() });
    }expandSuper(a) {
      return a;
    }expandCallExpression(a) {
      let e = this.expand(a.callee),
          f = new _enforester.Enforester(a.arguments, (0, _immutable.List)(), this.context),
          g = f.enforestArgumentList().map(h => this.expand(h));return new _terms2.default("CallExpression", { callee: e, arguments: g });
    }expandSpreadElement(a) {
      return new _terms2.default("SpreadElement", { expression: this.expand(a.expression) });
    }expandExpressionStatement(a) {
      let e = this.expand(a.expression);return new _terms2.default("ExpressionStatement", { expression: e });
    }expandLabeledStatement(a) {
      return new _terms2.default("LabeledStatement", { label: a.label.val(), body: this.expand(a.body) });
    }doFunctionExpansion(a, e) {
      let h,
          f = (0, _scope.freshScope)("fun"),
          g = new _applyScopeInParamsReducer2.default(f, this.context);"Getter" !== e && "Setter" !== e && (h = g.transform(a.params), h = this.expand(h)), this.context.currentScope.push(f);let k,
          l,
          j = new _compiler2.default(this.context.phase, this.context.env, this.context.store, this.context);return (a.body instanceof _terms2.default ? l = this.expand(a.body.addScope(f, this.context.bindings, _syntax.ALL_PHASES)) : (k = a.body.map(m => m.addScope(f, this.context.bindings, _syntax.ALL_PHASES)), l = new _terms2.default("FunctionBody", { directives: (0, _immutable.List)(), statements: j.compile(k) })), this.context.currentScope.pop(), "Getter" === e) ? new _terms2.default(e, { name: this.expand(a.name), body: l }) : "Setter" === e ? new _terms2.default(e, { name: this.expand(a.name), param: a.param, body: l }) : "ArrowExpression" === e ? new _terms2.default(e, { params: h, body: l }) : new _terms2.default(e, { name: a.name, isGenerator: a.isGenerator, params: h, body: l });
    }expandMethod(a) {
      return this.doFunctionExpansion(a, "Method");
    }expandSetter(a) {
      return this.doFunctionExpansion(a, "Setter");
    }expandGetter(a) {
      return this.doFunctionExpansion(a, "Getter");
    }expandFunctionDeclaration(a) {
      return this.doFunctionExpansion(a, "FunctionDeclaration");
    }expandFunctionExpression(a) {
      return this.doFunctionExpansion(a, "FunctionExpression");
    }expandCompoundAssignmentExpression(a) {
      return new _terms2.default("CompoundAssignmentExpression", { binding: this.expand(a.binding), operator: a.operator, expression: this.expand(a.expression) });
    }expandAssignmentExpression(a) {
      return new _terms2.default("AssignmentExpression", { binding: this.expand(a.binding), expression: this.expand(a.expression) });
    }expandEmptyStatement(a) {
      return a;
    }expandLiteralBooleanExpression(a) {
      return a;
    }expandLiteralNumericExpression(a) {
      return a;
    }expandLiteralInfinityExpression(a) {
      return a;
    }expandIdentifierExpression(a) {
      let e = this.context.env.get(a.name.resolve(this.context.phase));return e ? new _terms2.default("IdentifierExpression", { name: e.id }) : a;
    }expandLiteralNullExpression(a) {
      return a;
    }expandLiteralStringExpression(a) {
      return a;
    }expandLiteralRegExpExpression(a) {
      return a;
    }
  }exports.default = TermExpander;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/env.js", ["./transforms", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _transforms = $__require("./transforms");class Env {
    constructor() {
      this.map = new Map(), this.map.set("function", _transforms.FunctionDeclTransform), this.map.set("var", _transforms.VariableDeclTransform), this.map.set("let", _transforms.LetDeclTransform), this.map.set("const", _transforms.ConstDeclTransform), this.map.set("syntaxQuote", _transforms.SyntaxQuoteTransform), this.map.set("syntaxrec", _transforms.SyntaxrecDeclTransform), this.map.set("syntax", _transforms.SyntaxDeclTransform), this.map.set("return", _transforms.ReturnStatementTransform), this.map.set("while", _transforms.WhileTransform), this.map.set("if", _transforms.IfTransform), this.map.set("for", _transforms.ForTransform), this.map.set("switch", _transforms.SwitchTransform), this.map.set("break", _transforms.BreakTransform), this.map.set("continue", _transforms.ContinueTransform), this.map.set("do", _transforms.DoTransform), this.map.set("debugger", _transforms.DebuggerTransform), this.map.set("with", _transforms.WithTransform), this.map.set("try", _transforms.TryTransform), this.map.set("throw", _transforms.ThrowTransform), this.map.set("new", _transforms.NewTransform);
    }has(a) {
      return this.map.has(a);
    }get(a) {
      return this.map.get(a);
    }set(a, b) {
      return this.map.set(a, b);
    }
  }exports.default = Env;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/parse-reducer.js", ["./terms", "shift-reducer", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms),
      _shiftReducer = $__require("shift-reducer");function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class ParseReducer extends _shiftReducer.CloneReducer {
    constructor(a) {
      super(), this.context = a;
    }reduceModule(a, b) {
      return new _terms2.default("Module", { directives: b.directives.toArray(), items: b.items.toArray() });
    }reduceImport(a, b) {
      let c = b.moduleSpecifier ? b.moduleSpecifier.val() : null;return new _terms2.default("Import", { defaultBinding: b.defaultBinding, namedImports: b.namedImports.toArray(), moduleSpecifier: c, forSyntax: a.forSyntax });
    }reduceImportNamespace(a, b) {
      let c = b.moduleSpecifier ? b.moduleSpecifier.val() : null;return new _terms2.default("ImportNamespace", { defaultBinding: b.defaultBinding, namespaceBinding: b.namespaceBinding, moduleSpecifier: c, forSyntax: a.forSyntax });
    }reduceExport(a, b) {
      return new _terms2.default("Export", { declaration: b.declaration });
    }reduceExportAllFrom(a, b) {
      let c = b.moduleSpecifier ? b.moduleSpecifier.val() : null;return new _terms2.default("ExportAllFrom", { moduleSpecifier: c });
    }reduceExportFrom(a, b) {
      let c = b.moduleSpecifier ? b.moduleSpecifier.val() : null;return new _terms2.default("ExportFrom", { moduleSpecifier: c, namedExports: b.namedExports.toArray() });
    }reduceExportSpecifier(a, b) {
      let c = b.name,
          d = b.exportedName;return null == c ? (c = d.resolve(this.context.phase), d = d.val()) : (c = c.resolve(this.context.phase), d = d.val()), new _terms2.default("ExportSpecifier", { name: c, exportedName: d });
    }reduceImportSpecifier(a, b) {
      let c = b.name ? b.name.resolve(this.context.phase) : null;return new _terms2.default("ImportSpecifier", { name: c, binding: b.binding });
    }reduceIdentifierExpression(a) {
      return new _terms2.default("IdentifierExpression", { name: a.name.resolve(this.context.phase) });
    }reduceLiteralNumericExpression(a) {
      return new _terms2.default("LiteralNumericExpression", { value: a.value.val() });
    }reduceLiteralBooleanExpression(a) {
      return new _terms2.default("LiteralBooleanExpression", { value: "true" === a.value.val() });
    }reduceLiteralStringExpression(a) {
      return new _terms2.default("LiteralStringExpression", { value: a.value.token.str });
    }reduceCallExpression(a, b) {
      return new _terms2.default("CallExpression", { callee: b.callee, arguments: b.arguments.toArray() });
    }reduceFunctionBody(a, b) {
      return new _terms2.default("FunctionBody", { directives: b.directives.toArray(), statements: b.statements.toArray() });
    }reduceFormalParameters(a, b) {
      return new _terms2.default("FormalParameters", { items: b.items.toArray(), rest: b.rest });
    }reduceBindingIdentifier(a) {
      return new _terms2.default("BindingIdentifier", { name: a.name.resolve(this.context.phase) });
    }reduceBinaryExpression(a, b) {
      return new _terms2.default("BinaryExpression", { left: b.left, operator: a.operator.val(), right: b.right });
    }reduceObjectExpression(a, b) {
      return new _terms2.default("ObjectExpression", { properties: b.properties.toArray() });
    }reduceVariableDeclaration(a, b) {
      return new _terms2.default("VariableDeclaration", { kind: b.kind, declarators: b.declarators.toArray() });
    }reduceStaticPropertyName(a) {
      return new _terms2.default("StaticPropertyName", { value: a.value.val().toString() });
    }reduceArrayExpression(a, b) {
      return new _terms2.default("ArrayExpression", { elements: b.elements.toArray() });
    }reduceStaticMemberExpression(a, b) {
      return new _terms2.default("StaticMemberExpression", { object: b.object, property: b.property.val() });
    }
  }exports.default = ParseReducer;
});
System.registerDynamic("npm:shift-reducer@3.0.3/dist/clone-reducer.js", ["shift-spec"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _shiftSpec = $__require("shift-spec");

  var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  } /**
     * Copyright 2014 Shape Security, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License")
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

  var CloneReducer = function CloneReducer() {
    _classCallCheck(this, CloneReducer);
  };

  exports.default = CloneReducer;

  for (var typeName in _shiftSpec2.default) {
    var type = _shiftSpec2.default[typeName];
    Object.defineProperty(CloneReducer.prototype, "reduce" + typeName, {
      value: function value(node, state) {
        return state;
      }
    });
  }
});
System.registerDynamic("npm:shift-reducer@3.0.3/dist/monoidal-reducer.js", ["shift-spec"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
  }; /**
      * Copyright 2014 Shape Security, Inc.
      *
      * Licensed under the Apache License, Version 2.0 (the "License")
      * you may not use this file except in compliance with the License.
      * You may obtain a copy of the License at
      *
      *     http://www.apache.org/licenses/LICENSE-2.0
      *
      * Unless required by applicable law or agreed to in writing, software
      * distributed under the License is distributed on an "AS IS" BASIS,
      * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      * See the License for the specific language governing permissions and
      * limitations under the License.
      */

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _shiftSpec = $__require("shift-spec");

  var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var methods = {};

  function id(x) {
    return x;
  }

  function handlerForFieldOfType(type) {
    switch (type.typeName) {
      case "Enum":
      case "String":
      case "Boolean":
      case "Number":
      case "SourceSpan":
        return null;
      case "Const":
        return handlerForFieldOfType(type.argument);
      case "Maybe":
        {
          var _ret = function () {
            var subHandler = handlerForFieldOfType(type.argument);
            if (subHandler == null) return {
              v: null
            };
            return {
              v: function v(t) {
                return t == null ? this.identity : subHandler.call(this, t);
              }
            };
          }();

          if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
        }
      case "List":
        {
          var _ret2 = function () {
            var subHandler = handlerForFieldOfType(type.argument);
            if (subHandler == null) return {
              v: null
            };
            return {
              v: function v(t) {
                var _this = this;

                return this.fold(t.map(function (x) {
                  return subHandler.call(_this, x);
                }));
              }
            };
          }();

          if ((typeof _ret2 === "undefined" ? "undefined" : _typeof(_ret2)) === "object") return _ret2.v;
        }
      default:
        return id;
    }
  }

  var _loop = function _loop(typeName) {
    var type = _shiftSpec2.default[typeName];

    var handlers = {};
    type.fields.forEach(function (field) {
      var handler = handlerForFieldOfType(field.type);
      if (handler != null) handlers[field.name] = handler;
    });
    var fieldNames = Object.keys(handlers);

    methods["reduce" + typeName] = {
      value: function value(node, state) {
        var _this3 = this;

        return this.fold(fieldNames.map(function (fieldName) {
          return handlers[fieldName].call(_this3, state[fieldName]);
        }));
      }
    };
  };

  for (var typeName in _shiftSpec2.default) {
    _loop(typeName);
  }

  var MonoidalReducer = function () {
    function MonoidalReducer(monoid) {
      _classCallCheck(this, MonoidalReducer);

      this.identity = monoid.empty();
      var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
      this.append = function (a, b) {
        return concat.call(a, b);
      };
    }

    _createClass(MonoidalReducer, [{
      key: "fold",
      value: function fold(list, a) {
        var _this2 = this;

        return list.reduce(function (memo, x) {
          return _this2.append(memo, x);
        }, a == null ? this.identity : a);
      }
    }]);

    return MonoidalReducer;
  }();

  exports.default = MonoidalReducer;

  Object.defineProperties(MonoidalReducer.prototype, methods);
});
System.registerDynamic("npm:shift-spec@2015.2.1.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-spec@2015.2.1/dist/index.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // Generated by src/generate-spec.js. 

  /**
   * Copyright 2015 Shape Security, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Hack to make Babel6 import this as a module.
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  // Meta data generated from spec.idl.
  exports.default = function () {
    var SPEC = {};

    var BOOLEAN = { typeName: "Boolean" };
    var DOUBLE = { typeName: "Number" };
    var STRING = { typeName: "String" };
    function Maybe(arg) {
      return { typeName: "Maybe", argument: arg };
    }
    function List(arg) {
      return { typeName: "List", argument: arg };
    }
    function Const(arg) {
      return { typeName: "Const", argument: arg };
    }
    function Union() {
      return { typeName: "Union", arguments: [].slice.call(arguments, 0) };
    }

    var TYPE_INDICATOR = {
      typeName: "Enum",
      values: ["ArrayBinding", "ArrayExpression", "ArrowExpression", "AssignmentExpression", "BinaryExpression", "BindingIdentifier", "BindingProperty", "BindingPropertyIdentifier", "BindingPropertyProperty", "BindingWithDefault", "Block", "BlockStatement", "BreakStatement", "CallExpression", "CatchClause", "Class", "ClassDeclaration", "ClassElement", "ClassExpression", "CompoundAssignmentExpression", "ComputedMemberExpression", "ComputedPropertyName", "ConditionalExpression", "ContinueStatement", "DataProperty", "DebuggerStatement", "Directive", "DoWhileStatement", "EmptyStatement", "Export", "ExportAllFrom", "ExportDeclaration", "ExportDefault", "ExportFrom", "ExportSpecifier", "Expression", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FormalParameters", "Function", "FunctionBody", "FunctionDeclaration", "FunctionExpression", "Getter", "IdentifierExpression", "IfStatement", "Import", "ImportDeclaration", "ImportNamespace", "ImportSpecifier", "IterationStatement", "LabeledStatement", "LiteralBooleanExpression", "LiteralInfinityExpression", "LiteralNullExpression", "LiteralNumericExpression", "LiteralRegExpExpression", "LiteralStringExpression", "MemberExpression", "Method", "MethodDefinition", "Module", "NamedObjectProperty", "NewExpression", "NewTargetExpression", "Node", "ObjectBinding", "ObjectExpression", "ObjectProperty", "PropertyName", "ReturnStatement", "Script", "Setter", "ShorthandProperty", "SourceLocation", "SourceSpan", "SpreadElement", "Statement", "StaticMemberExpression", "StaticPropertyName", "Super", "SwitchCase", "SwitchDefault", "SwitchStatement", "SwitchStatementWithDefault", "TemplateElement", "TemplateExpression", "ThisExpression", "ThrowStatement", "TryCatchStatement", "TryFinallyStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarationStatement", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "YieldGeneratorExpression"]
    };

    var VariableDeclarationKind = {
      typeName: "Enum",
      values: ["var", "let", "const"]
    };

    var CompoundAssignmentOperator = {
      typeName: "Enum",
      values: ["+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="]
    };

    var BinaryOperator = {
      typeName: "Enum",
      values: ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"]
    };

    var UnaryOperator = {
      typeName: "Enum",
      values: ["+", "-", "!", "~", "typeof", "void", "delete"]
    };

    var UpdateOperator = {
      typeName: "Enum",
      values: ["++", "--"]
    };

    var SourceLocation = SPEC.SourceLocation = {};
    var SourceSpan = SPEC.SourceSpan = {};
    var BindingWithDefault = SPEC.BindingWithDefault = {};
    var BindingIdentifier = SPEC.BindingIdentifier = {};
    var ArrayBinding = SPEC.ArrayBinding = {};
    var ObjectBinding = SPEC.ObjectBinding = {};
    var BindingPropertyIdentifier = SPEC.BindingPropertyIdentifier = {};
    var BindingPropertyProperty = SPEC.BindingPropertyProperty = {};
    var ClassExpression = SPEC.ClassExpression = {};
    var ClassDeclaration = SPEC.ClassDeclaration = {};
    var ClassElement = SPEC.ClassElement = {};
    var Module = SPEC.Module = {};
    var Import = SPEC.Import = {};
    var ImportNamespace = SPEC.ImportNamespace = {};
    var ImportSpecifier = SPEC.ImportSpecifier = {};
    var ExportAllFrom = SPEC.ExportAllFrom = {};
    var ExportFrom = SPEC.ExportFrom = {};
    var Export = SPEC.Export = {};
    var ExportDefault = SPEC.ExportDefault = {};
    var ExportSpecifier = SPEC.ExportSpecifier = {};
    var Method = SPEC.Method = {};
    var Getter = SPEC.Getter = {};
    var Setter = SPEC.Setter = {};
    var DataProperty = SPEC.DataProperty = {};
    var ShorthandProperty = SPEC.ShorthandProperty = {};
    var ComputedPropertyName = SPEC.ComputedPropertyName = {};
    var StaticPropertyName = SPEC.StaticPropertyName = {};
    var LiteralBooleanExpression = SPEC.LiteralBooleanExpression = {};
    var LiteralInfinityExpression = SPEC.LiteralInfinityExpression = {};
    var LiteralNullExpression = SPEC.LiteralNullExpression = {};
    var LiteralNumericExpression = SPEC.LiteralNumericExpression = {};
    var LiteralRegExpExpression = SPEC.LiteralRegExpExpression = {};
    var LiteralStringExpression = SPEC.LiteralStringExpression = {};
    var ArrayExpression = SPEC.ArrayExpression = {};
    var ArrowExpression = SPEC.ArrowExpression = {};
    var AssignmentExpression = SPEC.AssignmentExpression = {};
    var BinaryExpression = SPEC.BinaryExpression = {};
    var CallExpression = SPEC.CallExpression = {};
    var CompoundAssignmentExpression = SPEC.CompoundAssignmentExpression = {};
    var ComputedMemberExpression = SPEC.ComputedMemberExpression = {};
    var ConditionalExpression = SPEC.ConditionalExpression = {};
    var FunctionExpression = SPEC.FunctionExpression = {};
    var IdentifierExpression = SPEC.IdentifierExpression = {};
    var NewExpression = SPEC.NewExpression = {};
    var NewTargetExpression = SPEC.NewTargetExpression = {};
    var ObjectExpression = SPEC.ObjectExpression = {};
    var UnaryExpression = SPEC.UnaryExpression = {};
    var StaticMemberExpression = SPEC.StaticMemberExpression = {};
    var TemplateExpression = SPEC.TemplateExpression = {};
    var ThisExpression = SPEC.ThisExpression = {};
    var UpdateExpression = SPEC.UpdateExpression = {};
    var YieldExpression = SPEC.YieldExpression = {};
    var YieldGeneratorExpression = SPEC.YieldGeneratorExpression = {};
    var BlockStatement = SPEC.BlockStatement = {};
    var BreakStatement = SPEC.BreakStatement = {};
    var ContinueStatement = SPEC.ContinueStatement = {};
    var DebuggerStatement = SPEC.DebuggerStatement = {};
    var DoWhileStatement = SPEC.DoWhileStatement = {};
    var EmptyStatement = SPEC.EmptyStatement = {};
    var ExpressionStatement = SPEC.ExpressionStatement = {};
    var ForInStatement = SPEC.ForInStatement = {};
    var ForOfStatement = SPEC.ForOfStatement = {};
    var ForStatement = SPEC.ForStatement = {};
    var IfStatement = SPEC.IfStatement = {};
    var LabeledStatement = SPEC.LabeledStatement = {};
    var ReturnStatement = SPEC.ReturnStatement = {};
    var SwitchStatement = SPEC.SwitchStatement = {};
    var SwitchStatementWithDefault = SPEC.SwitchStatementWithDefault = {};
    var ThrowStatement = SPEC.ThrowStatement = {};
    var TryCatchStatement = SPEC.TryCatchStatement = {};
    var TryFinallyStatement = SPEC.TryFinallyStatement = {};
    var VariableDeclarationStatement = SPEC.VariableDeclarationStatement = {};
    var WhileStatement = SPEC.WhileStatement = {};
    var WithStatement = SPEC.WithStatement = {};
    var Block = SPEC.Block = {};
    var CatchClause = SPEC.CatchClause = {};
    var Directive = SPEC.Directive = {};
    var FormalParameters = SPEC.FormalParameters = {};
    var FunctionBody = SPEC.FunctionBody = {};
    var FunctionDeclaration = SPEC.FunctionDeclaration = {};
    var Script = SPEC.Script = {};
    var SpreadElement = SPEC.SpreadElement = {};
    var Super = SPEC.Super = {};
    var SwitchCase = SPEC.SwitchCase = {};
    var SwitchDefault = SPEC.SwitchDefault = {};
    var TemplateElement = SPEC.TemplateElement = {};
    var VariableDeclaration = SPEC.VariableDeclaration = {};
    var VariableDeclarator = SPEC.VariableDeclarator = {};

    var Class = Union(ClassExpression, ClassDeclaration);
    var BindingProperty = Union(BindingPropertyIdentifier, BindingPropertyProperty);
    var ExportDeclaration = Union(ExportAllFrom, ExportFrom, Export, ExportDefault);
    var ImportDeclaration = Union(Import, ImportNamespace);
    var MethodDefinition = Union(Method, Getter, Setter);
    var NamedObjectProperty = Union(MethodDefinition, DataProperty);
    var ObjectProperty = Union(NamedObjectProperty, ShorthandProperty);
    var PropertyName = Union(ComputedPropertyName, StaticPropertyName);
    var MemberExpression = Union(ComputedMemberExpression, StaticMemberExpression);
    var Expression = Union(MemberExpression, ClassExpression, LiteralBooleanExpression, LiteralInfinityExpression, LiteralNullExpression, LiteralNumericExpression, LiteralRegExpExpression, LiteralStringExpression, ArrayExpression, ArrowExpression, AssignmentExpression, BinaryExpression, CallExpression, CompoundAssignmentExpression, ConditionalExpression, FunctionExpression, IdentifierExpression, NewExpression, NewTargetExpression, ObjectExpression, UnaryExpression, TemplateExpression, ThisExpression, UpdateExpression, YieldExpression, YieldGeneratorExpression);
    var IterationStatement = Union(DoWhileStatement, ForInStatement, ForOfStatement, ForStatement, WhileStatement);
    var Statement = Union(IterationStatement, ClassDeclaration, BlockStatement, BreakStatement, ContinueStatement, DebuggerStatement, EmptyStatement, ExpressionStatement, IfStatement, LabeledStatement, ReturnStatement, SwitchStatement, SwitchStatementWithDefault, ThrowStatement, TryCatchStatement, TryFinallyStatement, VariableDeclarationStatement, WithStatement, FunctionDeclaration);
    var Node = Union(Statement, Expression, PropertyName, ObjectProperty, ImportDeclaration, ExportDeclaration, BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding, BindingProperty, ClassElement, Module, ImportSpecifier, ExportSpecifier, Block, CatchClause, Directive, FormalParameters, FunctionBody, Script, SpreadElement, Super, SwitchCase, SwitchDefault, TemplateElement, VariableDeclaration, VariableDeclarator);
    var Function = Union(FunctionExpression, FunctionDeclaration);

    SourceLocation.typeName = "SourceLocation";
    SourceLocation.fields = [{ name: "line", type: DOUBLE }, { name: "column", type: DOUBLE }, { name: "offset", type: DOUBLE }];

    SourceSpan.typeName = "SourceSpan";
    SourceSpan.fields = [{ name: "source", type: Maybe(STRING) }, { name: "start", type: SourceLocation }, { name: "end", type: SourceLocation }];

    BindingWithDefault.typeName = "BindingWithDefault";
    BindingWithDefault.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BindingWithDefault" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "init", type: Expression }];

    BindingIdentifier.typeName = "BindingIdentifier";
    BindingIdentifier.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BindingIdentifier" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: STRING }];

    ArrayBinding.typeName = "ArrayBinding";
    ArrayBinding.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ArrayBinding" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "elements", type: List(Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault))) }, { name: "restElement", type: Maybe(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression)) }];

    ObjectBinding.typeName = "ObjectBinding";
    ObjectBinding.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ObjectBinding" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "properties", type: List(BindingProperty) }];

    BindingPropertyIdentifier.typeName = "BindingPropertyIdentifier";
    BindingPropertyIdentifier.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyIdentifier" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "binding", type: BindingIdentifier }, { name: "init", type: Maybe(Expression) }];

    BindingPropertyProperty.typeName = "BindingPropertyProperty";
    BindingPropertyProperty.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BindingPropertyProperty" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: PropertyName }, { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) }];

    ClassExpression.typeName = "ClassExpression";
    ClassExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ClassExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: Maybe(BindingIdentifier) }, { name: "super", type: Maybe(Expression) }, { name: "elements", type: List(ClassElement) }];

    ClassDeclaration.typeName = "ClassDeclaration";
    ClassDeclaration.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ClassDeclaration" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: BindingIdentifier }, { name: "super", type: Maybe(Expression) }, { name: "elements", type: List(ClassElement) }];

    ClassElement.typeName = "ClassElement";
    ClassElement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ClassElement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "isStatic", type: BOOLEAN }, { name: "method", type: MethodDefinition }];

    Module.typeName = "Module";
    Module.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Module" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "directives", type: List(Directive) }, { name: "items", type: List(Union(ImportDeclaration, ExportDeclaration, Statement)) }];

    Import.typeName = "Import";
    Import.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Import" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "moduleSpecifier", type: STRING }, { name: "defaultBinding", type: Maybe(BindingIdentifier) }, { name: "namedImports", type: List(ImportSpecifier) }];

    ImportNamespace.typeName = "ImportNamespace";
    ImportNamespace.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ImportNamespace" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "moduleSpecifier", type: STRING }, { name: "defaultBinding", type: Maybe(BindingIdentifier) }, { name: "namespaceBinding", type: BindingIdentifier }];

    ImportSpecifier.typeName = "ImportSpecifier";
    ImportSpecifier.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ImportSpecifier" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: Maybe(STRING) }, { name: "binding", type: BindingIdentifier }];

    ExportAllFrom.typeName = "ExportAllFrom";
    ExportAllFrom.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ExportAllFrom" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "moduleSpecifier", type: STRING }];

    ExportFrom.typeName = "ExportFrom";
    ExportFrom.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ExportFrom" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "namedExports", type: List(ExportSpecifier) }, { name: "moduleSpecifier", type: Maybe(STRING) }];

    Export.typeName = "Export";
    Export.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Export" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "declaration", type: Union(FunctionDeclaration, ClassDeclaration, VariableDeclaration) }];

    ExportDefault.typeName = "ExportDefault";
    ExportDefault.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ExportDefault" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "body", type: Union(FunctionDeclaration, ClassDeclaration, Expression) }];

    ExportSpecifier.typeName = "ExportSpecifier";
    ExportSpecifier.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ExportSpecifier" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: Maybe(STRING) }, { name: "exportedName", type: STRING }];

    Method.typeName = "Method";
    Method.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Method" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: PropertyName }, { name: "isGenerator", type: BOOLEAN }, { name: "params", type: FormalParameters }, { name: "body", type: FunctionBody }];

    Getter.typeName = "Getter";
    Getter.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Getter" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: PropertyName }, { name: "body", type: FunctionBody }];

    Setter.typeName = "Setter";
    Setter.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Setter" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: PropertyName }, { name: "param", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault) }, { name: "body", type: FunctionBody }];

    DataProperty.typeName = "DataProperty";
    DataProperty.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "DataProperty" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: PropertyName }, { name: "expression", type: Expression }];

    ShorthandProperty.typeName = "ShorthandProperty";
    ShorthandProperty.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ShorthandProperty" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: STRING }];

    ComputedPropertyName.typeName = "ComputedPropertyName";
    ComputedPropertyName.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ComputedPropertyName" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Expression }];

    StaticPropertyName.typeName = "StaticPropertyName";
    StaticPropertyName.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "StaticPropertyName" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "value", type: STRING }];

    LiteralBooleanExpression.typeName = "LiteralBooleanExpression";
    LiteralBooleanExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralBooleanExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "value", type: BOOLEAN }];

    LiteralInfinityExpression.typeName = "LiteralInfinityExpression";
    LiteralInfinityExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralInfinityExpression" }, { name: "loc", type: Maybe(SourceSpan) }];

    LiteralNullExpression.typeName = "LiteralNullExpression";
    LiteralNullExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNullExpression" }, { name: "loc", type: Maybe(SourceSpan) }];

    LiteralNumericExpression.typeName = "LiteralNumericExpression";
    LiteralNumericExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralNumericExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "value", type: DOUBLE }];

    LiteralRegExpExpression.typeName = "LiteralRegExpExpression";
    LiteralRegExpExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralRegExpExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "pattern", type: STRING }, { name: "flags", type: STRING }];

    LiteralStringExpression.typeName = "LiteralStringExpression";
    LiteralStringExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LiteralStringExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "value", type: STRING }];

    ArrayExpression.typeName = "ArrayExpression";
    ArrayExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ArrayExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "elements", type: List(Maybe(Union(SpreadElement, Expression))) }];

    ArrowExpression.typeName = "ArrowExpression";
    ArrowExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ArrowExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "params", type: FormalParameters }, { name: "body", type: Union(FunctionBody, Expression) }];

    AssignmentExpression.typeName = "AssignmentExpression";
    AssignmentExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "AssignmentExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "expression", type: Expression }];

    BinaryExpression.typeName = "BinaryExpression";
    BinaryExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BinaryExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "operator", type: BinaryOperator }, { name: "left", type: Expression }, { name: "right", type: Expression }];

    CallExpression.typeName = "CallExpression";
    CallExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "CallExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "callee", type: Union(Expression, Super) }, { name: "arguments", type: List(Union(SpreadElement, Expression)) }];

    CompoundAssignmentExpression.typeName = "CompoundAssignmentExpression";
    CompoundAssignmentExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "CompoundAssignmentExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "operator", type: CompoundAssignmentOperator }, { name: "binding", type: Union(BindingIdentifier, MemberExpression) }, { name: "expression", type: Expression }];

    ComputedMemberExpression.typeName = "ComputedMemberExpression";
    ComputedMemberExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ComputedMemberExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "object", type: Union(Expression, Super) }, { name: "expression", type: Expression }];

    ConditionalExpression.typeName = "ConditionalExpression";
    ConditionalExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ConditionalExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "test", type: Expression }, { name: "consequent", type: Expression }, { name: "alternate", type: Expression }];

    FunctionExpression.typeName = "FunctionExpression";
    FunctionExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "FunctionExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "isGenerator", type: BOOLEAN }, { name: "name", type: Maybe(BindingIdentifier) }, { name: "params", type: FormalParameters }, { name: "body", type: FunctionBody }];

    IdentifierExpression.typeName = "IdentifierExpression";
    IdentifierExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "IdentifierExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "name", type: STRING }];

    NewExpression.typeName = "NewExpression";
    NewExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "NewExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "callee", type: Expression }, { name: "arguments", type: List(Union(SpreadElement, Expression)) }];

    NewTargetExpression.typeName = "NewTargetExpression";
    NewTargetExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "NewTargetExpression" }, { name: "loc", type: Maybe(SourceSpan) }];

    ObjectExpression.typeName = "ObjectExpression";
    ObjectExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ObjectExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "properties", type: List(ObjectProperty) }];

    UnaryExpression.typeName = "UnaryExpression";
    UnaryExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "UnaryExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "operator", type: UnaryOperator }, { name: "operand", type: Expression }];

    StaticMemberExpression.typeName = "StaticMemberExpression";
    StaticMemberExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "StaticMemberExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "object", type: Union(Expression, Super) }, { name: "property", type: STRING }];

    TemplateExpression.typeName = "TemplateExpression";
    TemplateExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "TemplateExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "tag", type: Maybe(Expression) }, { name: "elements", type: List(Union(Expression, TemplateElement)) }];

    ThisExpression.typeName = "ThisExpression";
    ThisExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ThisExpression" }, { name: "loc", type: Maybe(SourceSpan) }];

    UpdateExpression.typeName = "UpdateExpression";
    UpdateExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "UpdateExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "isPrefix", type: BOOLEAN }, { name: "operator", type: UpdateOperator }, { name: "operand", type: Union(BindingIdentifier, MemberExpression) }];

    YieldExpression.typeName = "YieldExpression";
    YieldExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "YieldExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Maybe(Expression) }];

    YieldGeneratorExpression.typeName = "YieldGeneratorExpression";
    YieldGeneratorExpression.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "YieldGeneratorExpression" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Expression }];

    BlockStatement.typeName = "BlockStatement";
    BlockStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BlockStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "block", type: Block }];

    BreakStatement.typeName = "BreakStatement";
    BreakStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "BreakStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "label", type: Maybe(STRING) }];

    ContinueStatement.typeName = "ContinueStatement";
    ContinueStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ContinueStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "label", type: Maybe(STRING) }];

    DebuggerStatement.typeName = "DebuggerStatement";
    DebuggerStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "DebuggerStatement" }, { name: "loc", type: Maybe(SourceSpan) }];

    DoWhileStatement.typeName = "DoWhileStatement";
    DoWhileStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "DoWhileStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "body", type: Statement }, { name: "test", type: Expression }];

    EmptyStatement.typeName = "EmptyStatement";
    EmptyStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "EmptyStatement" }, { name: "loc", type: Maybe(SourceSpan) }];

    ExpressionStatement.typeName = "ExpressionStatement";
    ExpressionStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ExpressionStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Expression }];

    ForInStatement.typeName = "ForInStatement";
    ForInStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ForInStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "right", type: Expression }, { name: "body", type: Statement }];

    ForOfStatement.typeName = "ForOfStatement";
    ForOfStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ForOfStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "left", type: Union(VariableDeclaration, ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "right", type: Expression }, { name: "body", type: Statement }];

    ForStatement.typeName = "ForStatement";
    ForStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ForStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "init", type: Maybe(Union(VariableDeclaration, Expression)) }, { name: "test", type: Maybe(Expression) }, { name: "update", type: Maybe(Expression) }, { name: "body", type: Statement }];

    IfStatement.typeName = "IfStatement";
    IfStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "IfStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "test", type: Expression }, { name: "consequent", type: Statement }, { name: "alternate", type: Maybe(Statement) }];

    LabeledStatement.typeName = "LabeledStatement";
    LabeledStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "LabeledStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "label", type: STRING }, { name: "body", type: Statement }];

    ReturnStatement.typeName = "ReturnStatement";
    ReturnStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ReturnStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Maybe(Expression) }];

    SwitchStatement.typeName = "SwitchStatement";
    SwitchStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "discriminant", type: Expression }, { name: "cases", type: List(SwitchCase) }];

    SwitchStatementWithDefault.typeName = "SwitchStatementWithDefault";
    SwitchStatementWithDefault.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "SwitchStatementWithDefault" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "discriminant", type: Expression }, { name: "preDefaultCases", type: List(SwitchCase) }, { name: "defaultCase", type: SwitchDefault }, { name: "postDefaultCases", type: List(SwitchCase) }];

    ThrowStatement.typeName = "ThrowStatement";
    ThrowStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "ThrowStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Expression }];

    TryCatchStatement.typeName = "TryCatchStatement";
    TryCatchStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "TryCatchStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "body", type: Block }, { name: "catchClause", type: CatchClause }];

    TryFinallyStatement.typeName = "TryFinallyStatement";
    TryFinallyStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "TryFinallyStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "body", type: Block }, { name: "catchClause", type: Maybe(CatchClause) }, { name: "finalizer", type: Block }];

    VariableDeclarationStatement.typeName = "VariableDeclarationStatement";
    VariableDeclarationStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarationStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "declaration", type: VariableDeclaration }];

    WhileStatement.typeName = "WhileStatement";
    WhileStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "WhileStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "test", type: Expression }, { name: "body", type: Statement }];

    WithStatement.typeName = "WithStatement";
    WithStatement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "WithStatement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "object", type: Expression }, { name: "body", type: Statement }];

    Block.typeName = "Block";
    Block.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Block" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "statements", type: List(Statement) }];

    CatchClause.typeName = "CatchClause";
    CatchClause.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "CatchClause" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "body", type: Block }];

    Directive.typeName = "Directive";
    Directive.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Directive" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "rawValue", type: STRING }];

    FormalParameters.typeName = "FormalParameters";
    FormalParameters.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "FormalParameters" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "items", type: List(Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression, BindingWithDefault)) }, { name: "rest", type: Maybe(BindingIdentifier) }];

    FunctionBody.typeName = "FunctionBody";
    FunctionBody.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "FunctionBody" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "directives", type: List(Directive) }, { name: "statements", type: List(Statement) }];

    FunctionDeclaration.typeName = "FunctionDeclaration";
    FunctionDeclaration.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "FunctionDeclaration" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "isGenerator", type: BOOLEAN }, { name: "name", type: BindingIdentifier }, { name: "params", type: FormalParameters }, { name: "body", type: FunctionBody }];

    Script.typeName = "Script";
    Script.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Script" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "directives", type: List(Directive) }, { name: "statements", type: List(Statement) }];

    SpreadElement.typeName = "SpreadElement";
    SpreadElement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "SpreadElement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "expression", type: Expression }];

    Super.typeName = "Super";
    Super.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "Super" }, { name: "loc", type: Maybe(SourceSpan) }];

    SwitchCase.typeName = "SwitchCase";
    SwitchCase.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "SwitchCase" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "test", type: Expression }, { name: "consequent", type: List(Statement) }];

    SwitchDefault.typeName = "SwitchDefault";
    SwitchDefault.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "SwitchDefault" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "consequent", type: List(Statement) }];

    TemplateElement.typeName = "TemplateElement";
    TemplateElement.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "TemplateElement" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "rawValue", type: STRING }];

    VariableDeclaration.typeName = "VariableDeclaration";
    VariableDeclaration.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclaration" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "kind", type: VariableDeclarationKind }, { name: "declarators", type: List(VariableDeclarator) }];

    VariableDeclarator.typeName = "VariableDeclarator";
    VariableDeclarator.fields = [{ name: "type", type: Const(TYPE_INDICATOR), value: "VariableDeclarator" }, { name: "loc", type: Maybe(SourceSpan) }, { name: "binding", type: Union(ObjectBinding, ArrayBinding, BindingIdentifier, MemberExpression) }, { name: "init", type: Maybe(Expression) }];

    return SPEC;
  }();
});
System.registerDynamic("npm:shift-reducer@3.0.3.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-reducer@3.0.3/dist/index.js", ["./clone-reducer", "./monoidal-reducer", "shift-spec"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MonoidalReducer = exports.CloneReducer = undefined;
  exports.default = reduce;

  var _cloneReducer = $__require("./clone-reducer");

  Object.defineProperty(exports, "CloneReducer", {
    enumerable: true,
    get: function get() {
      return _cloneReducer.default;
    }
  });

  var _monoidalReducer = $__require("./monoidal-reducer");

  Object.defineProperty(exports, "MonoidalReducer", {
    enumerable: true,
    get: function get() {
      return _monoidalReducer.default;
    }
  });

  var _shiftSpec = $__require("shift-spec");

  var _shiftSpec2 = _interopRequireDefault(_shiftSpec);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function transformWithSpec(transformer, node, spec) {
    switch (spec.typeName) {
      case "Enum":
      case "String":
      case "Number":
      case "Boolean":
      case "SourceSpan":
        return node;
      case "Const":
        // TODO: checked version
        return transformWithSpec(transformer, node, spec.argument);
      case "Maybe":
        return node && transformWithSpec(transformer, node, spec.argument);
      case "List":
        return node.map(function (e) {
          return transformWithSpec(transformer, e, spec.argument);
        });
      case "Union":
        // TODO: checked version
        return transformWithSpec(transformer, node, _shiftSpec2.default[node.type]);
      default:
        var state = {};
        spec.fields.forEach(function (field) {
          var v = transformWithSpec(transformer, node[field.name], field.type);
          state[field.name] = v == null ? null : v;
        });
        if (typeof transformer["reduce" + node.type] !== "function") {
          throw new Error("Encountered " + node.type + ", which the provided reducer does not handle.");
        }
        return transformer["reduce" + node.type](node, state);
    }
  } /**
     * Copyright 2014 Shape Security, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License")
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

  function reduce(reducer, reducible) {
    return transformWithSpec(reducer, reducible, _shiftSpec2.default[reducible.type]);
  }
});
System.registerDynamic("npm:base64-js@1.2.0.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:base64-js@1.2.0/index.js', [], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  exports.byteLength = byteLength;
  exports.toByteArray = toByteArray;
  exports.fromByteArray = fromByteArray;

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function placeHoldersCount(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
  }

  function byteLength(b64) {
    // base64 is 4/3 + up to two characters of the original data
    return b64.length * 3 / 4 - placeHoldersCount(b64);
  }

  function toByteArray(b64) {
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    placeHolders = placeHoldersCount(b64);

    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('');
  }
});
System.registerDynamic("npm:ieee754@1.1.8.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "test/*": {
        "globals": {
          "Buffer": "buffer/global"
        }
      }
    }
  };
});

System.registerDynamic("npm:ieee754@1.1.8/index.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };
});
System.registerDynamic("npm:isarray@1.0.0.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:isarray@1.0.0/index.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var toString = {}.toString;

  module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };
});
System.registerDynamic("npm:buffer@4.9.1.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      },
      "test/constructor.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "test/node/*": {
        "globals": {
          "Buffer": "buffer/global"
        }
      }
    }
  };
});

System.registerDynamic('npm:buffer@4.9.1/index.js', ['base64-js', 'ieee754', 'isarray', 'process'], true, function ($__require, exports, module) {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */

  'use strict';

  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  var base64 = $__require('base64-js');
  var ieee754 = $__require('ieee754');
  var isArray = $__require('isarray');

  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

  /*
   * Export kMaxLength after typed array support is determined.
   */
  exports.kMaxLength = kMaxLength();

  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
          return 42;
        } };
      return arr.foo() === 42 && // typed array instances can be augmented
      typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
      arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
    } catch (e) {
      return false;
    }
  }

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that;
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
      // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true
      });
    }
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }
    return createBuffer(that, size);
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that;
  }

  function fromObject(that, obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }
    return length | 0;
  }

  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length);
  }

  Buffer.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer;
  };

  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0;

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
      // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;

          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  }
});
System.registerDynamic("npm:jspm-nodelibs-buffer@0.2.1.json", [], true, function() {
  return {
    "main": "buffer.js",
    "map": {
      "./buffer.js": {
        "browser": "buffer"
      }
    }
  };
});

System.registerDynamic('npm:jspm-nodelibs-buffer@0.2.1/global.js', ['./buffer.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require('./buffer.js').Buffer;
});
System.registerDynamic("npm:transit-js@0.8.846.json", [], true, function() {
  return {
    "main": "transit.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "src/com/cognitect/transit/handlers.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "src/com/cognitect/transit/types.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      },
      "src/com/cognitect/transit_amd.js": {
        "format": "amd"
      },
      "transit.js": {
        "globals": {
          "Buffer": "buffer/global"
        }
      }
    }
  };
});

System.registerDynamic("npm:transit-js@0.8.846/transit.js", ["buffer/global"], true, function ($__require, exports, module) {
  var Buffer = $__require("buffer/global");
  var global = this || self,
      GLOBAL = global;
  // transit-js 0.8.847
  // http://transit-format.org
  // 
  // Copyright 2014 Cognitect. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License..
  var COMPILED = !0,
      goog = goog || {};
  goog.global = exports;
  goog.isDef = function (a) {
    return void 0 !== a;
  };
  goog.exportPath_ = function (a, b, c) {
    a = a.split(".");
    c = c || goog.global;
    a[0] in c || !c.execScript || c.execScript("var " + a[0]);
    for (var d; a.length && (d = a.shift());) {
      !a.length && goog.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {};
    }
  };
  goog.define = function (a, b) {
    var c = b;
    COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, a) ? c = goog.global.CLOSURE_UNCOMPILED_DEFINES[a] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]));
    goog.exportPath_(a, c);
  };
  goog.DEBUG = !0;
  goog.LOCALE = "en";
  goog.TRUSTED_SITE = !0;
  goog.STRICT_MODE_COMPATIBLE = !1;
  goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
  goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
  goog.provide = function (a) {
    if (!COMPILED && goog.isProvided_(a)) {
      throw Error('Namespace "' + a + '" already declared.');
    }
    goog.constructNamespace_(a);
  };
  goog.constructNamespace_ = function (a, b) {
    if (!COMPILED) {
      delete goog.implicitNamespaces_[a];
      for (var c = a; (c = c.substring(0, c.lastIndexOf("."))) && !goog.getObjectByName(c);) {
        goog.implicitNamespaces_[c] = !0;
      }
    }
    goog.exportPath_(a, b);
  };
  goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
  goog.module = function (a) {
    if (!goog.isString(a) || !a || -1 == a.search(goog.VALID_MODULE_RE_)) {
      throw Error("Invalid module identifier");
    }
    if (!goog.isInModuleLoader_()) {
      throw Error("Module " + a + " has been loaded incorrectly.");
    }
    if (goog.moduleLoaderState_.moduleName) {
      throw Error("goog.module may only be called once per module.");
    }
    goog.moduleLoaderState_.moduleName = a;
    if (!COMPILED) {
      if (goog.isProvided_(a)) {
        throw Error('Namespace "' + a + '" already declared.');
      }
      delete goog.implicitNamespaces_[a];
    }
  };
  goog.module.get = function (a) {
    return goog.module.getInternal_(a);
  };
  goog.module.getInternal_ = function (a) {
    if (!COMPILED) {
      return goog.isProvided_(a) ? a in goog.loadedModules_ ? goog.loadedModules_[a] : goog.getObjectByName(a) : null;
    }
  };
  goog.moduleLoaderState_ = null;
  goog.isInModuleLoader_ = function () {
    return null != goog.moduleLoaderState_;
  };
  goog.module.declareTestMethods = function () {
    if (!goog.isInModuleLoader_()) {
      throw Error("goog.module.declareTestMethods must be called from within a goog.module");
    }
    goog.moduleLoaderState_.declareTestMethods = !0;
  };
  goog.module.declareLegacyNamespace = function () {
    if (!COMPILED && !goog.isInModuleLoader_()) {
      throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
    }
    if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
      throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
    }
    goog.moduleLoaderState_.declareLegacyNamespace = !0;
  };
  goog.setTestOnly = function (a) {
    if (goog.DISALLOW_TEST_ONLY_CODE) {
      throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
    }
  };
  goog.forwardDeclare = function (a) {};
  COMPILED || (goog.isProvided_ = function (a) {
    return a in goog.loadedModules_ || !goog.implicitNamespaces_[a] && goog.isDefAndNotNull(goog.getObjectByName(a));
  }, goog.implicitNamespaces_ = { "goog.module": !0 });
  goog.getObjectByName = function (a, b) {
    for (var c = a.split("."), d = b || goog.global, e; e = c.shift();) {
      if (goog.isDefAndNotNull(d[e])) {
        d = d[e];
      } else {
        return null;
      }
    }
    return d;
  };
  goog.globalize = function (a, b) {
    var c = b || goog.global,
        d;
    for (d in a) {
      c[d] = a[d];
    }
  };
  goog.addDependency = function (a, b, c, d) {
    if (goog.DEPENDENCIES_ENABLED) {
      var e;
      a = a.replace(/\\/g, "/");
      for (var f = goog.dependencies_, g = 0; e = b[g]; g++) {
        f.nameToPath[e] = a, f.pathIsModule[a] = !!d;
      }
      for (d = 0; b = c[d]; d++) {
        a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0;
      }
    }
  };
  goog.ENABLE_DEBUG_LOADER = !0;
  goog.logToConsole_ = function (a) {
    goog.global.console && goog.global.console.error(a);
  };
  goog.require = function (a) {
    if (!COMPILED) {
      goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_ && goog.maybeProcessDeferredDep_(a);
      if (goog.isProvided_(a)) {
        return goog.isInModuleLoader_() ? goog.module.getInternal_(a) : null;
      }
      if (goog.ENABLE_DEBUG_LOADER) {
        var b = goog.getPathFromDeps_(a);
        if (b) {
          return goog.included_[b] = !0, goog.writeScripts_(), null;
        }
      }
      a = "goog.require could not find: " + a;
      goog.logToConsole_(a);
      throw Error(a);
    }
  };
  goog.basePath = "";
  goog.nullFunction = function () {};
  goog.abstractMethod = function () {
    throw Error("unimplemented abstract method");
  };
  goog.addSingletonGetter = function (a) {
    a.getInstance = function () {
      if (a.instance_) {
        return a.instance_;
      }
      goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
      return a.instance_ = new a();
    };
  };
  goog.instantiatedSingletons_ = [];
  goog.LOAD_MODULE_USING_EVAL = !0;
  goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
  goog.loadedModules_ = {};
  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
  goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = { pathIsModule: {}, nameToPath: {}, requires: {}, visited: {}, written: {}, deferred: {} }, goog.inHtmlDocument_ = function () {
    var a = goog.global.document;
    return "undefined" != typeof a && "write" in a;
  }, goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
    } else {
      if (goog.inHtmlDocument_()) {
        for (var a = goog.global.document.getElementsByTagName("SCRIPT"), b = a.length - 1; 0 <= b; --b) {
          var c = a[b].src,
              d = c.lastIndexOf("?"),
              d = -1 == d ? c.length : d;
          if ("base.js" == c.substr(d - 7, 7)) {
            goog.basePath = c.substr(0, d - 7);
            break;
          }
        }
      }
    }
  }, goog.importScript_ = function (a, b) {
    (goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_)(a, b) && (goog.dependencies_.written[a] = !0);
  }, goog.IS_OLD_IE_ = !goog.global.atob && goog.global.document && goog.global.document.all, goog.importModule_ = function (a) {
    goog.importScript_("", 'goog.retrieveAndExecModule_("' + a + '");') && (goog.dependencies_.written[a] = !0);
  }, goog.queuedModules_ = [], goog.wrapModule_ = function (a, b) {
    return goog.LOAD_MODULE_USING_EVAL && goog.isDef(goog.global.JSON) ? "goog.loadModule(" + goog.global.JSON.stringify(b + "\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n";
  }, goog.loadQueuedModules_ = function () {
    var a = goog.queuedModules_.length;
    if (0 < a) {
      var b = goog.queuedModules_;
      goog.queuedModules_ = [];
      for (var c = 0; c < a; c++) {
        goog.maybeProcessDeferredPath_(b[c]);
      }
    }
  }, goog.maybeProcessDeferredDep_ = function (a) {
    goog.isDeferredModule_(a) && goog.allDepsAreAvailable_(a) && (a = goog.getPathFromDeps_(a), goog.maybeProcessDeferredPath_(goog.basePath + a));
  }, goog.isDeferredModule_ = function (a) {
    return (a = goog.getPathFromDeps_(a)) && goog.dependencies_.pathIsModule[a] ? goog.basePath + a in goog.dependencies_.deferred : !1;
  }, goog.allDepsAreAvailable_ = function (a) {
    if ((a = goog.getPathFromDeps_(a)) && a in goog.dependencies_.requires) {
      for (var b in goog.dependencies_.requires[a]) {
        if (!goog.isProvided_(b) && !goog.isDeferredModule_(b)) {
          return !1;
        }
      }
    }
    return !0;
  }, goog.maybeProcessDeferredPath_ = function (a) {
    if (a in goog.dependencies_.deferred) {
      var b = goog.dependencies_.deferred[a];
      delete goog.dependencies_.deferred[a];
      goog.globalEval(b);
    }
  }, goog.loadModule = function (a) {
    var b = goog.moduleLoaderState_;
    try {
      goog.moduleLoaderState_ = { moduleName: void 0, declareTestMethods: !1 };
      var c;
      if (goog.isFunction(a)) {
        c = a.call(goog.global, {});
      } else {
        if (goog.isString(a)) {
          c = goog.loadModuleFromSource_.call(goog.global, a);
        } else {
          throw Error("Invalid module definition");
        }
      }
      var d = goog.moduleLoaderState_.moduleName;
      if (!goog.isString(d) || !d) {
        throw Error('Invalid module name "' + d + '"');
      }
      goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(d, c) : goog.SEAL_MODULE_EXPORTS && Object.seal && Object.seal(c);
      goog.loadedModules_[d] = c;
      if (goog.moduleLoaderState_.declareTestMethods) {
        for (var e in c) {
          if (0 === e.indexOf("test", 0) || "tearDown" == e || "setUp" == e || "setUpPage" == e || "tearDownPage" == e) {
            goog.global[e] = c[e];
          }
        }
      }
    } finally {
      goog.moduleLoaderState_ = b;
    }
  }, goog.loadModuleFromSource_ = function (a) {
    eval(a);
    return {};
  }, goog.writeScriptSrcNode_ = function (a) {
    goog.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>');
  }, goog.appendScriptSrcNode_ = function (a) {
    var b = goog.global.document,
        c = b.createElement("script");
    c.type = "text/javascript";
    c.src = a;
    c.defer = !1;
    c.async = !1;
    b.head.appendChild(c);
  }, goog.writeScriptTag_ = function (a, b) {
    if (goog.inHtmlDocument_()) {
      var c = goog.global.document;
      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
        if (/\bdeps.js$/.test(a)) {
          return !1;
        }
        throw Error('Cannot write "' + a + '" after document load');
      }
      var d = goog.IS_OLD_IE_;
      void 0 === b ? d ? (d = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + d + ">\x3c/script>")) : goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? goog.appendScriptSrcNode_(a) : goog.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + b + "\x3c/script>");
      return !0;
    }
    return !1;
  }, goog.lastNonModuleScriptIndex_ = 0, goog.onScriptLoad_ = function (a, b) {
    "complete" == a.readyState && goog.lastNonModuleScriptIndex_ == b && goog.loadQueuedModules_();
    return !0;
  }, goog.writeScripts_ = function () {
    function a(e) {
      if (!(e in d.written)) {
        if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires)) {
          for (var f in d.requires[e]) {
            if (!goog.isProvided_(f)) {
              if (f in d.nameToPath) {
                a(d.nameToPath[f]);
              } else {
                throw Error("Undefined nameToPath for " + f);
              }
            }
          }
        }
        e in c || (c[e] = !0, b.push(e));
      }
    }
    var b = [],
        c = {},
        d = goog.dependencies_,
        e;
    for (e in goog.included_) {
      d.written[e] || a(e);
    }
    for (var f = 0; f < b.length; f++) {
      e = b[f], goog.dependencies_.written[e] = !0;
    }
    var g = goog.moduleLoaderState_;
    goog.moduleLoaderState_ = null;
    for (f = 0; f < b.length; f++) {
      if (e = b[f]) {
        d.pathIsModule[e] ? goog.importModule_(goog.basePath + e) : goog.importScript_(goog.basePath + e);
      } else {
        throw goog.moduleLoaderState_ = g, Error("Undefined script input");
      }
    }
    goog.moduleLoaderState_ = g;
  }, goog.getPathFromDeps_ = function (a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
  }, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + "deps.js"));
  goog.normalizePath_ = function (a) {
    a = a.split("/");
    for (var b = 0; b < a.length;) {
      "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
    }
    return a.join("/");
  };
  goog.loadFileSync_ = function (a) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
      return goog.global.CLOSURE_LOAD_FILE_SYNC(a);
    }
    var b = new goog.global.XMLHttpRequest();
    b.open("get", a, !1);
    b.send();
    return b.responseText;
  };
  goog.retrieveAndExecModule_ = function (a) {
    if (!COMPILED) {
      var b = a;
      a = goog.normalizePath_(a);
      var c = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_,
          d = goog.loadFileSync_(a);
      if (null != d) {
        d = goog.wrapModule_(a, d), goog.IS_OLD_IE_ ? (goog.dependencies_.deferred[b] = d, goog.queuedModules_.push(b)) : c(a, d);
      } else {
        throw Error("load of " + a + "failed");
      }
    }
  };
  goog.typeOf = function (a) {
    var b = typeof a;
    if ("object" == b) {
      if (a) {
        if (a instanceof Array) {
          return "array";
        }
        if (a instanceof Object) {
          return b;
        }
        var c = Object.prototype.toString.call(a);
        if ("[object Window]" == c) {
          return "object";
        }
        if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
          return "array";
        }
        if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
          return "function";
        }
      } else {
        return "null";
      }
    } else {
      if ("function" == b && "undefined" == typeof a.call) {
        return "object";
      }
    }
    return b;
  };
  goog.isNull = function (a) {
    return null === a;
  };
  goog.isDefAndNotNull = function (a) {
    return null != a;
  };
  goog.isArray = function (a) {
    return "array" == goog.typeOf(a);
  };
  goog.isArrayLike = function (a) {
    var b = goog.typeOf(a);
    return "array" == b || "object" == b && "number" == typeof a.length;
  };
  goog.isDateLike = function (a) {
    return goog.isObject(a) && "function" == typeof a.getFullYear;
  };
  goog.isString = function (a) {
    return "string" == typeof a;
  };
  goog.isBoolean = function (a) {
    return "boolean" == typeof a;
  };
  goog.isNumber = function (a) {
    return "number" == typeof a;
  };
  goog.isFunction = function (a) {
    return "function" == goog.typeOf(a);
  };
  goog.isObject = function (a) {
    var b = typeof a;
    return "object" == b && null != a || "function" == b;
  };
  goog.getUid = function (a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  };
  goog.hasUid = function (a) {
    return !!a[goog.UID_PROPERTY_];
  };
  goog.removeUid = function (a) {
    "removeAttribute" in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete a[goog.UID_PROPERTY_];
    } catch (b) {}
  };
  goog.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
  goog.uidCounter_ = 0;
  goog.getHashCode = goog.getUid;
  goog.removeHashCode = goog.removeUid;
  goog.cloneObject = function (a) {
    var b = goog.typeOf(a);
    if ("object" == b || "array" == b) {
      if (a.clone) {
        return a.clone();
      }
      var b = "array" == b ? [] : {},
          c;
      for (c in a) {
        b[c] = goog.cloneObject(a[c]);
      }
      return b;
    }
    return a;
  };
  goog.bindNative_ = function (a, b, c) {
    return a.call.apply(a.bind, arguments);
  };
  goog.bindJs_ = function (a, b, c) {
    if (!a) {
      throw Error();
    }
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function () {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }
    return function () {
      return a.apply(b, arguments);
    };
  };
  goog.bind = function (a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments);
  };
  goog.partial = function (a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function () {
      var b = c.slice();
      b.push.apply(b, arguments);
      return a.apply(this, b);
    };
  };
  goog.mixin = function (a, b) {
    for (var c in b) {
      a[c] = b[c];
    }
  };
  goog.now = goog.TRUSTED_SITE && Date.now || function () {
    return +new Date();
  };
  goog.globalEval = function (a) {
    if (goog.global.execScript) {
      goog.global.execScript(a, "JavaScript");
    } else {
      if (goog.global.eval) {
        if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), "undefined" != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) {
          goog.global.eval(a);
        } else {
          var b = goog.global.document,
              c = b.createElement("SCRIPT");
          c.type = "text/javascript";
          c.defer = !1;
          c.appendChild(b.createTextNode(a));
          b.body.appendChild(c);
          b.body.removeChild(c);
        }
      } else {
        throw Error("goog.globalEval not available");
      }
    }
  };
  goog.evalWorksForGlobals_ = null;
  goog.getCssName = function (a, b) {
    var c = function (a) {
      return goog.cssNameMapping_[a] || a;
    },
        d = function (a) {
      a = a.split("-");
      for (var b = [], d = 0; d < a.length; d++) {
        b.push(c(a[d]));
      }
      return b.join("-");
    },
        d = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c : d : function (a) {
      return a;
    };
    return b ? a + "-" + d(b) : d(a);
  };
  goog.setCssNameMapping = function (a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b;
  };
  !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
  goog.getMsg = function (a, b) {
    b && (a = a.replace(/\{\$([^}]+)}/g, function (a, d) {
      return d in b ? b[d] : a;
    }));
    return a;
  };
  goog.getMsgWithFallback = function (a, b) {
    return a;
  };
  goog.exportSymbol = function (a, b, c) {
    goog.exportPath_(a, b, c);
  };
  goog.exportProperty = function (a, b, c) {
    a[b] = c;
  };
  goog.inherits = function (a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
    a.base = function (a, c, f) {
      for (var g = Array(arguments.length - 2), h = 2; h < arguments.length; h++) {
        g[h - 2] = arguments[h];
      }
      return b.prototype[c].apply(a, g);
    };
  };
  goog.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !d) {
      throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
    }
    if (d.superClass_) {
      for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++) {
        e[f - 1] = arguments[f];
      }
      return d.superClass_.constructor.apply(a, e);
    }
    e = Array(arguments.length - 2);
    for (f = 2; f < arguments.length; f++) {
      e[f - 2] = arguments[f];
    }
    for (var f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor) {
      if (g.prototype[b] === d) {
        f = !0;
      } else {
        if (f) {
          return g.prototype[b].apply(a, e);
        }
      }
    }
    if (a[b] === d) {
      return a.constructor.prototype[b].apply(a, e);
    }
    throw Error("goog.base called from a method of one name to a method of a different name");
  };
  goog.scope = function (a) {
    a.call(goog.global);
  };
  COMPILED || (goog.global.COMPILED = COMPILED);
  goog.defineClass = function (a, b) {
    var c = b.constructor,
        d = b.statics;
    c && c != Object.prototype.constructor || (c = function () {
      throw Error("cannot instantiate an interface (no constructor defined).");
    });
    c = goog.defineClass.createSealingConstructor_(c, a);
    a && goog.inherits(c, a);
    delete b.constructor;
    delete b.statics;
    goog.defineClass.applyProperties_(c.prototype, b);
    null != d && (d instanceof Function ? d(c) : goog.defineClass.applyProperties_(c, d));
    return c;
  };
  goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
  goog.defineClass.createSealingConstructor_ = function (a, b) {
    if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) {
      if (b && b.prototype && b.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) {
        return a;
      }
      var c = function () {
        var b = a.apply(this, arguments) || this;
        b[goog.UID_PROPERTY_] = b[goog.UID_PROPERTY_];
        this.constructor === c && Object.seal(b);
        return b;
      };
      return c;
    }
    return a;
  };
  goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  goog.defineClass.applyProperties_ = function (a, b) {
    for (var c in b) {
      Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
    }
    for (var d = 0; d < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d++) {
      c = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
    }
  };
  goog.tagUnsealableClass = function (a) {
    !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0);
  };
  goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
  goog.math = {};
  goog.math.Long = function (a, b) {
    this.low_ = a | 0;
    this.high_ = b | 0;
  };
  goog.math.Long.IntCache_ = {};
  goog.math.Long.fromInt = function (a) {
    if (-128 <= a && 128 > a) {
      var b = goog.math.Long.IntCache_[a];
      if (b) {
        return b;
      }
    }
    b = new goog.math.Long(a | 0, 0 > a ? -1 : 0);
    -128 <= a && 128 > a && (goog.math.Long.IntCache_[a] = b);
    return b;
  };
  goog.math.Long.fromNumber = function (a) {
    return isNaN(a) || !isFinite(a) ? goog.math.Long.getZero() : a <= -goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMinValue() : a + 1 >= goog.math.Long.TWO_PWR_63_DBL_ ? goog.math.Long.getMaxValue() : 0 > a ? goog.math.Long.fromNumber(-a).negate() : new goog.math.Long(a % goog.math.Long.TWO_PWR_32_DBL_ | 0, a / goog.math.Long.TWO_PWR_32_DBL_ | 0);
  };
  goog.math.Long.fromBits = function (a, b) {
    return new goog.math.Long(a, b);
  };
  goog.math.Long.fromString = function (a, b) {
    if (0 == a.length) {
      throw Error("number format error: empty string");
    }
    var c = b || 10;
    if (2 > c || 36 < c) {
      throw Error("radix out of range: " + c);
    }
    if ("-" == a.charAt(0)) {
      return goog.math.Long.fromString(a.substring(1), c).negate();
    }
    if (0 <= a.indexOf("-")) {
      throw Error('number format error: interior "-" character: ' + a);
    }
    for (var d = goog.math.Long.fromNumber(Math.pow(c, 8)), e = goog.math.Long.getZero(), f = 0; f < a.length; f += 8) {
      var g = Math.min(8, a.length - f),
          h = parseInt(a.substring(f, f + g), c);
      8 > g ? (g = goog.math.Long.fromNumber(Math.pow(c, g)), e = e.multiply(g).add(goog.math.Long.fromNumber(h))) : (e = e.multiply(d), e = e.add(goog.math.Long.fromNumber(h)));
    }
    return e;
  };
  goog.math.Long.TWO_PWR_16_DBL_ = 65536;
  goog.math.Long.getTwoPwr24DBL_ = 16777216;
  goog.math.Long.TWO_PWR_32_DBL_ = goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
  goog.math.Long.TWO_PWR_31_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ / 2;
  goog.math.Long.TWO_PWR_48_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;
  goog.math.Long.TWO_PWR_64_DBL_ = goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;
  goog.math.Long.TWO_PWR_63_DBL_ = goog.math.Long.TWO_PWR_64_DBL_ / 2;
  goog.math.Long.getZero = function () {
    goog.math.Long.ZERO_ || (goog.math.Long.ZERO_ = goog.math.Long.fromInt(0));
    return goog.math.Long.ZERO_;
  };
  goog.math.Long.getOne = function () {
    goog.math.Long.ONE_ || (goog.math.Long.ONE_ = goog.math.Long.fromInt(1));
    return goog.math.Long.ONE_;
  };
  goog.math.Long.getNegOne = function () {
    goog.math.Long.NEG_ONE_ || (goog.math.Long.NEG_ONE_ = goog.math.Long.fromInt(-1));
    return goog.math.Long.NEG_ONE_;
  };
  goog.math.Long.getMaxValue = function () {
    goog.math.Long.MAX_VALUE_ || (goog.math.Long.MAX_VALUE_ = goog.math.Long.fromBits(-1, 2147483647));
    return goog.math.Long.MAX_VALUE_;
  };
  goog.math.Long.getMinValue = function () {
    goog.math.Long.MIN_VALUE_ || (goog.math.Long.MIN_VALUE_ = goog.math.Long.fromBits(0, -2147483648));
    return goog.math.Long.MIN_VALUE_;
  };
  goog.math.Long.getTwoPwr24 = function () {
    goog.math.Long.TWO_PWR_24_ || (goog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(16777216));
    return goog.math.Long.TWO_PWR_24_;
  };
  goog.math.Long.prototype.toInt = function () {
    return this.low_;
  };
  goog.math.Long.prototype.toNumber = function () {
    return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
  };
  goog.math.Long.prototype.toString = function (a) {
    a = a || 10;
    if (2 > a || 36 < a) {
      throw Error("radix out of range: " + a);
    }
    if (this.isZero()) {
      return "0";
    }
    if (this.isNegative()) {
      if (this.equals(goog.math.Long.getMinValue())) {
        var b = goog.math.Long.fromNumber(a),
            c = this.div(b),
            b = c.multiply(b).subtract(this);
        return c.toString(a) + b.toInt().toString(a);
      }
      return "-" + this.negate().toString(a);
    }
    for (var c = goog.math.Long.fromNumber(Math.pow(a, 6)), b = this, d = "";;) {
      var e = b.div(c),
          f = b.subtract(e.multiply(c)).toInt().toString(a),
          b = e;
      if (b.isZero()) {
        return f + d;
      }
      for (; 6 > f.length;) {
        f = "0" + f;
      }
      d = "" + f + d;
    }
  };
  goog.math.Long.prototype.getHighBits = function () {
    return this.high_;
  };
  goog.math.Long.prototype.getLowBits = function () {
    return this.low_;
  };
  goog.math.Long.prototype.getLowBitsUnsigned = function () {
    return 0 <= this.low_ ? this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;
  };
  goog.math.Long.prototype.getNumBitsAbs = function () {
    if (this.isNegative()) {
      return this.equals(goog.math.Long.getMinValue()) ? 64 : this.negate().getNumBitsAbs();
    }
    for (var a = 0 != this.high_ ? this.high_ : this.low_, b = 31; 0 < b && 0 == (a & 1 << b); b--) {}
    return 0 != this.high_ ? b + 33 : b + 1;
  };
  goog.math.Long.prototype.isZero = function () {
    return 0 == this.high_ && 0 == this.low_;
  };
  goog.math.Long.prototype.isNegative = function () {
    return 0 > this.high_;
  };
  goog.math.Long.prototype.isOdd = function () {
    return 1 == (this.low_ & 1);
  };
  goog.math.Long.prototype.equals = function (a) {
    return this.high_ == a.high_ && this.low_ == a.low_;
  };
  goog.math.Long.prototype.notEquals = function (a) {
    return this.high_ != a.high_ || this.low_ != a.low_;
  };
  goog.math.Long.prototype.lessThan = function (a) {
    return 0 > this.compare(a);
  };
  goog.math.Long.prototype.lessThanOrEqual = function (a) {
    return 0 >= this.compare(a);
  };
  goog.math.Long.prototype.greaterThan = function (a) {
    return 0 < this.compare(a);
  };
  goog.math.Long.prototype.greaterThanOrEqual = function (a) {
    return 0 <= this.compare(a);
  };
  goog.math.Long.prototype.compare = function (a) {
    if (this.equals(a)) {
      return 0;
    }
    var b = this.isNegative(),
        c = a.isNegative();
    return b && !c ? -1 : !b && c ? 1 : this.subtract(a).isNegative() ? -1 : 1;
  };
  goog.math.Long.prototype.negate = function () {
    return this.equals(goog.math.Long.getMinValue()) ? goog.math.Long.getMinValue() : this.not().add(goog.math.Long.getOne());
  };
  goog.math.Long.prototype.add = function (a) {
    var b = this.high_ >>> 16,
        c = this.high_ & 65535,
        d = this.low_ >>> 16,
        e = a.high_ >>> 16,
        f = a.high_ & 65535,
        g = a.low_ >>> 16,
        h;
    h = 0 + ((this.low_ & 65535) + (a.low_ & 65535));
    a = 0 + (h >>> 16);
    a += d + g;
    d = 0 + (a >>> 16);
    d += c + f;
    c = 0 + (d >>> 16);
    c = c + (b + e) & 65535;
    return goog.math.Long.fromBits((a & 65535) << 16 | h & 65535, c << 16 | d & 65535);
  };
  goog.math.Long.prototype.subtract = function (a) {
    return this.add(a.negate());
  };
  goog.math.Long.prototype.multiply = function (a) {
    if (this.isZero() || a.isZero()) {
      return goog.math.Long.getZero();
    }
    if (this.equals(goog.math.Long.getMinValue())) {
      return a.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
    }
    if (a.equals(goog.math.Long.getMinValue())) {
      return this.isOdd() ? goog.math.Long.getMinValue() : goog.math.Long.getZero();
    }
    if (this.isNegative()) {
      return a.isNegative() ? this.negate().multiply(a.negate()) : this.negate().multiply(a).negate();
    }
    if (a.isNegative()) {
      return this.multiply(a.negate()).negate();
    }
    if (this.lessThan(goog.math.Long.getTwoPwr24()) && a.lessThan(goog.math.Long.getTwoPwr24())) {
      return goog.math.Long.fromNumber(this.toNumber() * a.toNumber());
    }
    var b = this.high_ >>> 16,
        c = this.high_ & 65535,
        d = this.low_ >>> 16,
        e = this.low_ & 65535,
        f = a.high_ >>> 16,
        g = a.high_ & 65535,
        h = a.low_ >>> 16;
    a = a.low_ & 65535;
    var m, k, l, n;
    n = 0 + e * a;
    l = 0 + (n >>> 16);
    l += d * a;
    k = 0 + (l >>> 16);
    l = (l & 65535) + e * h;
    k += l >>> 16;
    l &= 65535;
    k += c * a;
    m = 0 + (k >>> 16);
    k = (k & 65535) + d * h;
    m += k >>> 16;
    k &= 65535;
    k += e * g;
    m += k >>> 16;
    k &= 65535;
    m = m + (b * a + c * h + d * g + e * f) & 65535;
    return goog.math.Long.fromBits(l << 16 | n & 65535, m << 16 | k);
  };
  goog.math.Long.prototype.div = function (a) {
    if (a.isZero()) {
      throw Error("division by zero");
    }
    if (this.isZero()) {
      return goog.math.Long.getZero();
    }
    if (this.equals(goog.math.Long.getMinValue())) {
      if (a.equals(goog.math.Long.getOne()) || a.equals(goog.math.Long.getNegOne())) {
        return goog.math.Long.getMinValue();
      }
      if (a.equals(goog.math.Long.getMinValue())) {
        return goog.math.Long.getOne();
      }
      var b = this.shiftRight(1).div(a).shiftLeft(1);
      if (b.equals(goog.math.Long.getZero())) {
        return a.isNegative() ? goog.math.Long.getOne() : goog.math.Long.getNegOne();
      }
      var c = this.subtract(a.multiply(b));
      return b.add(c.div(a));
    }
    if (a.equals(goog.math.Long.getMinValue())) {
      return goog.math.Long.getZero();
    }
    if (this.isNegative()) {
      return a.isNegative() ? this.negate().div(a.negate()) : this.negate().div(a).negate();
    }
    if (a.isNegative()) {
      return this.div(a.negate()).negate();
    }
    for (var d = goog.math.Long.getZero(), c = this; c.greaterThanOrEqual(a);) {
      for (var b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())), e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : Math.pow(2, e - 48), f = goog.math.Long.fromNumber(b), g = f.multiply(a); g.isNegative() || g.greaterThan(c);) {
        b -= e, f = goog.math.Long.fromNumber(b), g = f.multiply(a);
      }
      f.isZero() && (f = goog.math.Long.getOne());
      d = d.add(f);
      c = c.subtract(g);
    }
    return d;
  };
  goog.math.Long.prototype.modulo = function (a) {
    return this.subtract(this.div(a).multiply(a));
  };
  goog.math.Long.prototype.not = function () {
    return goog.math.Long.fromBits(~this.low_, ~this.high_);
  };
  goog.math.Long.prototype.and = function (a) {
    return goog.math.Long.fromBits(this.low_ & a.low_, this.high_ & a.high_);
  };
  goog.math.Long.prototype.or = function (a) {
    return goog.math.Long.fromBits(this.low_ | a.low_, this.high_ | a.high_);
  };
  goog.math.Long.prototype.xor = function (a) {
    return goog.math.Long.fromBits(this.low_ ^ a.low_, this.high_ ^ a.high_);
  };
  goog.math.Long.prototype.shiftLeft = function (a) {
    a &= 63;
    if (0 == a) {
      return this;
    }
    var b = this.low_;
    return 32 > a ? goog.math.Long.fromBits(b << a, this.high_ << a | b >>> 32 - a) : goog.math.Long.fromBits(0, b << a - 32);
  };
  goog.math.Long.prototype.shiftRight = function (a) {
    a &= 63;
    if (0 == a) {
      return this;
    }
    var b = this.high_;
    return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >> a) : goog.math.Long.fromBits(b >> a - 32, 0 <= b ? 0 : -1);
  };
  goog.math.Long.prototype.shiftRightUnsigned = function (a) {
    a &= 63;
    if (0 == a) {
      return this;
    }
    var b = this.high_;
    return 32 > a ? goog.math.Long.fromBits(this.low_ >>> a | b << 32 - a, b >>> a) : 32 == a ? goog.math.Long.fromBits(b, 0) : goog.math.Long.fromBits(b >>> a - 32, 0);
  };
  goog.object = {};
  goog.object.forEach = function (a, b, c) {
    for (var d in a) {
      b.call(c, a[d], d, a);
    }
  };
  goog.object.filter = function (a, b, c) {
    var d = {},
        e;
    for (e in a) {
      b.call(c, a[e], e, a) && (d[e] = a[e]);
    }
    return d;
  };
  goog.object.map = function (a, b, c) {
    var d = {},
        e;
    for (e in a) {
      d[e] = b.call(c, a[e], e, a);
    }
    return d;
  };
  goog.object.some = function (a, b, c) {
    for (var d in a) {
      if (b.call(c, a[d], d, a)) {
        return !0;
      }
    }
    return !1;
  };
  goog.object.every = function (a, b, c) {
    for (var d in a) {
      if (!b.call(c, a[d], d, a)) {
        return !1;
      }
    }
    return !0;
  };
  goog.object.getCount = function (a) {
    var b = 0,
        c;
    for (c in a) {
      b++;
    }
    return b;
  };
  goog.object.getAnyKey = function (a) {
    for (var b in a) {
      return b;
    }
  };
  goog.object.getAnyValue = function (a) {
    for (var b in a) {
      return a[b];
    }
  };
  goog.object.contains = function (a, b) {
    return goog.object.containsValue(a, b);
  };
  goog.object.getValues = function (a) {
    var b = [],
        c = 0,
        d;
    for (d in a) {
      b[c++] = a[d];
    }
    return b;
  };
  goog.object.getKeys = function (a) {
    var b = [],
        c = 0,
        d;
    for (d in a) {
      b[c++] = d;
    }
    return b;
  };
  goog.object.getValueByKeys = function (a, b) {
    for (var c = goog.isArrayLike(b), d = c ? b : arguments, c = c ? 0 : 1; c < d.length && (a = a[d[c]], goog.isDef(a)); c++) {}
    return a;
  };
  goog.object.containsKey = function (a, b) {
    return b in a;
  };
  goog.object.containsValue = function (a, b) {
    for (var c in a) {
      if (a[c] == b) {
        return !0;
      }
    }
    return !1;
  };
  goog.object.findKey = function (a, b, c) {
    for (var d in a) {
      if (b.call(c, a[d], d, a)) {
        return d;
      }
    }
  };
  goog.object.findValue = function (a, b, c) {
    return (b = goog.object.findKey(a, b, c)) && a[b];
  };
  goog.object.isEmpty = function (a) {
    for (var b in a) {
      return !1;
    }
    return !0;
  };
  goog.object.clear = function (a) {
    for (var b in a) {
      delete a[b];
    }
  };
  goog.object.remove = function (a, b) {
    var c;
    (c = b in a) && delete a[b];
    return c;
  };
  goog.object.add = function (a, b, c) {
    if (b in a) {
      throw Error('The object already contains the key "' + b + '"');
    }
    goog.object.set(a, b, c);
  };
  goog.object.get = function (a, b, c) {
    return b in a ? a[b] : c;
  };
  goog.object.set = function (a, b, c) {
    a[b] = c;
  };
  goog.object.setIfUndefined = function (a, b, c) {
    return b in a ? a[b] : a[b] = c;
  };
  goog.object.setWithReturnValueIfNotSet = function (a, b, c) {
    if (b in a) {
      return a[b];
    }
    c = c();
    return a[b] = c;
  };
  goog.object.equals = function (a, b) {
    for (var c in a) {
      if (!(c in b) || a[c] !== b[c]) {
        return !1;
      }
    }
    for (c in b) {
      if (!(c in a)) {
        return !1;
      }
    }
    return !0;
  };
  goog.object.clone = function (a) {
    var b = {},
        c;
    for (c in a) {
      b[c] = a[c];
    }
    return b;
  };
  goog.object.unsafeClone = function (a) {
    var b = goog.typeOf(a);
    if ("object" == b || "array" == b) {
      if (a.clone) {
        return a.clone();
      }
      var b = "array" == b ? [] : {},
          c;
      for (c in a) {
        b[c] = goog.object.unsafeClone(a[c]);
      }
      return b;
    }
    return a;
  };
  goog.object.transpose = function (a) {
    var b = {},
        c;
    for (c in a) {
      b[a[c]] = c;
    }
    return b;
  };
  goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  goog.object.extend = function (a, b) {
    for (var c, d, e = 1; e < arguments.length; e++) {
      d = arguments[e];
      for (c in d) {
        a[c] = d[c];
      }
      for (var f = 0; f < goog.object.PROTOTYPE_FIELDS_.length; f++) {
        c = goog.object.PROTOTYPE_FIELDS_[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
      }
    }
  };
  goog.object.create = function (a) {
    var b = arguments.length;
    if (1 == b && goog.isArray(arguments[0])) {
      return goog.object.create.apply(null, arguments[0]);
    }
    if (b % 2) {
      throw Error("Uneven number of arguments");
    }
    for (var c = {}, d = 0; d < b; d += 2) {
      c[arguments[d]] = arguments[d + 1];
    }
    return c;
  };
  goog.object.createSet = function (a) {
    var b = arguments.length;
    if (1 == b && goog.isArray(arguments[0])) {
      return goog.object.createSet.apply(null, arguments[0]);
    }
    for (var c = {}, d = 0; d < b; d++) {
      c[arguments[d]] = !0;
    }
    return c;
  };
  goog.object.createImmutableView = function (a) {
    var b = a;
    Object.isFrozen && !Object.isFrozen(a) && (b = Object.create(a), Object.freeze(b));
    return b;
  };
  goog.object.isImmutableView = function (a) {
    return !!Object.isFrozen && Object.isFrozen(a);
  };
  var com = { cognitect: {} };
  com.cognitect.transit = {};
  com.cognitect.transit.delimiters = {};
  com.cognitect.transit.delimiters.ESC = "~";
  com.cognitect.transit.delimiters.TAG = "#";
  com.cognitect.transit.delimiters.SUB = "^";
  com.cognitect.transit.delimiters.RES = "`";
  com.cognitect.transit.delimiters.ESC_TAG = "~#";
  com.cognitect.transit.caching = {};
  com.cognitect.transit.caching.MIN_SIZE_CACHEABLE = 3;
  com.cognitect.transit.caching.BASE_CHAR_IDX = 48;
  com.cognitect.transit.caching.CACHE_CODE_DIGITS = 44;
  com.cognitect.transit.caching.MAX_CACHE_ENTRIES = com.cognitect.transit.caching.CACHE_CODE_DIGITS * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
  com.cognitect.transit.caching.MAX_CACHE_SIZE = 4096;
  com.cognitect.transit.caching.isCacheable = function (a, b) {
    if (a.length > com.cognitect.transit.caching.MIN_SIZE_CACHEABLE) {
      if (b) {
        return !0;
      }
      var c = a.charAt(0),
          d = a.charAt(1);
      return c === com.cognitect.transit.delimiters.ESC ? ":" === d || "$" === d || "#" === d : !1;
    }
    return !1;
  };
  com.cognitect.transit.caching.idxToCode = function (a) {
    var b = Math.floor(a / com.cognitect.transit.caching.CACHE_CODE_DIGITS);
    a = String.fromCharCode(a % com.cognitect.transit.caching.CACHE_CODE_DIGITS + com.cognitect.transit.caching.BASE_CHAR_IDX);
    return 0 === b ? com.cognitect.transit.delimiters.SUB + a : com.cognitect.transit.delimiters.SUB + String.fromCharCode(b + com.cognitect.transit.caching.BASE_CHAR_IDX) + a;
  };
  com.cognitect.transit.caching.WriteCache = function () {
    this.cacheSize = this.gen = this.idx = 0;
    this.cache = {};
  };
  com.cognitect.transit.caching.WriteCache.prototype.write = function (a, b) {
    if (com.cognitect.transit.caching.isCacheable(a, b)) {
      this.cacheSize === com.cognitect.transit.caching.MAX_CACHE_SIZE ? (this.clear(), this.gen = 0, this.cache = {}) : this.idx === com.cognitect.transit.caching.MAX_CACHE_ENTRIES && this.clear();
      var c = this.cache[a];
      return null == c ? (this.cache[a] = [com.cognitect.transit.caching.idxToCode(this.idx), this.gen], this.idx++, a) : c[1] != this.gen ? (c[1] = this.gen, c[0] = com.cognitect.transit.caching.idxToCode(this.idx), this.idx++, a) : c[0];
    }
    return a;
  };
  com.cognitect.transit.caching.WriteCache.prototype.clear = function () {
    this.idx = 0;
    this.gen++;
  };
  com.cognitect.transit.caching.writeCache = function () {
    return new com.cognitect.transit.caching.WriteCache();
  };
  com.cognitect.transit.caching.isCacheCode = function (a) {
    return a.charAt(0) === com.cognitect.transit.delimiters.SUB && " " !== a.charAt(1);
  };
  com.cognitect.transit.caching.codeToIdx = function (a) {
    if (2 === a.length) {
      return a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX;
    }
    var b = (a.charCodeAt(1) - com.cognitect.transit.caching.BASE_CHAR_IDX) * com.cognitect.transit.caching.CACHE_CODE_DIGITS;
    a = a.charCodeAt(2) - com.cognitect.transit.caching.BASE_CHAR_IDX;
    return b + a;
  };
  com.cognitect.transit.caching.ReadCache = function () {
    this.idx = 0;
    this.cache = [];
  };
  com.cognitect.transit.caching.ReadCache.prototype.write = function (a, b) {
    this.idx == com.cognitect.transit.caching.MAX_CACHE_ENTRIES && (this.idx = 0);
    this.cache[this.idx] = a;
    this.idx++;
    return a;
  };
  com.cognitect.transit.caching.ReadCache.prototype.read = function (a, b) {
    return this.cache[com.cognitect.transit.caching.codeToIdx(a)];
  };
  com.cognitect.transit.caching.ReadCache.prototype.clear = function () {
    this.idx = 0;
  };
  com.cognitect.transit.caching.readCache = function () {
    return new com.cognitect.transit.caching.ReadCache();
  };
  com.cognitect.transit.util = {};
  com.cognitect.transit.util.objectKeys = "undefined" != typeof Object.keys ? function (a) {
    return Object.keys(a);
  } : function (a) {
    return goog.object.getKeys(a);
  };
  com.cognitect.transit.util.isArray = "undefined" != typeof Array.isArray ? function (a) {
    return Array.isArray(a);
  } : function (a) {
    return "array" === goog.typeOf(a);
  };
  com.cognitect.transit.util.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  com.cognitect.transit.util.randInt = function (a) {
    return Math.round(Math.random() * a);
  };
  com.cognitect.transit.util.randHex = function () {
    return com.cognitect.transit.util.randInt(15).toString(16);
  };
  com.cognitect.transit.util.randomUUID = function () {
    var a = (8 | 3 & com.cognitect.transit.util.randInt(14)).toString(16);
    return com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-4" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + a + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + "-" + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex() + com.cognitect.transit.util.randHex();
  };
  com.cognitect.transit.util.btoa = function (a) {
    if ("undefined" != typeof btoa) {
      return btoa(a);
    }
    a = String(a);
    for (var b, c, d = 0, e = com.cognitect.transit.util.chars, f = ""; a.charAt(d | 0) || (e = "=", d % 1); f += e.charAt(63 & b >> 8 - d % 1 * 8)) {
      c = a.charCodeAt(d += .75);
      if (255 < c) {
        throw Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      b = b << 8 | c;
    }
    return f;
  };
  com.cognitect.transit.util.atob = function (a) {
    if ("undefined" != typeof atob) {
      return atob(a);
    }
    a = String(a).replace(/=+$/, "");
    if (1 == a.length % 4) {
      throw Error("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (var b = 0, c, d, e = 0, f = ""; d = a.charAt(e++); ~d && (c = b % 4 ? 64 * c + d : d, b++ % 4) ? f += String.fromCharCode(255 & c >> (-2 * b & 6)) : 0) {
      d = com.cognitect.transit.util.chars.indexOf(d);
    }
    return f;
  };
  com.cognitect.transit.util.Uint8ToBase64 = function (a) {
    for (var b = 0, c = a.length, d = "", e = null; b < c;) {
      e = a.subarray(b, Math.min(b + 32768, c)), d += String.fromCharCode.apply(null, e), b += 32768;
    }
    return com.cognitect.transit.util.btoa(d);
  };
  com.cognitect.transit.util.Base64ToUint8 = function (a) {
    a = com.cognitect.transit.util.atob(a);
    for (var b = a.length, c = new Uint8Array(b), d = 0; d < b; d++) {
      var e = a.charCodeAt(d);
      c[d] = e;
    }
    return c;
  };
  com.cognitect.transit.eq = {};
  com.cognitect.transit.eq.hashCodeProperty = "transit$hashCode$";
  com.cognitect.transit.eq.hashCodeCounter = 1;
  com.cognitect.transit.eq.equals = function (a, b) {
    if (null == a) {
      return null == b;
    }
    if (a === b) {
      return !0;
    }
    if ("object" === typeof a) {
      if (com.cognitect.transit.util.isArray(a)) {
        if (com.cognitect.transit.util.isArray(b) && a.length === b.length) {
          for (var c = 0; c < a.length; c++) {
            if (!com.cognitect.transit.eq.equals(a[c], b[c])) {
              return !1;
            }
          }
          return !0;
        }
        return !1;
      }
      if (a.com$cognitect$transit$equals) {
        return a.com$cognitect$transit$equals(b);
      }
      if (null != b && "object" === typeof b) {
        if (b.com$cognitect$transit$equals) {
          return b.com$cognitect$transit$equals(a);
        }
        var c = 0,
            d = com.cognitect.transit.util.objectKeys(b).length,
            e;
        for (e in a) {
          if (a.hasOwnProperty(e) && (c++, !b.hasOwnProperty(e) || !com.cognitect.transit.eq.equals(a[e], b[e]))) {
            return !1;
          }
        }
        return c === d;
      }
    }
    return !1;
  };
  com.cognitect.transit.eq.hashCombine = function (a, b) {
    return a ^ b + 2654435769 + (a << 6) + (a >> 2);
  };
  com.cognitect.transit.eq.stringCodeCache = {};
  com.cognitect.transit.eq.stringCodeCacheSize = 0;
  com.cognitect.transit.eq.STR_CACHE_MAX = 256;
  com.cognitect.transit.eq.hashString = function (a) {
    var b = com.cognitect.transit.eq.stringCodeCache[a];
    if (null != b) {
      return b;
    }
    for (var c = b = 0; c < a.length; ++c) {
      b = 31 * b + a.charCodeAt(c), b %= 4294967296;
    }
    com.cognitect.transit.eq.stringCodeCacheSize++;
    com.cognitect.transit.eq.stringCodeCacheSize >= com.cognitect.transit.eq.STR_CACHE_MAX && (com.cognitect.transit.eq.stringCodeCache = {}, com.cognitect.transit.eq.stringCodeCacheSize = 1);
    return com.cognitect.transit.eq.stringCodeCache[a] = b;
  };
  com.cognitect.transit.eq.hashMapLike = function (a) {
    var b = 0;
    if (null != a.forEach) {
      a.forEach(function (a, c, d) {
        b = (b + (com.cognitect.transit.eq.hashCode(c) ^ com.cognitect.transit.eq.hashCode(a))) % 4503599627370496;
      });
    } else {
      for (var c = com.cognitect.transit.util.objectKeys(a), d = 0; d < c.length; d++) {
        var e = c[d],
            f = a[e],
            b = (b + (com.cognitect.transit.eq.hashCode(e) ^ com.cognitect.transit.eq.hashCode(f))) % 4503599627370496;
      }
    }
    return b;
  };
  com.cognitect.transit.eq.hashArrayLike = function (a) {
    var b = 0;
    if (com.cognitect.transit.util.isArray(a)) {
      for (var c = 0; c < a.length; c++) {
        b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a[c]));
      }
    } else {
      a.forEach && a.forEach(function (a, c) {
        b = com.cognitect.transit.eq.hashCombine(b, com.cognitect.transit.eq.hashCode(a));
      });
    }
    return b;
  };
  com.cognitect.transit.eq.hashCode = function (a) {
    if (null == a) {
      return 0;
    }
    switch (typeof a) {
      case "number":
        return a;
      case "boolean":
        return !0 === a ? 1 : 0;
      case "string":
        return com.cognitect.transit.eq.hashString(a);
      case "function":
        var b = a[com.cognitect.transit.eq.hashCodeProperty];
        b || (b = com.cognitect.transit.eq.hashCodeCounter, "undefined" != typeof Object.defineProperty ? Object.defineProperty(a, com.cognitect.transit.eq.hashCodeProperty, { value: b, enumerable: !1 }) : a[com.cognitect.transit.eq.hashCodeProperty] = b, com.cognitect.transit.eq.hashCodeCounter++);
        return b;
      default:
        return a instanceof Date ? a.valueOf() : com.cognitect.transit.util.isArray(a) ? com.cognitect.transit.eq.hashArrayLike(a) : a.com$cognitect$transit$hashCode ? a.com$cognitect$transit$hashCode() : com.cognitect.transit.eq.hashMapLike(a);
    }
  };
  com.cognitect.transit.eq.extendToEQ = function (a, b) {
    a.com$cognitect$transit$hashCode = b.hashCode;
    a.com$cognitect$transit$equals = b.equals;
    return a;
  };
  com.cognitect.transit.types = {};
  com.cognitect.transit.types.ITERATOR = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator";
  com.cognitect.transit.types.TaggedValue = function (a, b) {
    this.tag = a;
    this.rep = b;
    this.hashCode = -1;
  };
  com.cognitect.transit.types.TaggedValue.prototype.toString = function () {
    return "[TaggedValue: " + this.tag + ", " + this.rep + "]";
  };
  com.cognitect.transit.types.TaggedValue.prototype.equiv = function (a) {
    return com.cognitect.transit.eq.equals(this, a);
  };
  com.cognitect.transit.types.TaggedValue.prototype.equiv = com.cognitect.transit.types.TaggedValue.prototype.equiv;
  com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue ? this.tag === a.tag && com.cognitect.transit.eq.equals(this.rep, a.rep) : !1;
  };
  com.cognitect.transit.types.TaggedValue.prototype.com$cognitect$transit$hashCode = function () {
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCombine(com.cognitect.transit.eq.hashCode(this.tag), com.cognitect.transit.eq.hashCode(this.rep)));
    return this.hashCode;
  };
  com.cognitect.transit.types.taggedValue = function (a, b) {
    return new com.cognitect.transit.types.TaggedValue(a, b);
  };
  com.cognitect.transit.types.isTaggedValue = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue;
  };
  com.cognitect.transit.types.nullValue = function () {
    return null;
  };
  com.cognitect.transit.types.boolValue = function (a) {
    return "t" === a;
  };
  com.cognitect.transit.types.MAX_INT = goog.math.Long.fromString("9007199254740991");
  com.cognitect.transit.types.MIN_INT = goog.math.Long.fromString("-9007199254740991");
  com.cognitect.transit.types.intValue = function (a) {
    if ("number" === typeof a || a instanceof goog.math.Long) {
      return a;
    }
    a = goog.math.Long.fromString(a, 10);
    return a.greaterThan(com.cognitect.transit.types.MAX_INT) || a.lessThan(com.cognitect.transit.types.MIN_INT) ? a : a.toNumber();
  };
  goog.math.Long.prototype.equiv = function (a) {
    return com.cognitect.transit.eq.equals(this, a);
  };
  goog.math.Long.prototype.equiv = goog.math.Long.prototype.equiv;
  goog.math.Long.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof goog.math.Long && this.equals(a);
  };
  goog.math.Long.prototype.com$cognitect$transit$hashCode = function () {
    return this.toInt();
  };
  com.cognitect.transit.types.isInteger = function (a) {
    return a instanceof goog.math.Long ? !0 : "number" === typeof a && !isNaN(a) && Infinity !== a && parseFloat(a) === parseInt(a, 10);
  };
  com.cognitect.transit.types.floatValue = function (a) {
    return parseFloat(a);
  };
  com.cognitect.transit.types.bigInteger = function (a) {
    return com.cognitect.transit.types.taggedValue("n", a);
  };
  com.cognitect.transit.types.isBigInteger = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "n" === a.tag;
  };
  com.cognitect.transit.types.bigDecimalValue = function (a) {
    return com.cognitect.transit.types.taggedValue("f", a);
  };
  com.cognitect.transit.types.isBigDecimal = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "f" === a.tag;
  };
  com.cognitect.transit.types.charValue = function (a) {
    return a;
  };
  com.cognitect.transit.types.Keyword = function (a) {
    this._name = a;
    this.hashCode = -1;
  };
  com.cognitect.transit.types.Keyword.prototype.toString = function () {
    return ":" + this._name;
  };
  com.cognitect.transit.types.Keyword.prototype.namespace = function () {
    var a = this._name.indexOf("/");
    return -1 != a ? this._name.substring(0, a) : null;
  };
  com.cognitect.transit.types.Keyword.prototype.name = function () {
    var a = this._name.indexOf("/");
    return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
  };
  com.cognitect.transit.types.Keyword.prototype.equiv = function (a) {
    return com.cognitect.transit.eq.equals(this, a);
  };
  com.cognitect.transit.types.Keyword.prototype.equiv = com.cognitect.transit.types.Keyword.prototype.equiv;
  com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof com.cognitect.transit.types.Keyword && this._name == a._name;
  };
  com.cognitect.transit.types.Keyword.prototype.com$cognitect$transit$hashCode = function () {
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
    return this.hashCode;
  };
  com.cognitect.transit.types.keyword = function (a) {
    return new com.cognitect.transit.types.Keyword(a);
  };
  com.cognitect.transit.types.isKeyword = function (a) {
    return a instanceof com.cognitect.transit.types.Keyword;
  };
  com.cognitect.transit.types.Symbol = function (a) {
    this._name = a;
    this.hashCode = -1;
  };
  com.cognitect.transit.types.Symbol.prototype.namespace = function () {
    var a = this._name.indexOf("/");
    return -1 != a ? this._name.substring(0, a) : null;
  };
  com.cognitect.transit.types.Symbol.prototype.name = function () {
    var a = this._name.indexOf("/");
    return -1 != a ? this._name.substring(a + 1, this._name.length) : this._name;
  };
  com.cognitect.transit.types.Symbol.prototype.toString = function () {
    return this._name;
  };
  com.cognitect.transit.types.Symbol.prototype.equiv = function (a) {
    return com.cognitect.transit.eq.equals(this, a);
  };
  com.cognitect.transit.types.Symbol.prototype.equiv = com.cognitect.transit.types.Symbol.prototype.equiv;
  com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof com.cognitect.transit.types.Symbol && this._name == a._name;
  };
  com.cognitect.transit.types.Symbol.prototype.com$cognitect$transit$hashCode = function () {
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this._name));
    return this.hashCode;
  };
  com.cognitect.transit.types.symbol = function (a) {
    return new com.cognitect.transit.types.Symbol(a);
  };
  com.cognitect.transit.types.isSymbol = function (a) {
    return a instanceof com.cognitect.transit.types.Symbol;
  };
  com.cognitect.transit.types.hexFor = function (a, b, c) {
    var d = "";
    c = c || b + 1;
    for (var e = 8 * (7 - b), f = goog.math.Long.fromInt(255).shiftLeft(e); b < c; b++, e -= 8, f = f.shiftRightUnsigned(8)) {
      var g = a.and(f).shiftRightUnsigned(e).toString(16);
      1 == g.length && (g = "0" + g);
      d += g;
    }
    return d;
  };
  com.cognitect.transit.types.UUID = function (a, b) {
    this.high = a;
    this.low = b;
    this.hashCode = -1;
  };
  com.cognitect.transit.types.UUID.prototype.getLeastSignificantBits = function () {
    return this.low;
  };
  com.cognitect.transit.types.UUID.prototype.getMostSignificantBits = function () {
    return this.high;
  };
  com.cognitect.transit.types.UUID.prototype.toString = function () {
    var a,
        b = this.high,
        c = this.low;
    a = "" + (com.cognitect.transit.types.hexFor(b, 0, 4) + "-");
    a += com.cognitect.transit.types.hexFor(b, 4, 6) + "-";
    a += com.cognitect.transit.types.hexFor(b, 6, 8) + "-";
    a += com.cognitect.transit.types.hexFor(c, 0, 2) + "-";
    return a += com.cognitect.transit.types.hexFor(c, 2, 8);
  };
  com.cognitect.transit.types.UUID.prototype.equiv = function (a) {
    return com.cognitect.transit.eq.equals(this, a);
  };
  com.cognitect.transit.types.UUID.prototype.equiv = com.cognitect.transit.types.UUID.prototype.equiv;
  com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof com.cognitect.transit.types.UUID && this.high.equals(a.high) && this.low.equals(a.low);
  };
  com.cognitect.transit.types.UUID.prototype.com$cognitect$transit$hashCode = function () {
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashCode(this.toString()));
    return this.hashCode;
  };
  com.cognitect.transit.types.UUIDfromString = function (a) {
    a = a.replace(/-/g, "");
    for (var b = null, c = null, d = c = 0, e = 24, f = 0, f = c = 0, e = 24; 8 > f; f += 2, e -= 8) {
      c |= parseInt(a.substring(f, f + 2), 16) << e;
    }
    d = 0;
    f = 8;
    for (e = 24; 16 > f; f += 2, e -= 8) {
      d |= parseInt(a.substring(f, f + 2), 16) << e;
    }
    b = goog.math.Long.fromBits(d, c);
    c = 0;
    f = 16;
    for (e = 24; 24 > f; f += 2, e -= 8) {
      c |= parseInt(a.substring(f, f + 2), 16) << e;
    }
    d = 0;
    for (e = f = 24; 32 > f; f += 2, e -= 8) {
      d |= parseInt(a.substring(f, f + 2), 16) << e;
    }
    c = goog.math.Long.fromBits(d, c);
    return new com.cognitect.transit.types.UUID(b, c);
  };
  com.cognitect.transit.types.uuid = function (a) {
    return com.cognitect.transit.types.UUIDfromString(a);
  };
  com.cognitect.transit.types.isUUID = function (a) {
    return a instanceof com.cognitect.transit.types.UUID;
  };
  com.cognitect.transit.types.date = function (a) {
    a = "number" === typeof a ? a : parseInt(a, 10);
    return new Date(a);
  };
  com.cognitect.transit.types.verboseDate = function (a) {
    return new Date(a);
  };
  Date.prototype.com$cognitect$transit$equals = function (a) {
    return a instanceof Date ? this.valueOf() === a.valueOf() : !1;
  };
  Date.prototype.com$cognitect$transit$hashCode = function () {
    return this.valueOf();
  };
  com.cognitect.transit.types.binary = function (a, b) {
    return b && !1 === b.preferBuffers || "undefined" == typeof Buffer ? "undefined" != typeof Uint8Array ? com.cognitect.transit.util.Base64ToUint8(a) : com.cognitect.transit.types.taggedValue("b", a) : new Buffer(a, "base64");
  };
  com.cognitect.transit.types.isBinary = function (a) {
    return "undefined" != typeof Buffer && a instanceof Buffer ? !0 : "undefined" != typeof Uint8Array && a instanceof Uint8Array ? !0 : a instanceof com.cognitect.transit.types.TaggedValue && "b" === a.tag;
  };
  com.cognitect.transit.types.uri = function (a) {
    return com.cognitect.transit.types.taggedValue("r", a);
  };
  com.cognitect.transit.types.isURI = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "r" === a.tag;
  };
  com.cognitect.transit.types.KEYS = 0;
  com.cognitect.transit.types.VALUES = 1;
  com.cognitect.transit.types.ENTRIES = 2;
  com.cognitect.transit.types.TransitArrayMapIterator = function (a, b) {
    this.entries = a;
    this.type = b || com.cognitect.transit.types.KEYS;
    this.idx = 0;
  };
  com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = function () {
    if (this.idx < this.entries.length) {
      var a = null,
          a = this.type === com.cognitect.transit.types.KEYS ? this.entries[this.idx] : this.type === com.cognitect.transit.types.VALUES ? this.entries[this.idx + 1] : [this.entries[this.idx], this.entries[this.idx + 1]],
          a = { value: a, done: !1 };
      this.idx += 2;
      return a;
    }
    return { value: null, done: !0 };
  };
  com.cognitect.transit.types.TransitArrayMapIterator.prototype.next = com.cognitect.transit.types.TransitArrayMapIterator.prototype.next;
  com.cognitect.transit.types.TransitArrayMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function () {
    return this;
  };
  com.cognitect.transit.types.TransitMapIterator = function (a, b) {
    this.map = a;
    this.type = b || com.cognitect.transit.types.KEYS;
    this.keys = this.map.getKeys();
    this.idx = 0;
    this.bucket = null;
    this.bucketIdx = 0;
  };
  com.cognitect.transit.types.TransitMapIterator.prototype.next = function () {
    if (this.idx < this.map.size) {
      null != this.bucket && this.bucketIdx < this.bucket.length || (this.bucket = this.map.map[this.keys[this.idx]], this.bucketIdx = 0);
      var a = null,
          a = this.type === com.cognitect.transit.types.KEYS ? this.bucket[this.bucketIdx] : this.type === com.cognitect.transit.types.VALUES ? this.bucket[this.bucketIdx + 1] : [this.bucket[this.bucketIdx], this.bucket[this.bucketIdx + 1]],
          a = { value: a, done: !1 };
      this.idx++;
      this.bucketIdx += 2;
      return a;
    }
    return { value: null, done: !0 };
  };
  com.cognitect.transit.types.TransitMapIterator.prototype.next = com.cognitect.transit.types.TransitMapIterator.prototype.next;
  com.cognitect.transit.types.TransitMapIterator.prototype[com.cognitect.transit.types.ITERATOR] = function () {
    return this;
  };
  com.cognitect.transit.types.mapEquals = function (a, b) {
    if (a instanceof com.cognitect.transit.types.TransitMap && com.cognitect.transit.types.isMap(b)) {
      if (a.size !== b.size) {
        return !1;
      }
      for (var c in a.map) {
        for (var d = a.map[c], e = 0; e < d.length; e += 2) {
          if (!com.cognitect.transit.eq.equals(d[e + 1], b.get(d[e]))) {
            return !1;
          }
        }
      }
      return !0;
    }
    if (a instanceof com.cognitect.transit.types.TransitArrayMap && com.cognitect.transit.types.isMap(b)) {
      if (a.size !== b.size) {
        return !1;
      }
      c = a._entries;
      for (e = 0; e < c.length; e += 2) {
        if (!com.cognitect.transit.eq.equals(c[e + 1], b.get(c[e]))) {
          return !1;
        }
      }
      return !0;
    }
    if (null != b && "object" === typeof b && (e = com.cognitect.transit.util.objectKeys(b), c = e.length, a.size === c)) {
      for (d = 0; d < c; d++) {
        var f = e[d];
        if (!a.has(f) || !com.cognitect.transit.eq.equals(b[f], a.get(f))) {
          return !1;
        }
      }
      return !0;
    }
    return !1;
  };
  com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD = 8;
  com.cognitect.transit.types.ARRAY_MAP_THRESHOLD = 32;
  com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD = 32;
  com.cognitect.transit.types.print = function (a) {
    return null == a ? "null" : goog.isArray(a) ? "[" + a.toString() + "]" : goog.isString(a) ? '"' + a + '"' : a.toString();
  };
  com.cognitect.transit.types.printMap = function (a) {
    var b = 0,
        c = "TransitMap {";
    a.forEach(function (d, e) {
      c += com.cognitect.transit.types.print(e) + " => " + com.cognitect.transit.types.print(d);
      b < a.size - 1 && (c += ", ");
      b++;
    });
    return c + "}";
  };
  com.cognitect.transit.types.printSet = function (a) {
    var b = 0,
        c = "TransitSet {";
    a.forEach(function (d) {
      c += com.cognitect.transit.types.print(d);
      b < a.size - 1 && (c += ", ");
      b++;
    });
    return c + "}";
  };
  com.cognitect.transit.types.TransitArrayMap = function (a) {
    this._entries = a;
    this.backingMap = null;
    this.hashCode = -1;
    this.size = a.length / 2;
    this.accesses = 0;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.toString = function () {
    return com.cognitect.transit.types.printMap(this);
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.inspect = function () {
    return this.toString();
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.convert = function () {
    if (this.backingMap) {
      throw Error("Invalid operation, already converted");
    }
    if (this.size < com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD) {
      return !1;
    }
    this.accesses++;
    return this.accesses > com.cognitect.transit.types.ARRAY_MAP_ACCESS_THRESHOLD ? (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = [], !0) : !1;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.clear = function () {
    this.hashCode = -1;
    this.backingMap ? this.backingMap.clear() : this._entries = [];
    this.size = 0;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.clear = com.cognitect.transit.types.TransitArrayMap.prototype.clear;
  com.cognitect.transit.types.TransitArrayMap.prototype.keys = function () {
    return this.backingMap ? this.backingMap.keys() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.KEYS);
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.keys = com.cognitect.transit.types.TransitArrayMap.prototype.keys;
  com.cognitect.transit.types.TransitArrayMap.prototype.keySet = function () {
    if (this.backingMap) {
      return this.backingMap.keySet();
    }
    for (var a = [], b = 0, c = 0; c < this._entries.length; b++, c += 2) {
      a[b] = this._entries[c];
    }
    return a;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.keySet = com.cognitect.transit.types.TransitArrayMap.prototype.keySet;
  com.cognitect.transit.types.TransitArrayMap.prototype.entries = function () {
    return this.backingMap ? this.backingMap.entries() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.ENTRIES);
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.entries = com.cognitect.transit.types.TransitArrayMap.prototype.entries;
  com.cognitect.transit.types.TransitArrayMap.prototype.values = function () {
    return this.backingMap ? this.backingMap.values() : new com.cognitect.transit.types.TransitArrayMapIterator(this._entries, com.cognitect.transit.types.VALUES);
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.values = com.cognitect.transit.types.TransitArrayMap.prototype.values;
  com.cognitect.transit.types.TransitArrayMap.prototype.forEach = function (a) {
    if (this.backingMap) {
      this.backingMap.forEach(a);
    } else {
      for (var b = 0; b < this._entries.length; b += 2) {
        a(this._entries[b + 1], this._entries[b]);
      }
    }
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.forEach = com.cognitect.transit.types.TransitArrayMap.prototype.forEach;
  com.cognitect.transit.types.TransitArrayMap.prototype.get = function (a, b) {
    if (this.backingMap) {
      return this.backingMap.get(a);
    }
    if (this.convert()) {
      return this.get(a);
    }
    for (var c = 0; c < this._entries.length; c += 2) {
      if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
        return this._entries[c + 1];
      }
    }
    return b;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.get = com.cognitect.transit.types.TransitArrayMap.prototype.get;
  com.cognitect.transit.types.TransitArrayMap.prototype.has = function (a) {
    if (this.backingMap) {
      return this.backingMap.has(a);
    }
    if (this.convert()) {
      return this.has(a);
    }
    for (var b = 0; b < this._entries.length; b += 2) {
      if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
        return !0;
      }
    }
    return !1;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.has = com.cognitect.transit.types.TransitArrayMap.prototype.has;
  com.cognitect.transit.types.TransitArrayMap.prototype.set = function (a, b) {
    this.hashCode = -1;
    if (this.backingMap) {
      this.backingMap.set(a, b), this.size = this.backingMap.size;
    } else {
      for (var c = 0; c < this._entries.length; c += 2) {
        if (com.cognitect.transit.eq.equals(this._entries[c], a)) {
          this._entries[c + 1] = b;
          return;
        }
      }
      this._entries.push(a);
      this._entries.push(b);
      this.size++;
      this.size > com.cognitect.transit.types.ARRAY_MAP_THRESHOLD && (this.backingMap = com.cognitect.transit.types.map(this._entries, !1, !0), this._entries = null);
    }
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.set = com.cognitect.transit.types.TransitArrayMap.prototype.set;
  com.cognitect.transit.types.TransitArrayMap.prototype["delete"] = function (a) {
    this.hashCode = -1;
    if (this.backingMap) {
      return a = this.backingMap["delete"](a), this.size = this.backingMap.size, a;
    }
    for (var b = 0; b < this._entries.length; b += 2) {
      if (com.cognitect.transit.eq.equals(this._entries[b], a)) {
        return a = this._entries[b + 1], this._entries.splice(b, 2), this.size--, a;
      }
    }
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.clone = function () {
    var a = com.cognitect.transit.types.map();
    this.forEach(function (b, c) {
      a.set(c, b);
    });
    return a;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.clone = com.cognitect.transit.types.TransitArrayMap.prototype.clone;
  com.cognitect.transit.types.TransitArrayMap.prototype[com.cognitect.transit.types.ITERATOR] = function () {
    return this.entries();
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$hashCode = function () {
    if (this.backingMap) {
      return this.backingMap.com$cognitect$transit$hashCode();
    }
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
    return this.hashCode;
  };
  com.cognitect.transit.types.TransitArrayMap.prototype.com$cognitect$transit$equals = function (a) {
    return this.backingMap ? com.cognitect.transit.types.mapEquals(this.backingMap, a) : com.cognitect.transit.types.mapEquals(this, a);
  };
  com.cognitect.transit.types.TransitMap = function (a, b, c) {
    this.map = b || {};
    this._keys = a || [];
    this.size = c || 0;
    this.hashCode = -1;
  };
  com.cognitect.transit.types.TransitMap.prototype.toString = function () {
    return com.cognitect.transit.types.printMap(this);
  };
  com.cognitect.transit.types.TransitMap.prototype.inspect = function () {
    return this.toString();
  };
  com.cognitect.transit.types.TransitMap.prototype.clear = function () {
    this.hashCode = -1;
    this.map = {};
    this._keys = [];
    this.size = 0;
  };
  com.cognitect.transit.types.TransitMap.prototype.clear = com.cognitect.transit.types.TransitMap.prototype.clear;
  com.cognitect.transit.types.TransitMap.prototype.getKeys = function () {
    return null != this._keys ? this._keys : com.cognitect.transit.util.objectKeys(this.map);
  };
  com.cognitect.transit.types.TransitMap.prototype["delete"] = function (a) {
    this.hashCode = -1;
    this._keys = null;
    for (var b = com.cognitect.transit.eq.hashCode(a), c = this.map[b], d = 0; d < c.length; d += 2) {
      if (com.cognitect.transit.eq.equals(a, c[d])) {
        return a = c[d + 1], c.splice(d, 2), 0 === c.length && delete this.map[b], this.size--, a;
      }
    }
  };
  com.cognitect.transit.types.TransitMap.prototype.entries = function () {
    return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.ENTRIES);
  };
  com.cognitect.transit.types.TransitMap.prototype.entries = com.cognitect.transit.types.TransitMap.prototype.entries;
  com.cognitect.transit.types.TransitMap.prototype.forEach = function (a) {
    for (var b = this.getKeys(), c = 0; c < b.length; c++) {
      for (var d = this.map[b[c]], e = 0; e < d.length; e += 2) {
        a(d[e + 1], d[e], this);
      }
    }
  };
  com.cognitect.transit.types.TransitMap.prototype.forEach = com.cognitect.transit.types.TransitMap.prototype.forEach;
  com.cognitect.transit.types.TransitMap.prototype.get = function (a, b) {
    var c = com.cognitect.transit.eq.hashCode(a),
        c = this.map[c];
    if (null != c) {
      for (var d = 0; d < c.length; d += 2) {
        if (com.cognitect.transit.eq.equals(a, c[d])) {
          return c[d + 1];
        }
      }
    } else {
      return b;
    }
  };
  com.cognitect.transit.types.TransitMap.prototype.get = com.cognitect.transit.types.TransitMap.prototype.get;
  com.cognitect.transit.types.TransitMap.prototype.has = function (a) {
    var b = com.cognitect.transit.eq.hashCode(a),
        b = this.map[b];
    if (null != b) {
      for (var c = 0; c < b.length; c += 2) {
        if (com.cognitect.transit.eq.equals(a, b[c])) {
          return !0;
        }
      }
    }
    return !1;
  };
  com.cognitect.transit.types.TransitMap.prototype.has = com.cognitect.transit.types.TransitMap.prototype.has;
  com.cognitect.transit.types.TransitMap.prototype.keys = function () {
    return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.KEYS);
  };
  com.cognitect.transit.types.TransitMap.prototype.keys = com.cognitect.transit.types.TransitMap.prototype.keys;
  com.cognitect.transit.types.TransitMap.prototype.keySet = function () {
    for (var a = this.getKeys(), b = [], c = 0; c < a.length; c++) {
      for (var d = this.map[a[c]], e = 0; e < d.length; e += 2) {
        b.push(d[e]);
      }
    }
    return b;
  };
  com.cognitect.transit.types.TransitMap.prototype.keySet = com.cognitect.transit.types.TransitMap.prototype.keySet;
  com.cognitect.transit.types.TransitMap.prototype.set = function (a, b) {
    this.hashCode = -1;
    var c = com.cognitect.transit.eq.hashCode(a),
        d = this.map[c];
    if (null == d) {
      this._keys && this._keys.push(c), this.map[c] = [a, b], this.size++;
    } else {
      for (var c = !0, e = 0; e < d.length; e += 2) {
        if (com.cognitect.transit.eq.equals(b, d[e])) {
          c = !1;
          d[e] = b;
          break;
        }
      }
      c && (d.push(a), d.push(b), this.size++);
    }
  };
  com.cognitect.transit.types.TransitMap.prototype.set = com.cognitect.transit.types.TransitMap.prototype.set;
  com.cognitect.transit.types.TransitMap.prototype.values = function () {
    return new com.cognitect.transit.types.TransitMapIterator(this, com.cognitect.transit.types.VALUES);
  };
  com.cognitect.transit.types.TransitMap.prototype.values = com.cognitect.transit.types.TransitMap.prototype.values;
  com.cognitect.transit.types.TransitMap.prototype.clone = function () {
    var a = com.cognitect.transit.types.map();
    this.forEach(function (b, c) {
      a.set(c, b);
    });
    return a;
  };
  com.cognitect.transit.types.TransitMap.prototype.clone = com.cognitect.transit.types.TransitMap.prototype.clone;
  com.cognitect.transit.types.TransitMap.prototype[com.cognitect.transit.types.ITERATOR] = function () {
    return this.entries();
  };
  com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$hashCode = function () {
    -1 === this.hashCode && (this.hashCode = com.cognitect.transit.eq.hashMapLike(this));
    return this.hashCode;
  };
  com.cognitect.transit.types.TransitMap.prototype.com$cognitect$transit$equals = function (a) {
    return com.cognitect.transit.types.mapEquals(this, a);
  };
  com.cognitect.transit.types.map = function (a, b, c) {
    a = a || [];
    b = !1 === b ? b : !0;
    if ((!0 !== c || !c) && a.length <= 2 * com.cognitect.transit.types.ARRAY_MAP_THRESHOLD) {
      if (b) {
        var d = a;
        a = [];
        for (b = 0; b < d.length; b += 2) {
          var e = !1;
          for (c = 0; c < a.length; c += 2) {
            if (com.cognitect.transit.eq.equals(a[c], d[b])) {
              a[c + 1] = d[b + 1];
              e = !0;
              break;
            }
          }
          e || (a.push(d[b]), a.push(d[b + 1]));
        }
      }
      return new com.cognitect.transit.types.TransitArrayMap(a);
    }
    var d = {},
        e = [],
        f = 0;
    for (b = 0; b < a.length; b += 2) {
      c = com.cognitect.transit.eq.hashCode(a[b]);
      var g = d[c];
      if (null == g) {
        e.push(c), d[c] = [a[b], a[b + 1]], f++;
      } else {
        var h = !0;
        for (c = 0; c < g.length; c += 2) {
          if (com.cognitect.transit.eq.equals(g[c], a[b])) {
            g[c + 1] = a[b + 1];
            h = !1;
            break;
          }
        }
        h && (g.push(a[b]), g.push(a[b + 1]), f++);
      }
    }
    return new com.cognitect.transit.types.TransitMap(e, d, f);
  };
  com.cognitect.transit.types.isArrayMap = function (a) {
    return a instanceof com.cognitect.transit.types.TransitArrayMap;
  };
  com.cognitect.transit.types.isMap = function (a) {
    return a instanceof com.cognitect.transit.types.TransitArrayMap || a instanceof com.cognitect.transit.types.TransitMap;
  };
  com.cognitect.transit.types.TransitSet = function (a) {
    this.map = a;
    this.size = a.size;
  };
  com.cognitect.transit.types.TransitSet.prototype.toString = function () {
    return com.cognitect.transit.types.printSet(this);
  };
  com.cognitect.transit.types.TransitSet.prototype.inspect = function () {
    return this.toString();
  };
  com.cognitect.transit.types.TransitSet.prototype.add = function (a) {
    this.map.set(a, a);
    this.size = this.map.size;
  };
  com.cognitect.transit.types.TransitSet.prototype.add = com.cognitect.transit.types.TransitSet.prototype.add;
  com.cognitect.transit.types.TransitSet.prototype.clear = function () {
    this.map = new com.cognitect.transit.types.TransitMap();
    this.size = 0;
  };
  com.cognitect.transit.types.TransitSet.prototype.clear = com.cognitect.transit.types.TransitSet.prototype.clear;
  com.cognitect.transit.types.TransitSet.prototype["delete"] = function (a) {
    a = this.map["delete"](a);
    this.size = this.map.size;
    return a;
  };
  com.cognitect.transit.types.TransitSet.prototype.entries = function () {
    return this.map.entries();
  };
  com.cognitect.transit.types.TransitSet.prototype.entries = com.cognitect.transit.types.TransitSet.prototype.entries;
  com.cognitect.transit.types.TransitSet.prototype.forEach = function (a, b) {
    var c = this;
    this.map.forEach(function (b, e, f) {
      a(e, c);
    });
  };
  com.cognitect.transit.types.TransitSet.prototype.forEach = com.cognitect.transit.types.TransitSet.prototype.forEach;
  com.cognitect.transit.types.TransitSet.prototype.has = function (a) {
    return this.map.has(a);
  };
  com.cognitect.transit.types.TransitSet.prototype.has = com.cognitect.transit.types.TransitSet.prototype.has;
  com.cognitect.transit.types.TransitSet.prototype.keys = function () {
    return this.map.keys();
  };
  com.cognitect.transit.types.TransitSet.prototype.keys = com.cognitect.transit.types.TransitSet.prototype.keys;
  com.cognitect.transit.types.TransitSet.prototype.keySet = function () {
    return this.map.keySet();
  };
  com.cognitect.transit.types.TransitSet.prototype.keySet = com.cognitect.transit.types.TransitSet.prototype.keySet;
  com.cognitect.transit.types.TransitSet.prototype.values = function () {
    return this.map.values();
  };
  com.cognitect.transit.types.TransitSet.prototype.values = com.cognitect.transit.types.TransitSet.prototype.values;
  com.cognitect.transit.types.TransitSet.prototype.clone = function () {
    var a = com.cognitect.transit.types.set();
    this.forEach(function (b) {
      a.add(b);
    });
    return a;
  };
  com.cognitect.transit.types.TransitSet.prototype.clone = com.cognitect.transit.types.TransitSet.prototype.clone;
  com.cognitect.transit.types.TransitSet.prototype[com.cognitect.transit.types.ITERATOR] = function () {
    return this.values();
  };
  com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$equals = function (a) {
    if (a instanceof com.cognitect.transit.types.TransitSet) {
      if (this.size === a.size) {
        return com.cognitect.transit.eq.equals(this.map, a.map);
      }
    } else {
      return !1;
    }
  };
  com.cognitect.transit.types.TransitSet.prototype.com$cognitect$transit$hashCode = function (a) {
    return com.cognitect.transit.eq.hashCode(this.map);
  };
  com.cognitect.transit.types.set = function (a) {
    a = a || [];
    for (var b = {}, c = [], d = 0, e = 0; e < a.length; e++) {
      var f = com.cognitect.transit.eq.hashCode(a[e]),
          g = b[f];
      if (null == g) {
        c.push(f), b[f] = [a[e], a[e]], d++;
      } else {
        for (var f = !0, h = 0; h < g.length; h += 2) {
          if (com.cognitect.transit.eq.equals(g[h], a[e])) {
            f = !1;
            break;
          }
        }
        f && (g.push(a[e]), g.push(a[e]), d++);
      }
    }
    return new com.cognitect.transit.types.TransitSet(new com.cognitect.transit.types.TransitMap(c, b, d));
  };
  com.cognitect.transit.types.isSet = function (a) {
    return a instanceof com.cognitect.transit.types.TransitSet;
  };
  com.cognitect.transit.types.quoted = function (a) {
    return com.cognitect.transit.types.taggedValue("'", a);
  };
  com.cognitect.transit.types.isQuoted = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "'" === a.tag;
  };
  com.cognitect.transit.types.list = function (a) {
    return com.cognitect.transit.types.taggedValue("list", a);
  };
  com.cognitect.transit.types.isList = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "list" === a.tag;
  };
  com.cognitect.transit.types.link = function (a) {
    return com.cognitect.transit.types.taggedValue("link", a);
  };
  com.cognitect.transit.types.isLink = function (a) {
    return a instanceof com.cognitect.transit.types.TaggedValue && "link" === a.tag;
  };
  com.cognitect.transit.types.specialDouble = function (a) {
    switch (a) {
      case "-INF":
        return -Infinity;
      case "INF":
        return Infinity;
      case "NaN":
        return NaN;
      default:
        throw Error("Invalid special double value " + a);;
    }
  };
  com.cognitect.transit.handlers = {};
  com.cognitect.transit.handlers.ctorGuid = 0;
  com.cognitect.transit.handlers.ctorGuidProperty = "transit$guid$" + com.cognitect.transit.util.randomUUID();
  com.cognitect.transit.handlers.typeTag = function (a) {
    if (null == a) {
      return "null";
    }
    if (a === String) {
      return "string";
    }
    if (a === Boolean) {
      return "boolean";
    }
    if (a === Number) {
      return "number";
    }
    if (a === Array) {
      return "array";
    }
    if (a === Object) {
      return "map";
    }
    var b = a[com.cognitect.transit.handlers.ctorGuidProperty];
    null == b && ("undefined" != typeof Object.defineProperty ? (b = ++com.cognitect.transit.handlers.ctorGuid, Object.defineProperty(a, com.cognitect.transit.handlers.ctorGuidProperty, { value: b, enumerable: !1 })) : a[com.cognitect.transit.handlers.ctorGuidProperty] = b = ++com.cognitect.transit.handlers.ctorGuid);
    return b;
  };
  com.cognitect.transit.handlers.constructor = function (a) {
    return null == a ? null : a.constructor;
  };
  com.cognitect.transit.handlers.padZeros = function (a, b) {
    for (var c = a.toString(), d = c.length; d < b; d++) {
      c = "0" + c;
    }
    return c;
  };
  com.cognitect.transit.handlers.stringableKeys = function (a) {
    a = com.cognitect.transit.util.objectKeys(a);
    for (var b = 0; b < a.length; b++) {}
    return !0;
  };
  com.cognitect.transit.handlers.NilHandler = function () {};
  com.cognitect.transit.handlers.NilHandler.prototype.tag = function (a) {
    return "_";
  };
  com.cognitect.transit.handlers.NilHandler.prototype.rep = function (a) {
    return null;
  };
  com.cognitect.transit.handlers.NilHandler.prototype.stringRep = function (a) {
    return "null";
  };
  com.cognitect.transit.handlers.StringHandler = function () {};
  com.cognitect.transit.handlers.StringHandler.prototype.tag = function (a) {
    return "s";
  };
  com.cognitect.transit.handlers.StringHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.StringHandler.prototype.stringRep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.NumberHandler = function () {};
  com.cognitect.transit.handlers.NumberHandler.prototype.tag = function (a) {
    return "i";
  };
  com.cognitect.transit.handlers.NumberHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.NumberHandler.prototype.stringRep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.IntegerHandler = function () {};
  com.cognitect.transit.handlers.IntegerHandler.prototype.tag = function (a) {
    return "i";
  };
  com.cognitect.transit.handlers.IntegerHandler.prototype.rep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.IntegerHandler.prototype.stringRep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.BooleanHandler = function () {};
  com.cognitect.transit.handlers.BooleanHandler.prototype.tag = function (a) {
    return "?";
  };
  com.cognitect.transit.handlers.BooleanHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.BooleanHandler.prototype.stringRep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.ArrayHandler = function () {};
  com.cognitect.transit.handlers.ArrayHandler.prototype.tag = function (a) {
    return "array";
  };
  com.cognitect.transit.handlers.ArrayHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.ArrayHandler.prototype.stringRep = function (a) {
    return null;
  };
  com.cognitect.transit.handlers.MapHandler = function () {};
  com.cognitect.transit.handlers.MapHandler.prototype.tag = function (a) {
    return "map";
  };
  com.cognitect.transit.handlers.MapHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.MapHandler.prototype.stringRep = function (a) {
    return null;
  };
  com.cognitect.transit.handlers.VerboseDateHandler = function () {};
  com.cognitect.transit.handlers.VerboseDateHandler.prototype.tag = function (a) {
    return "t";
  };
  com.cognitect.transit.handlers.VerboseDateHandler.prototype.rep = function (a) {
    return a.getUTCFullYear() + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCMonth() + 1, 2) + "-" + com.cognitect.transit.handlers.padZeros(a.getUTCDate(), 2) + "T" + com.cognitect.transit.handlers.padZeros(a.getUTCHours(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCMinutes(), 2) + ":" + com.cognitect.transit.handlers.padZeros(a.getUTCSeconds(), 2) + "." + com.cognitect.transit.handlers.padZeros(a.getUTCMilliseconds(), 3) + "Z";
  };
  com.cognitect.transit.handlers.VerboseDateHandler.prototype.stringRep = function (a, b) {
    return b.rep(a);
  };
  com.cognitect.transit.handlers.DateHandler = function () {};
  com.cognitect.transit.handlers.DateHandler.prototype.tag = function (a) {
    return "m";
  };
  com.cognitect.transit.handlers.DateHandler.prototype.rep = function (a) {
    return a.valueOf();
  };
  com.cognitect.transit.handlers.DateHandler.prototype.stringRep = function (a) {
    return a.valueOf().toString();
  };
  com.cognitect.transit.handlers.DateHandler.prototype.getVerboseHandler = function (a) {
    return new com.cognitect.transit.handlers.VerboseDateHandler();
  };
  com.cognitect.transit.handlers.UUIDHandler = function () {};
  com.cognitect.transit.handlers.UUIDHandler.prototype.tag = function (a) {
    return "u";
  };
  com.cognitect.transit.handlers.UUIDHandler.prototype.rep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.UUIDHandler.prototype.stringRep = function (a) {
    return a.toString();
  };
  com.cognitect.transit.handlers.KeywordHandler = function () {};
  com.cognitect.transit.handlers.KeywordHandler.prototype.tag = function (a) {
    return ":";
  };
  com.cognitect.transit.handlers.KeywordHandler.prototype.rep = function (a) {
    return a._name;
  };
  com.cognitect.transit.handlers.KeywordHandler.prototype.stringRep = function (a, b) {
    return b.rep(a);
  };
  com.cognitect.transit.handlers.SymbolHandler = function () {};
  com.cognitect.transit.handlers.SymbolHandler.prototype.tag = function (a) {
    return "$";
  };
  com.cognitect.transit.handlers.SymbolHandler.prototype.rep = function (a) {
    return a._name;
  };
  com.cognitect.transit.handlers.SymbolHandler.prototype.stringRep = function (a, b) {
    return b.rep(a);
  };
  com.cognitect.transit.handlers.TaggedHandler = function () {};
  com.cognitect.transit.handlers.TaggedHandler.prototype.tag = function (a) {
    return a.tag;
  };
  com.cognitect.transit.handlers.TaggedHandler.prototype.rep = function (a) {
    return a.rep;
  };
  com.cognitect.transit.handlers.TaggedHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.TransitSetHandler = function () {};
  com.cognitect.transit.handlers.TransitSetHandler.prototype.tag = function (a) {
    return "set";
  };
  com.cognitect.transit.handlers.TransitSetHandler.prototype.rep = function (a) {
    var b = [];
    a.forEach(function (a, d) {
      b.push(a);
    });
    return com.cognitect.transit.types.taggedValue("array", b);
  };
  com.cognitect.transit.handlers.TransitSetHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.TransitArrayMapHandler = function () {};
  com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.tag = function (a) {
    return "map";
  };
  com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.TransitArrayMapHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.TransitMapHandler = function () {};
  com.cognitect.transit.handlers.TransitMapHandler.prototype.tag = function (a) {
    return "map";
  };
  com.cognitect.transit.handlers.TransitMapHandler.prototype.rep = function (a) {
    return a;
  };
  com.cognitect.transit.handlers.TransitMapHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.BufferHandler = function () {};
  com.cognitect.transit.handlers.BufferHandler.prototype.tag = function (a) {
    return "b";
  };
  com.cognitect.transit.handlers.BufferHandler.prototype.rep = function (a) {
    return a.toString("base64");
  };
  com.cognitect.transit.handlers.BufferHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.Uint8ArrayHandler = function () {};
  com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.tag = function (a) {
    return "b";
  };
  com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.rep = function (a) {
    return com.cognitect.transit.util.Uint8ToBase64(a);
  };
  com.cognitect.transit.handlers.Uint8ArrayHandler.prototype.stringRep = function (a, b) {
    return null;
  };
  com.cognitect.transit.handlers.defaultHandlers = function (a) {
    a.set(null, new com.cognitect.transit.handlers.NilHandler());
    a.set(String, new com.cognitect.transit.handlers.StringHandler());
    a.set(Number, new com.cognitect.transit.handlers.NumberHandler());
    a.set(goog.math.Long, new com.cognitect.transit.handlers.IntegerHandler());
    a.set(Boolean, new com.cognitect.transit.handlers.BooleanHandler());
    a.set(Array, new com.cognitect.transit.handlers.ArrayHandler());
    a.set(Object, new com.cognitect.transit.handlers.MapHandler());
    a.set(Date, new com.cognitect.transit.handlers.DateHandler());
    a.set(com.cognitect.transit.types.UUID, new com.cognitect.transit.handlers.UUIDHandler());
    a.set(com.cognitect.transit.types.Keyword, new com.cognitect.transit.handlers.KeywordHandler());
    a.set(com.cognitect.transit.types.Symbol, new com.cognitect.transit.handlers.SymbolHandler());
    a.set(com.cognitect.transit.types.TaggedValue, new com.cognitect.transit.handlers.TaggedHandler());
    a.set(com.cognitect.transit.types.TransitSet, new com.cognitect.transit.handlers.TransitSetHandler());
    a.set(com.cognitect.transit.types.TransitArrayMap, new com.cognitect.transit.handlers.TransitArrayMapHandler());
    a.set(com.cognitect.transit.types.TransitMap, new com.cognitect.transit.handlers.TransitMapHandler());
    "undefined" != typeof Buffer && a.set(Buffer, new com.cognitect.transit.handlers.BufferHandler());
    "undefined" != typeof Uint8Array && a.set(Uint8Array, new com.cognitect.transit.handlers.Uint8ArrayHandler());
    return a;
  };
  com.cognitect.transit.handlers.Handlers = function () {
    this.handlers = {};
    com.cognitect.transit.handlers.defaultHandlers(this);
  };
  com.cognitect.transit.handlers.Handlers.prototype.get = function (a) {
    var b = null,
        b = "string" === typeof a ? this.handlers[a] : this.handlers[com.cognitect.transit.handlers.typeTag(a)];
    return null != b ? b : this.handlers["default"];
  };
  com.cognitect.transit.handlers.Handlers.prototype.get = com.cognitect.transit.handlers.Handlers.prototype.get;
  com.cognitect.transit.handlers.validTag = function (a) {
    switch (a) {
      case "null":
        ;
      case "string":
        ;
      case "boolean":
        ;
      case "number":
        ;
      case "array":
        ;
      case "map":
        return !1;
    }
    return !0;
  };
  com.cognitect.transit.handlers.Handlers.prototype.set = function (a, b) {
    "string" === typeof a && com.cognitect.transit.handlers.validTag(a) ? this.handlers[a] = b : this.handlers[com.cognitect.transit.handlers.typeTag(a)] = b;
  };
  com.cognitect.transit.impl = {};
  com.cognitect.transit.impl.decoder = {};
  com.cognitect.transit.impl.decoder.Tag = function (a) {
    this.str = a;
  };
  com.cognitect.transit.impl.decoder.tag = function (a) {
    return new com.cognitect.transit.impl.decoder.Tag(a);
  };
  com.cognitect.transit.impl.decoder.isTag = function (a) {
    return a && a instanceof com.cognitect.transit.impl.decoder.Tag;
  };
  com.cognitect.transit.impl.decoder.isGroundHandler = function (a) {
    switch (a) {
      case "_":
        ;
      case "s":
        ;
      case "?":
        ;
      case "i":
        ;
      case "d":
        ;
      case "b":
        ;
      case "'":
        ;
      case "array":
        ;
      case "map":
        return !0;
    }
    return !1;
  };
  com.cognitect.transit.impl.decoder.Decoder = function (a) {
    this.options = a || {};
    this.handlers = {};
    for (var b in this.defaults.handlers) {
      this.handlers[b] = this.defaults.handlers[b];
    }
    for (b in this.options.handlers) {
      if (com.cognitect.transit.impl.decoder.isGroundHandler(b)) {
        throw Error('Cannot override handler for ground type "' + b + '"');
      }
      this.handlers[b] = this.options.handlers[b];
    }
    this.preferStrings = null != this.options.preferStrings ? this.options.preferStrings : this.defaults.preferStrings;
    this.preferBuffers = null != this.options.preferBuffers ? this.options.preferBuffers : this.defaults.preferBuffers;
    this.defaultHandler = this.options.defaultHandler || this.defaults.defaultHandler;
    this.mapBuilder = this.options.mapBuilder;
    this.arrayBuilder = this.options.arrayBuilder;
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.defaults = { handlers: { _: function (a, b) {
        return com.cognitect.transit.types.nullValue();
      }, "?": function (a, b) {
        return com.cognitect.transit.types.boolValue(a);
      }, b: function (a, b) {
        return com.cognitect.transit.types.binary(a, b);
      }, i: function (a, b) {
        return com.cognitect.transit.types.intValue(a);
      }, n: function (a, b) {
        return com.cognitect.transit.types.bigInteger(a);
      }, d: function (a, b) {
        return com.cognitect.transit.types.floatValue(a);
      }, f: function (a, b) {
        return com.cognitect.transit.types.bigDecimalValue(a);
      }, c: function (a, b) {
        return com.cognitect.transit.types.charValue(a);
      }, ":": function (a, b) {
        return com.cognitect.transit.types.keyword(a);
      }, $: function (a, b) {
        return com.cognitect.transit.types.symbol(a);
      }, r: function (a, b) {
        return com.cognitect.transit.types.uri(a);
      }, z: function (a, b) {
        return com.cognitect.transit.types.specialDouble(a);
      }, "'": function (a, b) {
        return a;
      }, m: function (a, b) {
        return com.cognitect.transit.types.date(a);
      }, t: function (a, b) {
        return com.cognitect.transit.types.verboseDate(a);
      }, u: function (a, b) {
        return com.cognitect.transit.types.uuid(a);
      }, set: function (a, b) {
        return com.cognitect.transit.types.set(a);
      }, list: function (a, b) {
        return com.cognitect.transit.types.list(a);
      }, link: function (a, b) {
        return com.cognitect.transit.types.link(a);
      }, cmap: function (a, b) {
        return com.cognitect.transit.types.map(a, !1);
      } }, defaultHandler: function (a, b) {
      return com.cognitect.transit.types.taggedValue(a, b);
    }, preferStrings: !0, preferBuffers: !0 };
  com.cognitect.transit.impl.decoder.Decoder.prototype.decode = function (a, b, c, d) {
    if (null == a) {
      return null;
    }
    switch (typeof a) {
      case "string":
        return this.decodeString(a, b, c, d);
      case "object":
        return com.cognitect.transit.util.isArray(a) ? "^ " === a[0] ? this.decodeArrayHash(a, b, c, d) : this.decodeArray(a, b, c, d) : this.decodeHash(a, b, c, d);
    }
    return a;
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.decode = com.cognitect.transit.impl.decoder.Decoder.prototype.decode;
  com.cognitect.transit.impl.decoder.Decoder.prototype.decodeString = function (a, b, c, d) {
    return com.cognitect.transit.caching.isCacheable(a, c) ? (a = this.parseString(a, b, !1), b && b.write(a, c), a) : com.cognitect.transit.caching.isCacheCode(a) ? b.read(a, c) : this.parseString(a, b, c);
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.decodeHash = function (a, b, c, d) {
    c = com.cognitect.transit.util.objectKeys(a);
    var e = c[0];
    d = 1 == c.length ? this.decode(e, b, !1, !1) : null;
    if (com.cognitect.transit.impl.decoder.isTag(d)) {
      return a = a[e], c = this.handlers[d.str], null != c ? c(this.decode(a, b, !1, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, !1, !1));
    }
    if (this.mapBuilder) {
      if (c.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD && this.mapBuilder.fromArray) {
        var f = [];
        for (d = 0; d < c.length; d++) {
          e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
        }
        return this.mapBuilder.fromArray(f, a);
      }
      f = this.mapBuilder.init(a);
      for (d = 0; d < c.length; d++) {
        e = c[d], f = this.mapBuilder.add(f, this.decode(e, b, !0, !1), this.decode(a[e], b, !1, !1), a);
      }
      return this.mapBuilder.finalize(f, a);
    }
    f = [];
    for (d = 0; d < c.length; d++) {
      e = c[d], f.push(this.decode(e, b, !0, !1)), f.push(this.decode(a[e], b, !1, !1));
    }
    return com.cognitect.transit.types.map(f, !1);
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArrayHash = function (a, b, c, d) {
    if (this.mapBuilder) {
      if (a.length < 2 * com.cognitect.transit.types.SMALL_ARRAY_MAP_THRESHOLD + 1 && this.mapBuilder.fromArray) {
        d = [];
        for (c = 1; c < a.length; c += 2) {
          d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
        }
        return this.mapBuilder.fromArray(d, a);
      }
      d = this.mapBuilder.init(a);
      for (c = 1; c < a.length; c += 2) {
        d = this.mapBuilder.add(d, this.decode(a[c], b, !0, !1), this.decode(a[c + 1], b, !1, !1), a);
      }
      return this.mapBuilder.finalize(d, a);
    }
    d = [];
    for (c = 1; c < a.length; c += 2) {
      d.push(this.decode(a[c], b, !0, !1)), d.push(this.decode(a[c + 1], b, !1, !1));
    }
    return com.cognitect.transit.types.map(d, !1);
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.decodeArray = function (a, b, c, d) {
    if (d) {
      var e = [];
      for (d = 0; d < a.length; d++) {
        e.push(this.decode(a[d], b, c, !1));
      }
      return e;
    }
    e = b && b.idx;
    if (2 === a.length && "string" === typeof a[0] && (d = this.decode(a[0], b, !1, !1), com.cognitect.transit.impl.decoder.isTag(d))) {
      return a = a[1], e = this.handlers[d.str], null != e ? e = e(this.decode(a, b, c, !0), this) : com.cognitect.transit.types.taggedValue(d.str, this.decode(a, b, c, !1));
    }
    b && e != b.idx && (b.idx = e);
    if (this.arrayBuilder) {
      if (32 >= a.length && this.arrayBuilder.fromArray) {
        e = [];
        for (d = 0; d < a.length; d++) {
          e.push(this.decode(a[d], b, c, !1));
        }
        return this.arrayBuilder.fromArray(e, a);
      }
      e = this.arrayBuilder.init(a);
      for (d = 0; d < a.length; d++) {
        e = this.arrayBuilder.add(e, this.decode(a[d], b, c, !1), a);
      }
      return this.arrayBuilder.finalize(e, a);
    }
    e = [];
    for (d = 0; d < a.length; d++) {
      e.push(this.decode(a[d], b, c, !1));
    }
    return e;
  };
  com.cognitect.transit.impl.decoder.Decoder.prototype.parseString = function (a, b, c) {
    if (a.charAt(0) === com.cognitect.transit.delimiters.ESC) {
      b = a.charAt(1);
      if (b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES) {
        return a.substring(1);
      }
      if (b === com.cognitect.transit.delimiters.TAG) {
        return com.cognitect.transit.impl.decoder.tag(a.substring(2));
      }
      c = this.handlers[b];
      return null == c ? this.defaultHandler(b, a.substring(2)) : c(a.substring(2), this);
    }
    return a;
  };
  com.cognitect.transit.impl.decoder.decoder = function (a) {
    return new com.cognitect.transit.impl.decoder.Decoder(a);
  };
  com.cognitect.transit.impl.reader = {};
  com.cognitect.transit.impl.reader.JSONUnmarshaller = function (a) {
    this.decoder = new com.cognitect.transit.impl.decoder.Decoder(a);
  };
  com.cognitect.transit.impl.reader.JSONUnmarshaller.prototype.unmarshal = function (a, b) {
    return this.decoder.decode(JSON.parse(a), b);
  };
  com.cognitect.transit.impl.reader.Reader = function (a, b) {
    this.unmarshaller = a;
    this.options = b || {};
    this.cache = this.options.cache ? this.options.cache : new com.cognitect.transit.caching.ReadCache();
  };
  com.cognitect.transit.impl.reader.Reader.prototype.read = function (a) {
    a = this.unmarshaller.unmarshal(a, this.cache);
    this.cache.clear();
    return a;
  };
  com.cognitect.transit.impl.reader.Reader.prototype.read = com.cognitect.transit.impl.reader.Reader.prototype.read;
  com.cognitect.transit.impl.writer = {};
  com.cognitect.transit.impl.writer.escape = function (a) {
    if (0 < a.length) {
      var b = a.charAt(0);
      return b === com.cognitect.transit.delimiters.ESC || b === com.cognitect.transit.delimiters.SUB || b === com.cognitect.transit.delimiters.RES ? com.cognitect.transit.delimiters.ESC + a : a;
    }
    return a;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller = function (a) {
    this.opts = a || {};
    this.preferStrings = null != this.opts.preferStrings ? this.opts.preferStrings : !0;
    this.objectBuilder = this.opts.objectBuilder || null;
    this.handlers = new com.cognitect.transit.handlers.Handlers();
    if (a = this.opts.handlers) {
      if (com.cognitect.transit.util.isArray(a) || !a.forEach) {
        throw Error('transit writer "handlers" option must be a map');
      }
      var b = this;
      a.forEach(function (a, d) {
        if (void 0 !== d) {
          b.handlers.set(d, a);
        } else {
          throw Error("Cannot create handler for JavaScript undefined");
        }
      });
    }
    this.handlerForForeign = this.opts.handlerForForeign;
    this.unpack = this.opts.unpack || function (a) {
      return com.cognitect.transit.types.isArrayMap(a) && null === a.backingMap ? a._entries : !1;
    };
    this.verbose = this.opts && this.opts.verbose || !1;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.handler = function (a) {
    var b = this.handlers.get(com.cognitect.transit.handlers.constructor(a));
    return null != b ? b : (a = a && a.transitTag) ? this.handlers.get(a) : null;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.registerHandler = function (a, b) {
    this.handlers.set(a, b);
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitNil = function (a, b) {
    return a ? this.emitString(com.cognitect.transit.delimiters.ESC, "_", "", a, b) : null;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitString = function (a, b, c, d, e) {
    a = a + b + c;
    return e ? e.write(a, d) : a;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBoolean = function (a, b, c) {
    return b ? this.emitString(com.cognitect.transit.delimiters.ESC, "?", a.toString()[0], b, c) : a;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitInteger = function (a, b, c) {
    return Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "INF", b, c) : -Infinity === a ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "-INF", b, c) : isNaN(a) ? this.emitString(com.cognitect.transit.delimiters.ESC, "z", "NaN", b, c) : b || "string" === typeof a || a instanceof goog.math.Long ? this.emitString(com.cognitect.transit.delimiters.ESC, "i", a.toString(), b, c) : a;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitDouble = function (a, b, c) {
    return b ? this.emitString(a.ESC, "d", a, b, c) : a;
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitBinary = function (a, b, c) {
    return this.emitString(com.cognitect.transit.delimiters.ESC, "b", a, b, c);
  };
  com.cognitect.transit.impl.writer.JSONMarshaller.prototype.emitQuoted = function (a, b, c) {
    if (a.verbose) {
      a = {};
      var d = this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c);
      a[d] = com.cognitect.transit.impl.writer.marshal(this, b, !1, c);
      return a;
    }
    return [this.emitString(com.cognitect.transit.delimiters.ESC_TAG, "'", "", !0, c), com.cognitect.transit.impl.writer.marshal(this, b, !1, c)];
  };
  com.cognitect.transit.impl.writer.emitObjects = function (a, b, c) {
    var d = [];
    if (com.cognitect.transit.util.isArray(b)) {
      for (var e = 0; e < b.length; e++) {
        d.push(com.cognitect.transit.impl.writer.marshal(a, b[e], !1, c));
      }
    } else {
      b.forEach(function (b, e) {
        d.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, c));
      });
    }
    return d;
  };
  com.cognitect.transit.impl.writer.emitArray = function (a, b, c, d) {
    return com.cognitect.transit.impl.writer.emitObjects(a, b, d);
  };
  com.cognitect.transit.impl.writer.isStringableKey = function (a, b) {
    if ("string" !== typeof b) {
      var c = a.handler(b);
      return c && 1 === c.tag(b).length;
    }
    return !0;
  };
  com.cognitect.transit.impl.writer.stringableKeys = function (a, b) {
    var c = a.unpack(b),
        d = !0;
    if (c) {
      for (var e = 0; e < c.length && (d = com.cognitect.transit.impl.writer.isStringableKey(a, c[e]), d); e += 2) {}
      return d;
    }
    if (b.keys && (c = b.keys(), e = null, c.next)) {
      for (e = c.next(); !e.done;) {
        d = com.cognitect.transit.impl.writer.isStringableKey(a, e.value);
        if (!d) {
          break;
        }
        e = c.next();
      }
      return d;
    }
    if (b.forEach) {
      return b.forEach(function (b, c) {
        d = d && com.cognitect.transit.impl.writer.isStringableKey(a, c);
      }), d;
    }
    throw Error("Cannot walk keys of object type " + com.cognitect.transit.handlers.constructor(b).name);
  };
  com.cognitect.transit.impl.writer.isForeignObject = function (a) {
    if (a.constructor.transit$isObject) {
      return !0;
    }
    var b = a.constructor.toString(),
        b = b.substr(9),
        b = b.substr(0, b.indexOf("("));
    isObject = "Object" == b;
    "undefined" != typeof Object.defineProperty ? Object.defineProperty(a.constructor, "transit$isObject", { value: isObject, enumerable: !1 }) : a.constructor.transit$isObject = isObject;
    return isObject;
  };
  com.cognitect.transit.impl.writer.emitMap = function (a, b, c, d) {
    var e = null,
        f = null,
        g = null,
        e = null;
    c = 0;
    if (b.constructor === Object || null != b.forEach || a.handlerForForeign && com.cognitect.transit.impl.writer.isForeignObject(b)) {
      if (a.verbose) {
        if (null != b.forEach) {
          if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
            var h = {};
            b.forEach(function (b, c) {
              h[com.cognitect.transit.impl.writer.marshal(a, c, !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
            });
          } else {
            e = a.unpack(b);
            f = [];
            g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
            if (e) {
              for (; c < e.length; c += 2) {
                f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, !1)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
              }
            } else {
              b.forEach(function (b, c) {
                f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, !1));
                f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
              });
            }
            h = {};
            h[g] = f;
          }
        } else {
          for (e = com.cognitect.transit.util.objectKeys(b), h = {}; c < e.length; c++) {
            h[com.cognitect.transit.impl.writer.marshal(a, e[c], !0, !1)] = com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d);
          }
        }
        return h;
      }
      if (null != b.forEach) {
        if (com.cognitect.transit.impl.writer.stringableKeys(a, b)) {
          e = a.unpack(b);
          h = ["^ "];
          if (e) {
            for (; c < e.length; c += 2) {
              h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
            }
          } else {
            b.forEach(function (b, c) {
              h.push(com.cognitect.transit.impl.writer.marshal(a, c, !0, d));
              h.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
            });
          }
          return h;
        }
        e = a.unpack(b);
        f = [];
        g = a.emitString(com.cognitect.transit.delimiters.ESC_TAG, "cmap", "", !0, d);
        if (e) {
          for (; c < e.length; c += 2) {
            f.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !1, d)), f.push(com.cognitect.transit.impl.writer.marshal(a, e[c + 1], !1, d));
          }
        } else {
          b.forEach(function (b, c) {
            f.push(com.cognitect.transit.impl.writer.marshal(a, c, !1, d));
            f.push(com.cognitect.transit.impl.writer.marshal(a, b, !1, d));
          });
        }
        return [g, f];
      }
      h = ["^ "];
      for (e = com.cognitect.transit.util.objectKeys(b); c < e.length; c++) {
        h.push(com.cognitect.transit.impl.writer.marshal(a, e[c], !0, d)), h.push(com.cognitect.transit.impl.writer.marshal(a, b[e[c]], !1, d));
      }
      return h;
    }
    if (null != a.objectBuilder) {
      return a.objectBuilder(b, function (b) {
        return com.cognitect.transit.impl.writer.marshal(a, b, !0, d);
      }, function (b) {
        return com.cognitect.transit.impl.writer.marshal(a, b, !1, d);
      });
    }
    c = com.cognitect.transit.handlers.constructor(b).name;
    e = Error("Cannot write " + c);
    e.data = { obj: b, type: c };
    throw e;
  };
  com.cognitect.transit.impl.writer.emitTaggedMap = function (a, b, c, d, e) {
    return a.verbose ? (d = {}, d[a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e)] = com.cognitect.transit.impl.writer.marshal(a, c, !1, e), d) : [a.emitString(com.cognitect.transit.delimiters.ESC_TAG, b, "", !0, e), com.cognitect.transit.impl.writer.marshal(a, c, !1, e)];
  };
  com.cognitect.transit.impl.writer.emitEncoded = function (a, b, c, d, e, f, g) {
    if (1 === c.length) {
      if ("string" === typeof d) {
        return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
      }
      if (f || a.preferStrings) {
        (d = a.verbose && b.getVerboseHandler()) ? (c = d.tag(e), d = d.stringRep(e, d)) : d = b.stringRep(e, b);
        if (null !== d) {
          return a.emitString(com.cognitect.transit.delimiters.ESC, c, d, f, g);
        }
        a = Error('Tag "' + c + '" cannot be encoded as string');
        a.data = { tag: c, rep: d, obj: e };
        throw a;
      }
    }
    return com.cognitect.transit.impl.writer.emitTaggedMap(a, c, d, f, g);
  };
  com.cognitect.transit.impl.writer.marshal = function (a, b, c, d) {
    var e = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null),
        f = e ? e.tag(b) : null,
        g = e ? e.rep(b) : null;
    if (null != e && null != f) {
      switch (f) {
        case "_":
          return a.emitNil(c, d);
        case "s":
          return a.emitString("", "", com.cognitect.transit.impl.writer.escape(g), c, d);
        case "?":
          return a.emitBoolean(g, c, d);
        case "i":
          return a.emitInteger(g, c, d);
        case "d":
          return a.emitDouble(g, c, d);
        case "b":
          return a.emitBinary(g, c, d);
        case "'":
          return a.emitQuoted(a, g, d);
        case "array":
          return com.cognitect.transit.impl.writer.emitArray(a, g, c, d);
        case "map":
          return com.cognitect.transit.impl.writer.emitMap(a, g, c, d);
        default:
          return com.cognitect.transit.impl.writer.emitEncoded(a, e, f, g, b, c, d);
      }
    } else {
      throw a = com.cognitect.transit.handlers.constructor(b).name, c = Error("Cannot write " + a), c.data = { obj: b, type: a }, c;
    }
  };
  com.cognitect.transit.impl.writer.maybeQuoted = function (a, b) {
    var c = a.handler(b) || (a.handlerForForeign ? a.handlerForForeign(b, a.handlers) : null);
    if (null != c) {
      return 1 === c.tag(b).length ? com.cognitect.transit.types.quoted(b) : b;
    }
    var c = com.cognitect.transit.handlers.constructor(b).name,
        d = Error("Cannot write " + c);
    d.data = { obj: b, type: c };
    throw d;
  };
  com.cognitect.transit.impl.writer.marshalTop = function (a, b, c, d) {
    return JSON.stringify(com.cognitect.transit.impl.writer.marshal(a, com.cognitect.transit.impl.writer.maybeQuoted(a, b), c, d));
  };
  com.cognitect.transit.impl.writer.Writer = function (a, b) {
    this._marshaller = a;
    this.options = b || {};
    this.cache = !1 === this.options.cache ? null : this.options.cache ? this.options.cache : new com.cognitect.transit.caching.WriteCache();
  };
  com.cognitect.transit.impl.writer.Writer.prototype.marshaller = function () {
    return this._marshaller;
  };
  com.cognitect.transit.impl.writer.Writer.prototype.marshaller = com.cognitect.transit.impl.writer.Writer.prototype.marshaller;
  com.cognitect.transit.impl.writer.Writer.prototype.write = function (a, b) {
    var c = null,
        c = b || {},
        d = c.asMapKey || !1,
        e = this._marshaller.verbose ? !1 : this.cache,
        c = !1 === c.marshalTop ? com.cognitect.transit.impl.writer.marshal(this._marshaller, a, d, e) : com.cognitect.transit.impl.writer.marshalTop(this._marshaller, a, d, e);
    null != this.cache && this.cache.clear();
    return c;
  };
  com.cognitect.transit.impl.writer.Writer.prototype.write = com.cognitect.transit.impl.writer.Writer.prototype.write;
  com.cognitect.transit.impl.writer.Writer.prototype.register = function (a, b) {
    this._marshaller.registerHandler(a, b);
  };
  com.cognitect.transit.impl.writer.Writer.prototype.register = com.cognitect.transit.impl.writer.Writer.prototype.register;
  var TRANSIT_DEV = !0,
      TRANSIT_NODE_TARGET = !0,
      TRANSIT_BROWSER_TARGET = !1,
      TRANSIT_BROWSER_AMD_TARGET = !1;
  com.cognitect.transit.reader = function (a, b) {
    if ("json" === a || "json-verbose" === a || null == a) {
      var c = new com.cognitect.transit.impl.reader.JSONUnmarshaller(b);
      return new com.cognitect.transit.impl.reader.Reader(c, b);
    }
    throw Error("Cannot create reader of type " + a);
  };
  com.cognitect.transit.writer = function (a, b) {
    if ("json" === a || "json-verbose" === a || null == a) {
      "json-verbose" === a && (null == b && (b = {}), b.verbose = !0);
      var c = new com.cognitect.transit.impl.writer.JSONMarshaller(b);
      return new com.cognitect.transit.impl.writer.Writer(c, b);
    }
    c = Error('Type must be "json"');
    c.data = { type: a };
    throw c;
  };
  com.cognitect.transit.makeWriteHandler = function (a) {
    var b = function () {};
    b.prototype.tag = a.tag;
    b.prototype.rep = a.rep;
    b.prototype.stringRep = a.stringRep;
    b.prototype.getVerboseHandler = a.getVerboseHandler;
    return new b();
  };
  com.cognitect.transit.makeBuilder = function (a) {
    var b = function () {};
    b.prototype.init = a.init;
    b.prototype.add = a.add;
    b.prototype.finalize = a.finalize;
    b.prototype.fromArray = a.fromArray;
    return new b();
  };
  com.cognitect.transit.date = com.cognitect.transit.types.date;
  com.cognitect.transit.integer = com.cognitect.transit.types.intValue;
  com.cognitect.transit.isInteger = com.cognitect.transit.types.isInteger;
  com.cognitect.transit.uuid = com.cognitect.transit.types.uuid;
  com.cognitect.transit.isUUID = com.cognitect.transit.types.isUUID;
  com.cognitect.transit.bigInt = com.cognitect.transit.types.bigInteger;
  com.cognitect.transit.isBigInt = com.cognitect.transit.types.isBigInteger;
  com.cognitect.transit.bigDec = com.cognitect.transit.types.bigDecimalValue;
  com.cognitect.transit.isBigDec = com.cognitect.transit.types.isBigDecimal;
  com.cognitect.transit.keyword = com.cognitect.transit.types.keyword;
  com.cognitect.transit.isKeyword = com.cognitect.transit.types.isKeyword;
  com.cognitect.transit.symbol = com.cognitect.transit.types.symbol;
  com.cognitect.transit.isSymbol = com.cognitect.transit.types.isSymbol;
  com.cognitect.transit.binary = com.cognitect.transit.types.binary;
  com.cognitect.transit.isBinary = com.cognitect.transit.types.isBinary;
  com.cognitect.transit.uri = com.cognitect.transit.types.uri;
  com.cognitect.transit.isURI = com.cognitect.transit.types.isURI;
  com.cognitect.transit.map = com.cognitect.transit.types.map;
  com.cognitect.transit.isMap = com.cognitect.transit.types.isMap;
  com.cognitect.transit.set = com.cognitect.transit.types.set;
  com.cognitect.transit.isSet = com.cognitect.transit.types.isSet;
  com.cognitect.transit.list = com.cognitect.transit.types.list;
  com.cognitect.transit.isList = com.cognitect.transit.types.isList;
  com.cognitect.transit.quoted = com.cognitect.transit.types.quoted;
  com.cognitect.transit.isQuoted = com.cognitect.transit.types.isQuoted;
  com.cognitect.transit.tagged = com.cognitect.transit.types.taggedValue;
  com.cognitect.transit.isTaggedValue = com.cognitect.transit.types.isTaggedValue;
  com.cognitect.transit.link = com.cognitect.transit.types.link;
  com.cognitect.transit.isLink = com.cognitect.transit.types.isLink;
  com.cognitect.transit.hash = com.cognitect.transit.eq.hashCode;
  com.cognitect.transit.hashMapLike = com.cognitect.transit.eq.hashMapLike;
  com.cognitect.transit.hashArrayLike = com.cognitect.transit.eq.hashArrayLike;
  com.cognitect.transit.equals = com.cognitect.transit.eq.equals;
  com.cognitect.transit.extendToEQ = com.cognitect.transit.eq.extendToEQ;
  com.cognitect.transit.mapToObject = function (a) {
    var b = {};
    a.forEach(function (a, d) {
      if ("string" !== typeof d) {
        throw Error("Cannot convert map with non-string keys");
      }
      b[d] = a;
    });
    return b;
  };
  com.cognitect.transit.objectToMap = function (a) {
    var b = com.cognitect.transit.map(),
        c;
    for (c in a) {
      a.hasOwnProperty(c) && b.set(c, a[c]);
    }
    return b;
  };
  com.cognitect.transit.decoder = com.cognitect.transit.impl.decoder.decoder;
  com.cognitect.transit.readCache = com.cognitect.transit.caching.readCache;
  com.cognitect.transit.writeCache = com.cognitect.transit.caching.writeCache;
  com.cognitect.transit.UUIDfromString = com.cognitect.transit.types.UUIDfromString;
  com.cognitect.transit.randomUUID = com.cognitect.transit.util.randomUUID;
  com.cognitect.transit.stringableKeys = com.cognitect.transit.impl.writer.stringableKeys;
  TRANSIT_BROWSER_TARGET && (goog.exportSymbol("transit.reader", com.cognitect.transit.reader), goog.exportSymbol("transit.writer", com.cognitect.transit.writer), goog.exportSymbol("transit.makeBuilder", com.cognitect.transit.makeBuilder), goog.exportSymbol("transit.makeWriteHandler", com.cognitect.transit.makeWriteHandler), goog.exportSymbol("transit.date", com.cognitect.transit.types.date), goog.exportSymbol("transit.integer", com.cognitect.transit.types.intValue), goog.exportSymbol("transit.isInteger", com.cognitect.transit.types.isInteger), goog.exportSymbol("transit.uuid", com.cognitect.transit.types.uuid), goog.exportSymbol("transit.isUUID", com.cognitect.transit.types.isUUID), goog.exportSymbol("transit.bigInt", com.cognitect.transit.types.bigInteger), goog.exportSymbol("transit.isBigInt", com.cognitect.transit.types.isBigInteger), goog.exportSymbol("transit.bigDec", com.cognitect.transit.types.bigDecimalValue), goog.exportSymbol("transit.isBigDec", com.cognitect.transit.types.isBigDecimal), goog.exportSymbol("transit.keyword", com.cognitect.transit.types.keyword), goog.exportSymbol("transit.isKeyword", com.cognitect.transit.types.isKeyword), goog.exportSymbol("transit.symbol", com.cognitect.transit.types.symbol), goog.exportSymbol("transit.isSymbol", com.cognitect.transit.types.isSymbol), goog.exportSymbol("transit.binary", com.cognitect.transit.types.binary), goog.exportSymbol("transit.isBinary", com.cognitect.transit.types.isBinary), goog.exportSymbol("transit.uri", com.cognitect.transit.types.uri), goog.exportSymbol("transit.isURI", com.cognitect.transit.types.isURI), goog.exportSymbol("transit.map", com.cognitect.transit.types.map), goog.exportSymbol("transit.isMap", com.cognitect.transit.types.isMap), goog.exportSymbol("transit.set", com.cognitect.transit.types.set), goog.exportSymbol("transit.isSet", com.cognitect.transit.types.isSet), goog.exportSymbol("transit.list", com.cognitect.transit.types.list), goog.exportSymbol("transit.isList", com.cognitect.transit.types.isList), goog.exportSymbol("transit.quoted", com.cognitect.transit.types.quoted), goog.exportSymbol("transit.isQuoted", com.cognitect.transit.types.isQuoted), goog.exportSymbol("transit.tagged", com.cognitect.transit.types.taggedValue), goog.exportSymbol("transit.isTaggedValue", com.cognitect.transit.types.isTaggedValue), goog.exportSymbol("transit.link", com.cognitect.transit.types.link), goog.exportSymbol("transit.isLink", com.cognitect.transit.types.isLink), goog.exportSymbol("transit.hash", com.cognitect.transit.eq.hashCode), goog.exportSymbol("transit.hashMapLike", com.cognitect.transit.eq.hashMapLike), goog.exportSymbol("transit.hashArrayLike", com.cognitect.transit.eq.hashArrayLike), goog.exportSymbol("transit.equals", com.cognitect.transit.eq.equals), goog.exportSymbol("transit.extendToEQ", com.cognitect.transit.eq.extendToEQ), goog.exportSymbol("transit.mapToObject", com.cognitect.transit.mapToObject), goog.exportSymbol("transit.objectToMap", com.cognitect.transit.objectToMap), goog.exportSymbol("transit.decoder", com.cognitect.transit.impl.decoder.decoder), goog.exportSymbol("transit.UUIDfromString", com.cognitect.transit.types.UUIDfromString), goog.exportSymbol("transit.randomUUID", com.cognitect.transit.util.randomUUID), goog.exportSymbol("transit.stringableKeys", com.cognitect.transit.impl.writer.stringableKeys), goog.exportSymbol("transit.readCache", com.cognitect.transit.caching.readCache), goog.exportSymbol("transit.writeCache", com.cognitect.transit.caching.writeCache));
  TRANSIT_NODE_TARGET && (module.exports = { reader: com.cognitect.transit.reader, writer: com.cognitect.transit.writer, makeBuilder: com.cognitect.transit.makeBuilder, makeWriteHandler: com.cognitect.transit.makeWriteHandler, date: com.cognitect.transit.types.date, integer: com.cognitect.transit.types.intValue, isInteger: com.cognitect.transit.types.isInteger, uuid: com.cognitect.transit.types.uuid, isUUID: com.cognitect.transit.types.isUUID, bigInt: com.cognitect.transit.types.bigInteger, isBigInt: com.cognitect.transit.types.isBigInteger,
    bigDec: com.cognitect.transit.types.bigDecimalValue, isBigDec: com.cognitect.transit.types.isBigDecimal, keyword: com.cognitect.transit.types.keyword, isKeyword: com.cognitect.transit.types.isKeyword, symbol: com.cognitect.transit.types.symbol, isSymbol: com.cognitect.transit.types.isSymbol, binary: com.cognitect.transit.types.binary, isBinary: com.cognitect.transit.types.isBinary, uri: com.cognitect.transit.types.uri, isURI: com.cognitect.transit.types.isURI, map: com.cognitect.transit.types.map, isMap: com.cognitect.transit.types.isMap,
    set: com.cognitect.transit.types.set, isSet: com.cognitect.transit.types.isSet, list: com.cognitect.transit.types.list, isList: com.cognitect.transit.types.isList, quoted: com.cognitect.transit.types.quoted, isQuoted: com.cognitect.transit.types.isQuoted, tagged: com.cognitect.transit.types.taggedValue, isTaggedValue: com.cognitect.transit.types.isTaggedValue, link: com.cognitect.transit.types.link, isLink: com.cognitect.transit.types.isLink, hash: com.cognitect.transit.eq.hashCode, hashArrayLike: com.cognitect.transit.eq.hashArrayLike,
    hashMapLike: com.cognitect.transit.eq.hashMapLike, equals: com.cognitect.transit.eq.equals, extendToEQ: com.cognitect.transit.eq.extendToEQ, mapToObject: com.cognitect.transit.mapToObject, objectToMap: com.cognitect.transit.objectToMap, decoder: com.cognitect.transit.impl.decoder.decoder, UUIDfromString: com.cognitect.transit.types.UUIDfromString, randomUUID: com.cognitect.transit.util.randomUUID, stringableKeys: com.cognitect.transit.impl.writer.stringableKeys, readCache: com.cognitect.transit.caching.readCache,
    writeCache: com.cognitect.transit.caching.writeCache });
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/serializer.js", ["transit-js", "immutable", "./syntax", "./symbol", "shift-parser/dist/tokenizer", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.serializer = exports.makeDeserializer = void 0;var _transitJs = $__require("transit-js"),
      _transitJs2 = _interopRequireDefault(_transitJs),
      _immutable = $__require("immutable"),
      _syntax = $__require("./syntax"),
      _syntax2 = _interopRequireDefault(_syntax),
      _symbol = $__require("./symbol"),
      _tokenizer = $__require("shift-parser/dist/tokenizer");function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }let typeMap = [_tokenizer.TokenType.STRING, _tokenizer.TokenType.EOS, _tokenizer.TokenType.LPAREN, _tokenizer.TokenType.RPAREN, _tokenizer.TokenType.LBRACK, _tokenizer.TokenType.RBRACK, _tokenizer.TokenType.LBRACE, _tokenizer.TokenType.RBRACE, _tokenizer.TokenType.COLON, _tokenizer.TokenType.SEMICOLON, _tokenizer.TokenType.PERIOD, _tokenizer.TokenType.ELLIPSIS, _tokenizer.TokenType.ARROW, _tokenizer.TokenType.CONDITIONAL, _tokenizer.TokenType.INC, _tokenizer.TokenType.DEC, _tokenizer.TokenType.ASSIGN, _tokenizer.TokenType.ASSIGN_BIT_OR, _tokenizer.TokenType.ASSIGN_BIT_XOR, _tokenizer.TokenType.ASSIGN_BIT_AND, _tokenizer.TokenType.ASSIGN_SHL, _tokenizer.TokenType.ASSIGN_SHR, _tokenizer.TokenType.ASSIGN_SHR_UNSIGNED, _tokenizer.TokenType.ASSIGN_ADD, _tokenizer.TokenType.ASSIGN_SUB, _tokenizer.TokenType.ASSIGN_MUL, _tokenizer.TokenType.ASSIGN_DIV, _tokenizer.TokenType.ASSIGN_MOD, _tokenizer.TokenType.COMMA, _tokenizer.TokenType.OR, _tokenizer.TokenType.AND, _tokenizer.TokenType.BIT_OR, _tokenizer.TokenType.BIT_XOR, _tokenizer.TokenType.BIT_AND, _tokenizer.TokenType.SHL, _tokenizer.TokenType.SHR, _tokenizer.TokenType.SHR_UNSIGNED, _tokenizer.TokenType.ADD, _tokenizer.TokenType.SUB, _tokenizer.TokenType.MUL, _tokenizer.TokenType.DIV, _tokenizer.TokenType.MOD, _tokenizer.TokenType.EQ, _tokenizer.TokenType.NE, _tokenizer.TokenType.EQ_STRICT, _tokenizer.TokenType.NE_STRICT, _tokenizer.TokenType.LT, _tokenizer.TokenType.GT, _tokenizer.TokenType.LTE, _tokenizer.TokenType.GTE, _tokenizer.TokenType.INSTANCEOF, _tokenizer.TokenType.IN, _tokenizer.TokenType.NOT, _tokenizer.TokenType.BIT_NOT, _tokenizer.TokenType.AWAIT, _tokenizer.TokenType.DELETE, _tokenizer.TokenType.TYPEOF, _tokenizer.TokenType.VOID, _tokenizer.TokenType.BREAK, _tokenizer.TokenType.CASE, _tokenizer.TokenType.CATCH, _tokenizer.TokenType.CLASS, _tokenizer.TokenType.CONTINUE, _tokenizer.TokenType.DEBUGGER, _tokenizer.TokenType.DEFAULT, _tokenizer.TokenType.DO, _tokenizer.TokenType.ELSE, _tokenizer.TokenType.EXPORT, _tokenizer.TokenType.EXTENDS, _tokenizer.TokenType.FINALLY, _tokenizer.TokenType.FOR, _tokenizer.TokenType.FUNCTION, _tokenizer.TokenType.IF, _tokenizer.TokenType.IMPORT, _tokenizer.TokenType.LET, _tokenizer.TokenType.NEW, _tokenizer.TokenType.RETURN, _tokenizer.TokenType.SUPER, _tokenizer.TokenType.SWITCH, _tokenizer.TokenType.THIS, _tokenizer.TokenType.THROW, _tokenizer.TokenType.TRY, _tokenizer.TokenType.VAR, _tokenizer.TokenType.WHILE, _tokenizer.TokenType.WITH, _tokenizer.TokenType.NULL, _tokenizer.TokenType.TRUE, _tokenizer.TokenType.FALSE, _tokenizer.TokenType.YIELD, _tokenizer.TokenType.NUMBER, _tokenizer.TokenType.STRING, _tokenizer.TokenType.REGEXP, _tokenizer.TokenType.IDENTIFIER, _tokenizer.TokenType.CONST, _tokenizer.TokenType.TEMPLATE, _tokenizer.TokenType.ILLEGAL],
      ListHandler = _transitJs2.default.makeWriteHandler({ tag: () => "array", rep: a => a }),
      MapHandler = _transitJs2.default.makeWriteHandler({ tag: function () {
      return "map";
    }, rep: function (b) {
      return b;
    }, stringRep: function () {
      return null;
    } }),
      SyntaxHandler = _transitJs2.default.makeWriteHandler({ tag: () => "stx", rep: a => {
      if (_immutable.List.isList(a.token)) return [a.token, a.scopesets];let b = _transitJs2.default.objectToMap(a.token);return b.set("type", typeMap.indexOf(a.token.type)), [b, a.scopesets];
    } }),
      SymbolHandler = _transitJs2.default.makeWriteHandler({ tag: () => "symb", rep: a => [a.name] }),
      writer = _transitJs2.default.writer("json", { handlers: _transitJs2.default.map([_immutable.List, ListHandler, _immutable.Map, MapHandler, _syntax2.default, SyntaxHandler, _symbol.SymbolClass, SymbolHandler]) });function makeReader(a) {
    return _transitJs2.default.reader("json", { arrayBuilder: { init: () => (0, _immutable.List)().asMutable(), add: (b, c) => b.push(c), finalize: b => b.asImmutable(), fromArray: b => (0, _immutable.List)(b) }, mapBuilder: { init: function () {
          return (0, _immutable.Map)().asMutable();
        }, add: function (c, d, e) {
          return c.set(d, e);
        }, finalize: function (c) {
          return c.asImmutable();
        } }, handlers: { stx: b => {
          let c = _transitJs2.default.mapToObject(b[1]);if (_immutable.List.isList(b[0])) {
            let d = b[0];return new _syntax2.default(d, { bindings: a, scopesets: c });
          }let d = _transitJs2.default.mapToObject(b[0]);return d.type = typeMap[b[0].get("type")], d.slice = b[0].has("slice") ? _transitJs2.default.mapToObject(b[0].get("slice")) : void 0, d.slice && (d.slice.startLocation = _transitJs2.default.mapToObject(d.slice.startLocation)), new _syntax2.default(d, { bindings: a, scopesets: c });
        }, symb: b => {
          return (0, _symbol.Symbol)(b[0]);
        } } });
  }exports.makeDeserializer = makeReader, exports.serializer = writer;
});
System.registerDynamic("npm:shift-codegen@5.0.2/dist/minimal-codegen.js", ["object-assign", "esutils", "./coderep"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _objectAssign = $__require("object-assign");

  var _objectAssign2 = _interopRequireDefault(_objectAssign);

  var _esutils = $__require("esutils");

  var _coderep = $__require("./coderep");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function p(node, precedence, a) {
    return (0, _coderep.getPrecedence)(node) < precedence ? paren(a) : a;
  }

  function t(token) {
    return new _coderep.Token(token);
  }

  function paren(rep) {
    return new _coderep.Paren(rep);
  }

  function brace(rep) {
    return new _coderep.Brace(rep);
  }

  function bracket(rep) {
    return new _coderep.Bracket(rep);
  }

  function noIn(rep) {
    return new _coderep.NoIn(rep);
  }

  function markContainsIn(state) {
    return state.containsIn ? new _coderep.ContainsIn(state) : state;
  }

  function seq() {
    for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
      reps[_key] = arguments[_key];
    }

    return new _coderep.Seq(reps);
  }

  function semi() {
    return new _coderep.Semi();
  }

  function semiOp() {
    return new _coderep.SemiOp();
  }

  function empty() {
    return new _coderep.Empty();
  }

  function commaSep(pieces) {
    return new _coderep.CommaSep(pieces);
  }

  function getAssignmentExpr(state) {
    return state ? state.containsGroup ? paren(state) : state : empty();
  }

  var MinimalCodeGen = function () {
    function MinimalCodeGen() {
      _classCallCheck(this, MinimalCodeGen);
    }

    _createClass(MinimalCodeGen, [{
      key: "parenToAvoidBeingDirective",
      value: function parenToAvoidBeingDirective(element, original) {
        if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
          return seq(paren(original.children[0]), semiOp());
        }
        return original;
      }
    }, {
      key: "reduceArrayExpression",
      value: function reduceArrayExpression(node, _ref) {
        var elements = _ref.elements;

        if (elements.length === 0) {
          return bracket(empty());
        }

        var content = commaSep(elements.map(getAssignmentExpr));
        if (elements.length > 0 && elements[elements.length - 1] == null) {
          content = seq(content, t(","));
        }
        return bracket(content);
      }
    }, {
      key: "reduceSpreadElement",
      value: function reduceSpreadElement(node, _ref2) {
        var expression = _ref2.expression;

        return seq(t("..."), p(node.expression, _coderep.Precedence.Assignment, expression));
      }
    }, {
      key: "reduceAssignmentExpression",
      value: function reduceAssignmentExpression(node, _ref3) {
        var binding = _ref3.binding;
        var expression = _ref3.expression;

        var leftCode = binding;
        var rightCode = expression;
        var containsIn = expression.containsIn;
        var startsWithCurly = binding.startsWithCurly;
        var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
        if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
          rightCode = paren(rightCode);
          containsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, t("="), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
      }
    }, {
      key: "reduceAssignmentTargetIdentifier",
      value: function reduceAssignmentTargetIdentifier(node) {
        var a = t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceAssignmentTargetWithDefault",
      value: function reduceAssignmentTargetWithDefault(node, _ref4) {
        var binding = _ref4.binding;
        var init = _ref4.init;

        return seq(binding, t("="), p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceCompoundAssignmentExpression",
      value: function reduceCompoundAssignmentExpression(node, _ref5) {
        var binding = _ref5.binding;
        var expression = _ref5.expression;

        var leftCode = binding;
        var rightCode = expression;
        var containsIn = expression.containsIn;
        var startsWithCurly = binding.startsWithCurly;
        var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
        if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
          rightCode = paren(rightCode);
          containsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
      }
    }, {
      key: "reduceBinaryExpression",
      value: function reduceBinaryExpression(node, _ref6) {
        var left = _ref6.left;
        var right = _ref6.right;

        var leftCode = left;
        var startsWithCurly = left.startsWithCurly;
        var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
        var leftContainsIn = left.containsIn;
        if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
          leftCode = paren(leftCode);
          startsWithCurly = false;
          startsWithLetSquareBracket = false;
          startsWithFunctionOrClass = false;
          leftContainsIn = false;
        }
        var rightCode = right;
        var rightContainsIn = right.containsIn;
        if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
          rightCode = paren(rightCode);
          rightContainsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, t(node.operator), rightCode), {
          containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
          containsGroup: node.operator == ",",
          startsWithCurly: startsWithCurly,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithFunctionOrClass: startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceBindingWithDefault",
      value: function reduceBindingWithDefault(node, _ref7) {
        var binding = _ref7.binding;
        var init = _ref7.init;

        return seq(binding, t("="), p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceBindingIdentifier",
      value: function reduceBindingIdentifier(node) {
        var a = t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceArrayAssignmentTarget",
      value: function reduceArrayAssignmentTarget(node, _ref8) {
        var elements = _ref8.elements;
        var rest = _ref8.rest;

        var content = void 0;
        if (elements.length === 0) {
          content = rest == null ? empty() : seq(t("..."), rest);
        } else {
          elements = elements.concat(rest == null ? [] : [seq(t("..."), rest)]);
          content = commaSep(elements.map(getAssignmentExpr));
          if (elements.length > 0 && elements[elements.length - 1] == null) {
            content = seq(content, t(","));
          }
        }
        return bracket(content);
      }
    }, {
      key: "reduceArrayBinding",
      value: function reduceArrayBinding(node, _ref9) {
        var elements = _ref9.elements;
        var rest = _ref9.rest;

        var content = void 0;
        if (elements.length === 0) {
          content = rest == null ? empty() : seq(t("..."), rest);
        } else {
          elements = elements.concat(rest == null ? [] : [seq(t("..."), rest)]);
          content = commaSep(elements.map(getAssignmentExpr));
          if (elements.length > 0 && elements[elements.length - 1] == null) {
            content = seq(content, t(","));
          }
        }
        return bracket(content);
      }
    }, {
      key: "reduceObjectAssignmentTarget",
      value: function reduceObjectAssignmentTarget(node, _ref10) {
        var properties = _ref10.properties;

        var state = brace(commaSep(properties));
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceObjectBinding",
      value: function reduceObjectBinding(node, _ref11) {
        var properties = _ref11.properties;

        var state = brace(commaSep(properties));
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceAssignmentTargetPropertyIdentifier",
      value: function reduceAssignmentTargetPropertyIdentifier(node, _ref12) {
        var binding = _ref12.binding;
        var init = _ref12.init;

        if (node.init == null) return binding;
        return seq(binding, t("="), p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceAssignmentTargetPropertyProperty",
      value: function reduceAssignmentTargetPropertyProperty(node, _ref13) {
        var name = _ref13.name;
        var binding = _ref13.binding;

        return seq(name, t(":"), binding);
      }
    }, {
      key: "reduceBindingPropertyIdentifier",
      value: function reduceBindingPropertyIdentifier(node, _ref14) {
        var binding = _ref14.binding;
        var init = _ref14.init;

        if (node.init == null) return binding;
        return seq(binding, t("="), p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceBindingPropertyProperty",
      value: function reduceBindingPropertyProperty(node, _ref15) {
        var name = _ref15.name;
        var binding = _ref15.binding;

        return seq(name, t(":"), binding);
      }
    }, {
      key: "reduceBlock",
      value: function reduceBlock(node, _ref16) {
        var statements = _ref16.statements;

        return brace(seq.apply(undefined, _toConsumableArray(statements)));
      }
    }, {
      key: "reduceBlockStatement",
      value: function reduceBlockStatement(node, _ref17) {
        var block = _ref17.block;

        return block;
      }
    }, {
      key: "reduceBreakStatement",
      value: function reduceBreakStatement(node) {
        return seq(t("break"), node.label ? t(node.label) : empty(), semiOp());
      }
    }, {
      key: "reduceCallExpression",
      value: function reduceCallExpression(node, _ref18) {
        var callee = _ref18.callee;
        var args = _ref18.arguments;

        return (0, _objectAssign2.default)(seq(p(node.callee, (0, _coderep.getPrecedence)(node), callee), paren(commaSep(args))), {
          startsWithCurly: callee.startsWithCurly,
          startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
          startsWithFunctionOrClass: callee.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceCatchClause",
      value: function reduceCatchClause(node, _ref19) {
        var binding = _ref19.binding;
        var body = _ref19.body;

        return seq(t("catch"), paren(binding), body);
      }
    }, {
      key: "reduceClassDeclaration",
      value: function reduceClassDeclaration(node, _ref20) {
        var name = _ref20.name;
        var _super = _ref20.super;
        var elements = _ref20.elements;

        var state = seq(t("class"), node.name.name === "*default*" ? empty() : name);
        if (_super != null) {
          state = seq(state, t("extends"), p(node.super, _coderep.Precedence.New, _super));
        }
        state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
        return state;
      }
    }, {
      key: "reduceClassExpression",
      value: function reduceClassExpression(node, _ref21) {
        var name = _ref21.name;
        var _super = _ref21.super;
        var elements = _ref21.elements;

        var state = t("class");
        if (name != null) {
          state = seq(state, name);
        }
        if (_super != null) {
          state = seq(state, t("extends"), p(node.super, _coderep.Precedence.New, _super));
        }
        state = seq.apply(undefined, [state, t("{")].concat(_toConsumableArray(elements), [t("}")]));
        state.startsWithFunctionOrClass = true;
        return state;
      }
    }, {
      key: "reduceClassElement",
      value: function reduceClassElement(node, _ref22) {
        var method = _ref22.method;

        if (!node.isStatic) return method;
        return seq(t("static"), method);
      }
    }, {
      key: "reduceComputedMemberAssignmentTarget",
      value: function reduceComputedMemberAssignmentTarget(node, _ref23) {
        var object = _ref23.object;
        var expression = _ref23.expression;

        var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
        return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
          startsWithLet: object.startsWithLet,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithCurly: object.startsWithCurly,
          startsWithFunctionOrClass: object.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceComputedMemberExpression",
      value: function reduceComputedMemberExpression(node, _ref24) {
        var object = _ref24.object;
        var expression = _ref24.expression;

        var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
        return (0, _objectAssign2.default)(seq(p(node.object, (0, _coderep.getPrecedence)(node), object), bracket(expression)), {
          startsWithLet: object.startsWithLet,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithCurly: object.startsWithCurly,
          startsWithFunctionOrClass: object.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceComputedPropertyName",
      value: function reduceComputedPropertyName(node, _ref25) {
        var expression = _ref25.expression;

        return bracket(p(node.expression, _coderep.Precedence.Assignment, expression));
      }
    }, {
      key: "reduceConditionalExpression",
      value: function reduceConditionalExpression(node, _ref26) {
        var test = _ref26.test;
        var consequent = _ref26.consequent;
        var alternate = _ref26.alternate;

        var containsIn = test.containsIn || alternate.containsIn;
        var startsWithCurly = test.startsWithCurly;
        var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
        return (0, _objectAssign2.default)(seq(p(node.test, _coderep.Precedence.LogicalOR, test), t("?"), p(node.consequent, _coderep.Precedence.Assignment, consequent), t(":"), p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
          containsIn: containsIn,
          startsWithCurly: startsWithCurly,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithFunctionOrClass: startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceContinueStatement",
      value: function reduceContinueStatement(node) {
        return seq(t("continue"), node.label ? t(node.label) : empty(), semiOp());
      }
    }, {
      key: "reduceDataProperty",
      value: function reduceDataProperty(node, _ref27) {
        var name = _ref27.name;
        var expression = _ref27.expression;

        return seq(name, t(":"), getAssignmentExpr(expression));
      }
    }, {
      key: "reduceDebuggerStatement",
      value: function reduceDebuggerStatement(node) {
        return seq(t("debugger"), semiOp());
      }
    }, {
      key: "reduceDoWhileStatement",
      value: function reduceDoWhileStatement(node, _ref28) {
        var body = _ref28.body;
        var test = _ref28.test;

        return seq(t("do"), body, t("while"), paren(test), semiOp());
      }
    }, {
      key: "reduceEmptyStatement",
      value: function reduceEmptyStatement(node) {
        return semi();
      }
    }, {
      key: "reduceExpressionStatement",
      value: function reduceExpressionStatement(node, _ref29) {
        var expression = _ref29.expression;

        var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
        return seq(needsParens ? paren(expression) : expression, semiOp());
      }
    }, {
      key: "reduceForInStatement",
      value: function reduceForInStatement(node, _ref30) {
        var left = _ref30.left;
        var right = _ref30.right;
        var body = _ref30.body;

        var leftP = left;
        switch (node.left.type) {
          case "VariableDeclaration":
            leftP = noIn(markContainsIn(left));
            break;
          case "AssignmentTargetIdentifier":
            if (node.left.name === "let") {
              leftP = paren(left);
            }
            break;
        }
        return (0, _objectAssign2.default)(seq(t("for"), paren(seq(leftP, t("in"), right)), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceForOfStatement",
      value: function reduceForOfStatement(node, _ref31) {
        var left = _ref31.left;
        var right = _ref31.right;
        var body = _ref31.body;

        left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
        return (0, _objectAssign2.default)(seq(t("for"), paren(seq(left.startsWithLet ? paren(left) : left, t("of"), p(node.right, _coderep.Precedence.Assignment, right))), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceForStatement",
      value: function reduceForStatement(node, _ref32) {
        var init = _ref32.init;
        var test = _ref32.test;
        var update = _ref32.update;
        var body = _ref32.body;

        return (0, _objectAssign2.default)(seq(t("for"), paren(seq(init ? noIn(markContainsIn(init)) : empty(), semi(), test || empty(), semi(), update || empty())), body), {
          endsWithMissingElse: body.endsWithMissingElse
        });
      }
    }, {
      key: "reduceFunctionBody",
      value: function reduceFunctionBody(node, _ref33) {
        var directives = _ref33.directives;
        var statements = _ref33.statements;

        if (statements.length) {
          statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
      }
    }, {
      key: "reduceFunctionDeclaration",
      value: function reduceFunctionDeclaration(node, _ref34) {
        var name = _ref34.name;
        var params = _ref34.params;
        var body = _ref34.body;

        return seq(t("function"), node.isGenerator ? t("*") : empty(), node.name.name === "*default*" ? empty() : name, paren(params), brace(body));
      }
    }, {
      key: "reduceFunctionExpression",
      value: function reduceFunctionExpression(node, _ref35) {
        var name = _ref35.name;
        var params = _ref35.params;
        var body = _ref35.body;

        var state = seq(t("function"), node.isGenerator ? t("*") : empty(), name ? name : empty(), paren(params), brace(body));
        state.startsWithFunctionOrClass = true;
        return state;
      }
    }, {
      key: "reduceFormalParameters",
      value: function reduceFormalParameters(node, _ref36) {
        var items = _ref36.items;
        var rest = _ref36.rest;

        return commaSep(items.concat(rest == null ? [] : [seq(t("..."), rest)]));
      }
    }, {
      key: "reduceArrowExpression",
      value: function reduceArrowExpression(node, _ref37) {
        var params = _ref37.params;
        var body = _ref37.body;

        if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
          params = paren(params);
        }
        var containsIn = false;
        if (node.body.type === "FunctionBody") {
          body = brace(body);
        } else if (body.startsWithCurly) {
          body = paren(body);
        } else if (body.containsIn) {
          containsIn = true;
        }
        return (0, _objectAssign2.default)(seq(params, t("=>"), p(node.body, _coderep.Precedence.Assignment, body)), { containsIn: containsIn });
      }
    }, {
      key: "reduceGetter",
      value: function reduceGetter(node, _ref38) {
        var name = _ref38.name;
        var body = _ref38.body;

        return seq(t("get"), name, paren(empty()), brace(body));
      }
    }, {
      key: "reduceIdentifierExpression",
      value: function reduceIdentifierExpression(node) {
        var a = t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceIfStatement",
      value: function reduceIfStatement(node, _ref39) {
        var test = _ref39.test;
        var consequent = _ref39.consequent;
        var alternate = _ref39.alternate;

        if (alternate && consequent.endsWithMissingElse) {
          consequent = brace(consequent);
        }
        return (0, _objectAssign2.default)(seq(t("if"), paren(test), consequent, alternate ? seq(t("else"), alternate) : empty()), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
      }
    }, {
      key: "reduceImport",
      value: function reduceImport(node, _ref40) {
        var defaultBinding = _ref40.defaultBinding;
        var namedImports = _ref40.namedImports;

        var bindings = [];
        if (defaultBinding != null) {
          bindings.push(defaultBinding);
        }
        if (namedImports.length > 0) {
          bindings.push(brace(commaSep(namedImports)));
        }
        if (bindings.length === 0) {
          return seq(t("import"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
        }
        return seq(t("import"), commaSep(bindings), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
      }
    }, {
      key: "reduceImportNamespace",
      value: function reduceImportNamespace(node, _ref41) {
        var defaultBinding = _ref41.defaultBinding;
        var namespaceBinding = _ref41.namespaceBinding;

        return seq(t("import"), defaultBinding == null ? empty() : seq(defaultBinding, t(",")), t("*"), t("as"), namespaceBinding, t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
      }
    }, {
      key: "reduceImportSpecifier",
      value: function reduceImportSpecifier(node, _ref42) {
        var binding = _ref42.binding;

        if (node.name == null) return binding;
        return seq(t(node.name), t("as"), binding);
      }
    }, {
      key: "reduceExportAllFrom",
      value: function reduceExportAllFrom(node) {
        return seq(t("export"), t("*"), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
      }
    }, {
      key: "reduceExportFrom",
      value: function reduceExportFrom(node, _ref43) {
        var namedExports = _ref43.namedExports;

        return seq(t("export"), brace(commaSep(namedExports)), t("from"), t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), semiOp());
      }
    }, {
      key: "reduceExportLocals",
      value: function reduceExportLocals(node, _ref44) {
        var namedExports = _ref44.namedExports;

        return seq(t("export"), brace(commaSep(namedExports)), semiOp());
      }
    }, {
      key: "reduceExport",
      value: function reduceExport(node, _ref45) {
        var declaration = _ref45.declaration;

        switch (node.declaration.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            break;
          default:
            declaration = seq(declaration, semiOp());
        }
        return seq(t("export"), declaration);
      }
    }, {
      key: "reduceExportDefault",
      value: function reduceExportDefault(node, _ref46) {
        var body = _ref46.body;

        body = body.startsWithFunctionOrClass ? paren(body) : body;
        switch (node.body.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            return seq(t("export default"), body);
          default:
            return seq(t("export default"), p(node.body, _coderep.Precedence.Assignment, body), semiOp());
        }
      }
    }, {
      key: "reduceExportFromSpecifier",
      value: function reduceExportFromSpecifier(node) {
        if (node.exportedName == null) return t(node.name);
        return seq(t(node.name), t("as"), t(node.exportedName));
      }
    }, {
      key: "reduceExportLocalSpecifier",
      value: function reduceExportLocalSpecifier(node, _ref47) {
        var name = _ref47.name;

        if (node.exportedName == null) return name;
        return seq(name, t("as"), t(node.exportedName));
      }
    }, {
      key: "reduceLabeledStatement",
      value: function reduceLabeledStatement(node, _ref48) {
        var body = _ref48.body;

        return (0, _objectAssign2.default)(seq(t(node.label + ":"), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceLiteralBooleanExpression",
      value: function reduceLiteralBooleanExpression(node) {
        return t(node.value.toString());
      }
    }, {
      key: "reduceLiteralNullExpression",
      value: function reduceLiteralNullExpression(node) {
        return t("null");
      }
    }, {
      key: "reduceLiteralInfinityExpression",
      value: function reduceLiteralInfinityExpression(node) {
        return t("2e308");
      }
    }, {
      key: "reduceLiteralNumericExpression",
      value: function reduceLiteralNumericExpression(node) {
        return new _coderep.NumberCodeRep(node.value);
      }
    }, {
      key: "reduceLiteralRegExpExpression",
      value: function reduceLiteralRegExpExpression(node) {
        return t("/" + node.pattern + "/" + (node.global ? 'g' : '') + (node.ignoreCase ? 'i' : '') + (node.multiLine ? 'm' : '') + (node.unicode ? 'u' : '') + (node.sticky ? 'y' : ''));
      }
    }, {
      key: "reduceLiteralStringExpression",
      value: function reduceLiteralStringExpression(node) {
        return t((0, _coderep.escapeStringLiteral)(node.value));
      }
    }, {
      key: "reduceMethod",
      value: function reduceMethod(node, _ref49) {
        var name = _ref49.name;
        var params = _ref49.params;
        var body = _ref49.body;

        return seq(node.isGenerator ? t("*") : empty(), name, paren(params), brace(body));
      }
    }, {
      key: "reduceModule",
      value: function reduceModule(node, _ref50) {
        var directives = _ref50.directives;
        var items = _ref50.items;

        if (items.length) {
          items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(items)));
      }
    }, {
      key: "reduceNewExpression",
      value: function reduceNewExpression(node, _ref51) {
        var callee = _ref51.callee;
        var args = _ref51.arguments;

        var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? paren(callee) : p(node.callee, (0, _coderep.getPrecedence)(node), callee);
        return seq(t("new"), calleeRep, args.length === 0 ? empty() : paren(commaSep(args)));
      }
    }, {
      key: "reduceNewTargetExpression",
      value: function reduceNewTargetExpression() {
        return t("new.target");
      }
    }, {
      key: "reduceObjectExpression",
      value: function reduceObjectExpression(node, _ref52) {
        var properties = _ref52.properties;

        var state = brace(commaSep(properties));
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceUpdateExpression",
      value: function reduceUpdateExpression(node, _ref53) {
        var operand = _ref53.operand;

        if (node.isPrefix) {
          return this.reduceUnaryExpression.apply(this, arguments);
        } else {
          return (0, _objectAssign2.default)(seq(p(node.operand, _coderep.Precedence.New, operand), t(node.operator)), {
            startsWithCurly: operand.startsWithCurly,
            startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
            startsWithFunctionOrClass: operand.startsWithFunctionOrClass
          });
        }
      }
    }, {
      key: "reduceUnaryExpression",
      value: function reduceUnaryExpression(node, _ref54) {
        var operand = _ref54.operand;

        return seq(t(node.operator), p(node.operand, (0, _coderep.getPrecedence)(node), operand));
      }
    }, {
      key: "reduceReturnStatement",
      value: function reduceReturnStatement(node, _ref55) {
        var expression = _ref55.expression;

        return seq(t("return"), expression || empty(), semiOp());
      }
    }, {
      key: "reduceScript",
      value: function reduceScript(node, _ref56) {
        var directives = _ref56.directives;
        var statements = _ref56.statements;

        if (statements.length) {
          statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat(_toConsumableArray(statements)));
      }
    }, {
      key: "reduceSetter",
      value: function reduceSetter(node, _ref57) {
        var name = _ref57.name;
        var param = _ref57.param;
        var body = _ref57.body;

        return seq(t("set"), name, paren(param), brace(body));
      }
    }, {
      key: "reduceShorthandProperty",
      value: function reduceShorthandProperty(node, _ref58) {
        var name = _ref58.name;

        return name;
      }
    }, {
      key: "reduceStaticMemberAssignmentTarget",
      value: function reduceStaticMemberAssignmentTarget(node, _ref59) {
        var object = _ref59.object;

        var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(node.property));
        state.startsWithLet = object.startsWithLet;
        state.startsWithCurly = object.startsWithCurly;
        state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
        state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
        return state;
      }
    }, {
      key: "reduceStaticMemberExpression",
      value: function reduceStaticMemberExpression(node, _ref60) {
        var object = _ref60.object;

        var state = seq(p(node.object, (0, _coderep.getPrecedence)(node), object), t("."), t(node.property));
        state.startsWithLet = object.startsWithLet;
        state.startsWithCurly = object.startsWithCurly;
        state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
        state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
        return state;
      }
    }, {
      key: "reduceStaticPropertyName",
      value: function reduceStaticPropertyName(node) {
        if (_esutils.keyword.isIdentifierNameES6(node.value)) {
          return t(node.value);
        }
        var n = parseFloat(node.value);
        if (n >= 0 && n.toString() === node.value) {
          return new _coderep.NumberCodeRep(n);
        }
        return t((0, _coderep.escapeStringLiteral)(node.value));
      }
    }, {
      key: "reduceSuper",
      value: function reduceSuper() {
        return t("super");
      }
    }, {
      key: "reduceSwitchCase",
      value: function reduceSwitchCase(node, _ref61) {
        var test = _ref61.test;
        var consequent = _ref61.consequent;

        return seq(t("case"), test, t(":"), seq.apply(undefined, _toConsumableArray(consequent)));
      }
    }, {
      key: "reduceSwitchDefault",
      value: function reduceSwitchDefault(node, _ref62) {
        var consequent = _ref62.consequent;

        return seq(t("default:"), seq.apply(undefined, _toConsumableArray(consequent)));
      }
    }, {
      key: "reduceSwitchStatement",
      value: function reduceSwitchStatement(node, _ref63) {
        var discriminant = _ref63.discriminant;
        var cases = _ref63.cases;

        return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(cases))));
      }
    }, {
      key: "reduceSwitchStatementWithDefault",
      value: function reduceSwitchStatementWithDefault(node, _ref64) {
        var discriminant = _ref64.discriminant;
        var preDefaultCases = _ref64.preDefaultCases;
        var defaultCase = _ref64.defaultCase;
        var postDefaultCases = _ref64.postDefaultCases;

        return seq(t("switch"), paren(discriminant), brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases)))));
      }
    }, {
      key: "reduceTemplateExpression",
      value: function reduceTemplateExpression(node, _ref65) {
        var tag = _ref65.tag;
        var elements = _ref65.elements;

        var state = node.tag == null ? empty() : p(node.tag, (0, _coderep.getPrecedence)(node), tag);
        var templateData = "";
        state = seq(state, t("`"));
        for (var i = 0, l = node.elements.length; i < l; ++i) {
          if (node.elements[i].type === "TemplateElement") {
            var d = "";
            if (i > 0) d += "}";
            d += node.elements[i].rawValue;
            if (i < l - 1) d += "${";
            state = seq(state, t(d));
          } else {
            state = seq(state, elements[i]);
          }
        }
        state = seq(state, t("`"));
        if (node.tag != null) {
          state.startsWithCurly = tag.startsWithCurly;
          state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
          state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
        }
        return state;
      }
    }, {
      key: "reduceTemplateElement",
      value: function reduceTemplateElement(node) {
        return t(node.rawValue);
      }
    }, {
      key: "reduceThisExpression",
      value: function reduceThisExpression(node) {
        return t("this");
      }
    }, {
      key: "reduceThrowStatement",
      value: function reduceThrowStatement(node, _ref66) {
        var expression = _ref66.expression;

        return seq(t("throw"), expression, semiOp());
      }
    }, {
      key: "reduceTryCatchStatement",
      value: function reduceTryCatchStatement(node, _ref67) {
        var body = _ref67.body;
        var catchClause = _ref67.catchClause;

        return seq(t("try"), body, catchClause);
      }
    }, {
      key: "reduceTryFinallyStatement",
      value: function reduceTryFinallyStatement(node, _ref68) {
        var body = _ref68.body;
        var catchClause = _ref68.catchClause;
        var finalizer = _ref68.finalizer;

        return seq(t("try"), body, catchClause || empty(), t("finally"), finalizer);
      }
    }, {
      key: "reduceYieldExpression",
      value: function reduceYieldExpression(node, _ref69) {
        var expression = _ref69.expression;

        if (node.expression == null) return t("yield");
        return seq(t("yield"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
      }
    }, {
      key: "reduceYieldGeneratorExpression",
      value: function reduceYieldGeneratorExpression(node, _ref70) {
        var expression = _ref70.expression;

        return seq(t("yield"), t("*"), p(node.expression, (0, _coderep.getPrecedence)(node), expression));
      }
    }, {
      key: "reduceDirective",
      value: function reduceDirective(node) {
        var delim = node.rawValue.match(/(^|[^\\])(\\\\)*"/) ? "'" : '"';
        return seq(t(delim + node.rawValue + delim), semiOp());
      }
    }, {
      key: "reduceVariableDeclaration",
      value: function reduceVariableDeclaration(node, _ref71) {
        var declarators = _ref71.declarators;

        return seq(t(node.kind), commaSep(declarators));
      }
    }, {
      key: "reduceVariableDeclarationStatement",
      value: function reduceVariableDeclarationStatement(node, _ref72) {
        var declaration = _ref72.declaration;

        return seq(declaration, semiOp());
      }
    }, {
      key: "reduceVariableDeclarator",
      value: function reduceVariableDeclarator(node, _ref73) {
        var binding = _ref73.binding;
        var init = _ref73.init;

        var containsIn = init && init.containsIn && !init.containsGroup;
        if (init) {
          if (init.containsGroup) {
            init = paren(init);
          } else {
            init = markContainsIn(init);
          }
        }
        return (0, _objectAssign2.default)(init == null ? binding : seq(binding, t("="), init), { containsIn: containsIn });
      }
    }, {
      key: "reduceWhileStatement",
      value: function reduceWhileStatement(node, _ref74) {
        var test = _ref74.test;
        var body = _ref74.body;

        return (0, _objectAssign2.default)(seq(t("while"), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceWithStatement",
      value: function reduceWithStatement(node, _ref75) {
        var object = _ref75.object;
        var body = _ref75.body;

        return (0, _objectAssign2.default)(seq(t("with"), paren(object), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }]);

    return MinimalCodeGen;
  }();

  exports.default = MinimalCodeGen;
});
System.registerDynamic("npm:object-assign@4.1.1.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:object-assign@4.1.1/index.js', [], true, function ($__require, exports, module) {
	/*
 object-assign
 (c) Sindre Sorhus
 @license MIT
 */

	'use strict';
	/* eslint-disable no-unused-vars */

	var global = this || self,
	    GLOBAL = global;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
});
System.registerDynamic("npm:shift-codegen@5.0.2/dist/formatted-codegen.js", ["object-assign", "esutils", "./coderep"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.Sep = undefined;

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _objectAssign = $__require("object-assign");

  var _objectAssign2 = _interopRequireDefault(_objectAssign);

  var _esutils = $__require("esutils");

  var _coderep = $__require("./coderep");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function empty() {
    return new _coderep.Empty();
  }

  function noIn(rep) {
    return new _coderep.NoIn(rep);
  }

  function markContainsIn(state) {
    return state.containsIn ? new _coderep.ContainsIn(state) : state;
  }

  function seq() {
    for (var _len = arguments.length, reps = Array(_len), _key = 0; _key < _len; _key++) {
      reps[_key] = arguments[_key];
    }

    return new _coderep.Seq(reps);
  }

  function isEmpty(codeRep) {
    return codeRep instanceof _coderep.Empty || codeRep instanceof Linebreak || codeRep instanceof _coderep.Seq && codeRep.children.every(isEmpty);
  }

  var Sep = {};
  var separatorNames = ["ARRAY_EMPTY", "ARRAY_BEFORE_COMMA", "ARRAY_AFTER_COMMA", "SPREAD", "BEFORE_DEFAULT_EQUALS", "AFTER_DEFAULT_EQUALS", "REST", "OBJECT_BEFORE_COMMA", "OBJECT_AFTER_COMMA", "BEFORE_PROP", "AFTER_PROP", "BEFORE_JUMP_LABEL", "ARGS_BEFORE_COMMA", "ARGS_AFTER_COMMA", "CALL", "BEFORE_CATCH_BINDING", "AFTER_CATCH_BINDING", "BEFORE_CLASS_NAME", "BEFORE_EXTENDS", "AFTER_EXTENDS", "BEFORE_CLASS_DECLARATION_ELEMENTS", "BEFORE_CLASS_EXPRESSION_ELEMENTS", "AFTER_STATIC", "BEFORE_CLASS_ELEMENT", "AFTER_CLASS_ELEMENT", "BEFORE_TERNARY_QUESTION", "AFTER_TERNARY_QUESTION", "BEFORE_TERNARY_COLON", "AFTER_TERNARY_COLON", "COMPUTED_MEMBER_EXPRESSION", "COMPUTED_MEMBER_ASSIGNMENT_TARGET", "AFTER_DO", "BEFORE_DOWHILE_WHILE", "AFTER_DOWHILE_WHILE", "AFTER_FORIN_FOR", "BEFORE_FORIN_IN", "AFTER_FORIN_FOR", "BEFORE_FORIN_BODY", "AFTER_FOROF_FOR", "BEFORE_FOROF_OF", "AFTER_FOROF_FOR", "BEFORE_FOROF_BODY", "AFTER_FOR_FOR", "BEFORE_FOR_INIT", "AFTER_FOR_INIT", "EMPTY_FOR_INIT", "BEFORE_FOR_TEST", "AFTER_FOR_TEST", "EMPTY_FOR_TEST", "BEFORE_FOR_UPDATE", "AFTER_FOR_UPDATE", "EMPTY_FOR_UPDATE", "BEFORE_FOR_BODY", "BEFORE_GENERATOR_STAR", "AFTER_GENERATOR_STAR", "BEFORE_FUNCTION_PARAMS", "BEFORE_FUNCTION_DECLARATION_BODY", "BEFORE_FUNCTION_EXPRESSION_BODY", "AFTER_FUNCTION_DIRECTIVES", "BEFORE_ARROW", "AFTER_ARROW", "AFTER_GET", "BEFORE_GET_PARAMS", "BEFORE_GET_BODY", "AFTER_IF", "AFTER_IF_TEST", "BEFORE_ELSE", "AFTER_ELSE", "PARAMETER_BEFORE_COMMA", "PARAMETER_AFTER_COMMA", "NAMED_IMPORT_BEFORE_COMMA", "NAMED_IMPORT_AFTER_COMMA", "IMPORT_BEFORE_COMMA", "IMPORT_AFTER_COMMA", "BEFORE_IMPORT_BINDINGS", "BEFORE_IMPORT_MODULE", "AFTER_IMPORT_BINDINGS", "AFTER_FROM", "BEFORE_IMPORT_NAMESPACE", "BEFORE_IMPORT_STAR", "AFTER_IMPORT_STAR", "AFTER_IMPORT_AS", "AFTER_NAMESPACE_BINDING", "BEFORE_IMPORT_AS", "AFTER_IMPORT_AS", "EXPORTS_BEFORE_COMMA", "EXPORTS_AFTER_COMMA", "BEFORE_EXPORT_STAR", "AFTER_EXPORT_STAR", "BEFORE_EXPORT_BINDINGS", "AFTER_EXPORT_FROM_BINDINGS", "AFTER_EXPORT_LOCAL_BINDINGS", "AFTER_EXPORT", "EXPORT_DEFAULT", "AFTER_EXPORT_DEFAULT", "BEFORE_EXPORT_AS", "AFTER_EXPORT_AS", "BEFORE_LABEL_COLON", "AFTER_LABEL_COLON", "AFTER_METHOD_GENERATOR_STAR", "AFTER_METHOD_NAME", "BEFORE_METHOD_BODY", "AFTER_MODULE_DIRECTIVES", "AFTER_NEW", "BEFORE_NEW_ARGS", "EMPTY_NEW_CALL", "NEW_TARGET_BEFORE_DOT", "NEW_TARGET_AFTER_DOT", "RETURN", "AFTER_SET", "BEFORE_SET_PARAMS", "BEFORE_SET_BODY", "AFTER_SCRIPT_DIRECTIVES", "BEFORE_STATIC_MEMBER_DOT", "AFTER_STATIC_MEMBER_DOT", "BEFORE_STATIC_MEMBER_ASSIGNMENT_TARGET_DOT", "AFTER_STATIC_MEMBER_ASSIGNMENT_TARGET_DOT", "BEFORE_CASE_TEST", "AFTER_CASE_TEST", "BEFORE_CASE_BODY", "AFTER_CASE_BODY", "DEFAULT", "AFTER_DEFAULT_BODY", "BEFORE_SWITCH_DISCRIM", "BEFORE_SWITCH_BODY", "TEMPLATE_TAG", "BEFORE_TEMPLATE_EXPRESSION", "AFTER_TEMPLATE_EXPRESSION", "THROW", "AFTER_TRY", "BEFORE_CATCH", "BEFORE_FINALLY", "AFTER_FINALLY", "VARIABLE_DECLARATION", "YIELD", "BEFORE_YIELD_STAR", "AFTER_YIELD_STAR", "DECLARATORS_BEFORE_COMMA", "DECLARATORS_AFTER_COMMA", "BEFORE_INIT_EQUALS", "AFTER_INIT_EQUALS", "AFTER_WHILE", "BEFORE_WHILE_BODY", "AFTER_WITH", "BEFORE_WITH_BODY", "PAREN_AVOIDING_DIRECTIVE_BEFORE", "PAREN_AVOIDING_DIRECTIVE_AFTER", "PRECEDENCE_BEFORE", "PRECEDENCE_AFTER", "EXPRESSION_PAREN_BEFORE", "EXPRESSION_PAREN_AFTER", "CALL_PAREN_BEFORE", "CALL_PAREN_AFTER", "CALL_PAREN_EMPTY", "CATCH_PAREN_BEFORE", "CATCH_PAREN_AFTER", "DO_WHILE_TEST_PAREN_BEFORE", "DO_WHILE_TEST_PAREN_AFTER", "EXPRESSION_STATEMENT_PAREN_BEFORE", "EXPRESSION_STATEMENT_PAREN_AFTER", "FOR_IN_LET_PAREN_BEFORE", "FOR_IN_LET_PAREN_AFTER", "FOR_IN_PAREN_BEFORE", "FOR_IN_PAREN_AFTER", "FOR_OF_LET_PAREN_BEFORE", "FOR_OF_LET_PAREN_AFTER", "FOR_OF_PAREN_BEFORE", "FOR_OF_PAREN_AFTER", "PARAMETERS_PAREN_BEFORE", "PARAMETERS_PAREN_AFTER", "PARAMETERS_PAREN_EMPTY", "ARROW_PARAMETERS_PAREN_BEFORE", "ARROW_PARAMETERS_PAREN_AFTER", "ARROW_PARAMETERS_PAREN_EMPTY", "ARROW_BODY_PAREN_BEFORE", "ARROW_BODY_PAREN_AFTER", "GETTER_PARAMS", "IF_PAREN_BEFORE", "IF_PAREN_AFTER", "EXPORT_PAREN_BEFORE", "EXPORT_PAREN_AFTER", "NEW_CALLEE_PAREN_BEFORE", "NEW_CALLEE_PAREN_AFTER", "NEW_PAREN_BEFORE", "NEW_PAREN_AFTER", "NEW_PAREN_EMPTY", "SETTER_PARAM_BEFORE", "SETTER_PARAM_AFTER", "SWITCH_DISCRIM_PAREN_BEFORE", "SWITCH_DISCRIM_PAREN_AFTER", "WHILE_TEST_PAREN_BEFORE", "WHILE_TEST_PAREN_AFTER", "WITH_PAREN_BEFORE", "WITH_PAREN_AFTER", "OBJECT_BRACE_INITIAL", "OBJECT_BRACE_FINAL", "OBJECT_EMPTY", "BLOCK_BRACE_INITIAL", "BLOCK_BRACE_FINAL", "BLOCK_EMPTY", "CLASS_BRACE_INITIAL", "CLASS_BRACE_FINAL", "CLASS_EMPTY", "CLASS_EXPRESSION_BRACE_INITIAL", "CLASS_EXPRESSION_BRACE_FINAL", "CLASS_EXPRESSION_BRACE_EMPTY", "FUNCTION_BRACE_INITIAL", "FUNCTION_BRACE_FINAL", "FUNCTION_EMPTY", "FUNCTION_EXPRESSION_BRACE_INITIAL", "FUNCTION_EXPRESSION_BRACE_FINAL", "FUNCTION_EXPRESSION_EMPTY", "ARROW_BRACE_INITIAL", "ARROW_BRACE_FINAL", "ARROW_BRACE_EMPTY", "GET_BRACE_INTIAL", "GET_BRACE_FINAL", "GET_BRACE_EMPTY", "MISSING_ELSE_INTIIAL", "MISSING_ELSE_FINAL", "MISSING_ELSE_EMPTY", "IMPORT_BRACE_INTIAL", "IMPORT_BRACE_FINAL", "IMPORT_BRACE_EMPTY", "EXPORT_BRACE_INITIAL", "EXPORT_BRACE_FINAL", "EXPORT_BRACE_EMPTY", "METHOD_BRACE_INTIAL", "METHOD_BRACE_FINAL", "METHOD_BRACE_EMPTY", "SET_BRACE_INTIIAL", "SET_BRACE_FINAL", "SET_BRACE_EMPTY", "SWITCH_BRACE_INTIAL", "SWITCH_BRACE_FINAL", "SWITCH_BRACE_EMPTY", "ARRAY_INITIAL", "ARRAY_FINAL", "COMPUTED_MEMBER_BRACKET_INTIAL", "COMPUTED_MEMBER_BRACKET_FINAL", "COMPUTED_MEMBER_ASSIGNMENT_TARGET_BRACKET_INTIAL", "COMPUTED_MEMBER_ASSIGNMENT_TARGET_BRACKET_FINAL", "COMPUTED_PROPERTY_BRACKET_INTIAL", "COMPUTED_PROPERTY_BRACKET_FINAL"];
  for (var i = 0; i < separatorNames.length; ++i) {
    Sep[separatorNames[i]] = { type: separatorNames[i] };
  }

  Sep.BEFORE_ASSIGN_OP = function (op) {
    return {
      type: "BEFORE_ASSIGN_OP",
      op: op
    };
  };

  Sep.AFTER_ASSIGN_OP = function (op) {
    return {
      type: "AFTER_ASSIGN_OP",
      op: op
    };
  };

  Sep.BEFORE_BINOP = function (op) {
    return {
      type: "BEFORE_BINOP",
      op: op
    };
  };

  Sep.AFTER_BINOP = function (op) {
    return {
      type: "AFTER_BINOP",
      op: op
    };
  };

  Sep.BEFORE_POSTFIX = function (op) {
    return {
      type: "BEFORE_POSTFIX",
      op: op
    };
  };

  Sep.UNARY = function (op) {
    return {
      type: "UNARY",
      op: op
    };
  };

  Sep.AFTER_STATEMENT = function (node) {
    return {
      type: "AFTER_STATEMENT",
      node: node
    };
  };

  Sep.BEFORE_FUNCTION_NAME = function (node) {
    return {
      type: "BEFORE_FUNCTION_NAME",
      node: node
    };
  };
  exports.Sep = Sep;

  var ExtensibleCodeGen = exports.ExtensibleCodeGen = function () {
    function ExtensibleCodeGen() {
      _classCallCheck(this, ExtensibleCodeGen);
    }

    _createClass(ExtensibleCodeGen, [{
      key: "parenToAvoidBeingDirective",
      value: function parenToAvoidBeingDirective(element, original) {
        if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
          return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp());
        }
        return original;
      }
    }, {
      key: "t",
      value: function t(token) {
        return new _coderep.Token(token);
      }
    }, {
      key: "p",
      value: function p(node, precedence, a) {
        return (0, _coderep.getPrecedence)(node) < precedence ? this.paren(a, Sep.PRECEDENCE_BEFORE, Sep.PRECEDENCE_AFTER) : a;
      }
    }, {
      key: "getAssignmentExpr",
      value: function getAssignmentExpr(state) {
        return state ? state.containsGroup ? this.paren(state, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER) : state : empty();
      }
    }, {
      key: "paren",
      value: function paren(rep, first, last, empty) {
        if (isEmpty(rep)) {
          return new _coderep.Paren(this.sep(empty));
        }
        return new _coderep.Paren(seq(first ? this.sep(first) : new _coderep.Empty(), rep, last ? this.sep(last) : new _coderep.Empty()));
      }
    }, {
      key: "brace",
      value: function brace(rep, node, first, last, empty) {
        if (isEmpty(rep)) {
          return new _coderep.Brace(this.sep(empty));
        }
        return new _coderep.Brace(seq(this.sep(first), rep, this.sep(last)));
      }
    }, {
      key: "bracket",
      value: function bracket(rep, first, last, empty) {
        if (isEmpty(rep)) {
          return new _coderep.Bracket(this.sep(empty));
        }
        return new _coderep.Bracket(seq(this.sep(first), rep, this.sep(last)));
      }
    }, {
      key: "commaSep",
      value: function commaSep(pieces, before, after) {
        var _this = this;

        var first = true;
        pieces = pieces.map(function (p) {
          if (first) {
            first = false;
            return p;
          } else {
            return seq(_this.sep(before), _this.t(","), _this.sep(after), p);
          }
        });
        return seq.apply(undefined, _toConsumableArray(pieces));
      }
    }, {
      key: "semiOp",
      value: function semiOp() {
        return new _coderep.SemiOp();
      }
    }, {
      key: "sep",
      value: function sep(kind) {
        return new _coderep.Empty();
      }
    }, {
      key: "reduceArrayExpression",
      value: function reduceArrayExpression(node, _ref) {
        var _this2 = this;

        var elements = _ref.elements;

        if (elements.length === 0) {
          return this.bracket(empty(), null, null, Sep.ARRAY_EMPTY);
        }

        var content = this.commaSep(elements.map(function (e) {
          return _this2.getAssignmentExpr(e);
        }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
        if (elements.length > 0 && elements[elements.length - 1] == null) {
          content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
        }
        return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL);
      }
    }, {
      key: "reduceSpreadElement",
      value: function reduceSpreadElement(node, _ref2) {
        var expression = _ref2.expression;

        return seq(this.t("..."), this.sep(Sep.SPREAD), this.p(node.expression, _coderep.Precedence.Assignment, expression));
      }
    }, {
      key: "reduceAssignmentExpression",
      value: function reduceAssignmentExpression(node, _ref3) {
        var binding = _ref3.binding;
        var expression = _ref3.expression;

        var leftCode = binding;
        var rightCode = expression;
        var containsIn = expression.containsIn;
        var startsWithCurly = binding.startsWithCurly;
        var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
        if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
          rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
          containsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP("=")), this.t("="), this.sep(Sep.AFTER_ASSIGN_OP("=")), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
      }
    }, {
      key: "reduceAssignmentTargetIdentifier",
      value: function reduceAssignmentTargetIdentifier(node) {
        var a = this.t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceAssignmentTargetWithDefault",
      value: function reduceAssignmentTargetWithDefault(node, _ref4) {
        var binding = _ref4.binding;
        var init = _ref4.init;

        return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), this.p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceCompoundAssignmentExpression",
      value: function reduceCompoundAssignmentExpression(node, _ref5) {
        var binding = _ref5.binding;
        var expression = _ref5.expression;

        var leftCode = binding;
        var rightCode = expression;
        var containsIn = expression.containsIn;
        var startsWithCurly = binding.startsWithCurly;
        var startsWithLetSquareBracket = binding.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = binding.startsWithFunctionOrClass;
        if ((0, _coderep.getPrecedence)(node.expression) < (0, _coderep.getPrecedence)(node)) {
          rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
          containsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_ASSIGN_OP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_ASSIGN_OP(node.operator)), rightCode), { containsIn: containsIn, startsWithCurly: startsWithCurly, startsWithLetSquareBracket: startsWithLetSquareBracket, startsWithFunctionOrClass: startsWithFunctionOrClass });
      }
    }, {
      key: "reduceBinaryExpression",
      value: function reduceBinaryExpression(node, _ref6) {
        var left = _ref6.left;
        var right = _ref6.right;

        var leftCode = left;
        var startsWithCurly = left.startsWithCurly;
        var startsWithLetSquareBracket = left.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = left.startsWithFunctionOrClass;
        var leftContainsIn = left.containsIn;
        if ((0, _coderep.getPrecedence)(node.left) < (0, _coderep.getPrecedence)(node)) {
          leftCode = this.paren(leftCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
          startsWithCurly = false;
          startsWithLetSquareBracket = false;
          startsWithFunctionOrClass = false;
          leftContainsIn = false;
        }
        var rightCode = right;
        var rightContainsIn = right.containsIn;
        if ((0, _coderep.getPrecedence)(node.right) <= (0, _coderep.getPrecedence)(node)) {
          rightCode = this.paren(rightCode, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
          rightContainsIn = false;
        }
        return (0, _objectAssign2.default)(seq(leftCode, this.sep(Sep.BEFORE_BINOP(node.operator)), this.t(node.operator), this.sep(Sep.AFTER_BINOP(node.operator)), rightCode), {
          containsIn: leftContainsIn || rightContainsIn || node.operator === "in",
          containsGroup: node.operator == ",",
          startsWithCurly: startsWithCurly,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithFunctionOrClass: startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceBindingWithDefault",
      value: function reduceBindingWithDefault(node, _ref7) {
        var binding = _ref7.binding;
        var init = _ref7.init;

        return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), this.p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceBindingIdentifier",
      value: function reduceBindingIdentifier(node) {
        var a = this.t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceArrayAssignmentTarget",
      value: function reduceArrayAssignmentTarget(node, _ref8) {
        var _this3 = this;

        var elements = _ref8.elements;
        var rest = _ref8.rest;

        var content = void 0;
        if (elements.length === 0) {
          content = rest == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), rest);
        } else {
          elements = elements.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]);
          content = this.commaSep(elements.map(function (e) {
            return _this3.getAssignmentExpr(e);
          }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
          if (elements.length > 0 && elements[elements.length - 1] == null) {
            content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
          }
        }
        return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
      }
    }, {
      key: "reduceArrayBinding",
      value: function reduceArrayBinding(node, _ref9) {
        var _this4 = this;

        var elements = _ref9.elements;
        var rest = _ref9.rest;

        var content = void 0;
        if (elements.length === 0) {
          content = rest == null ? empty() : seq(this.t("..."), this.sep(Sep.REST), rest);
        } else {
          elements = elements.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]);
          content = this.commaSep(elements.map(function (e) {
            return _this4.getAssignmentExpr(e);
          }), Sep.ARRAY_BEFORE_COMMA, Sep.ARRAY_AFTER_COMMA);
          if (elements.length > 0 && elements[elements.length - 1] == null) {
            content = seq(content, this.sep(Sep.ARRAY_BEFORE_COMMA), this.t(","), this.sep(Sep.ARRAY_AFTER_COMMA));
          }
        }
        return this.bracket(content, Sep.ARRAY_INITIAL, Sep.ARRAY_FINAL, Sep.ARRAY_EMPTY);
      }
    }, {
      key: "reduceObjectAssignmentTarget",
      value: function reduceObjectAssignmentTarget(node, _ref10) {
        var properties = _ref10.properties;

        var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceObjectBinding",
      value: function reduceObjectBinding(node, _ref11) {
        var properties = _ref11.properties;

        var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceAssignmentTargetPropertyIdentifier",
      value: function reduceAssignmentTargetPropertyIdentifier(node, _ref12) {
        var binding = _ref12.binding;
        var init = _ref12.init;

        if (node.init == null) return binding;
        return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), this.p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceAssignmentTargetPropertyProperty",
      value: function reduceAssignmentTargetPropertyProperty(node, _ref13) {
        var name = _ref13.name;
        var binding = _ref13.binding;

        return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
      }
    }, {
      key: "reduceBindingPropertyIdentifier",
      value: function reduceBindingPropertyIdentifier(node, _ref14) {
        var binding = _ref14.binding;
        var init = _ref14.init;

        if (node.init == null) return binding;
        return seq(binding, this.sep(Sep.BEFORE_DEFAULT_EQUALS), this.t("="), this.sep(Sep.AFTER_DEFAULT_EQUALS), this.p(node.init, _coderep.Precedence.Assignment, init));
      }
    }, {
      key: "reduceBindingPropertyProperty",
      value: function reduceBindingPropertyProperty(node, _ref15) {
        var name = _ref15.name;
        var binding = _ref15.binding;

        return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), binding);
      }
    }, {
      key: "reduceBlock",
      value: function reduceBlock(node, _ref16) {
        var statements = _ref16.statements;

        return this.brace(seq.apply(undefined, _toConsumableArray(statements)), node, Sep.BLOCK_BRACE_INITIAL, Sep.BLOCK_BRACE_FINAL, Sep.BLOCK_EMPTY);
      }
    }, {
      key: "reduceBlockStatement",
      value: function reduceBlockStatement(node, _ref17) {
        var block = _ref17.block;

        return seq(block, this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceBreakStatement",
      value: function reduceBreakStatement(node) {
        return seq(this.t("break"), node.label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(node.label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceCallExpression",
      value: function reduceCallExpression(node, _ref18) {
        var callee = _ref18.callee;
        var args = _ref18.arguments;

        return (0, _objectAssign2.default)(seq(this.p(node.callee, (0, _coderep.getPrecedence)(node), callee), this.sep(Sep.CALL), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.CALL_PAREN_BEFORE, Sep.CALL_PAREN_AFTER, Sep.CALL_PAREN_EMPTY)), {
          startsWithCurly: callee.startsWithCurly,
          startsWithLetSquareBracket: callee.startsWithLetSquareBracket,
          startsWithFunctionOrClass: callee.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceCatchClause",
      value: function reduceCatchClause(node, _ref19) {
        var binding = _ref19.binding;
        var body = _ref19.body;

        return seq(this.t("catch"), this.sep(Sep.BEFORE_CATCH_BINDING), this.paren(binding, Sep.CATCH_PAREN_BEFORE, Sep.CATCH_PAREN_AFTER), this.sep(Sep.AFTER_CATCH_BINDING), body);
      }
    }, {
      key: "reduceClassDeclaration",
      value: function reduceClassDeclaration(node, _ref20) {
        var name = _ref20.name;
        var _super = _ref20.super;
        var elements = _ref20.elements;

        var state = seq(this.t("class"), node.name.name === "*default*" ? empty() : seq(this.sep(Sep.BEFORE_CLASS_NAME), name));
        if (_super != null) {
          state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), this.p(node.super, _coderep.Precedence.New, _super));
        }
        state = seq(state, this.sep(Sep.BEFORE_CLASS_DECLARATION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_BRACE_INITIAL, Sep.CLASS_BRACE_FINAL, Sep.CLASS_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
        return state;
      }
    }, {
      key: "reduceClassExpression",
      value: function reduceClassExpression(node, _ref21) {
        var name = _ref21.name;
        var _super = _ref21.super;
        var elements = _ref21.elements;

        var state = this.t("class");
        if (name != null) {
          state = seq(state, this.sep(Sep.BEFORE_CLASS_NAME), name);
        }
        if (_super != null) {
          state = seq(state, this.sep(Sep.BEFORE_EXTENDS), this.t("extends"), this.sep(Sep.AFTER_EXTENDS), this.p(node.super, _coderep.Precedence.New, _super));
        }
        state = seq(state, this.sep(Sep.BEFORE_CLASS_EXPRESSION_ELEMENTS), this.brace(seq.apply(undefined, _toConsumableArray(elements)), node, Sep.CLASS_EXPRESSION_BRACE_INITIAL, Sep.CLASS_EXPRESSION_BRACE_FINAL, Sep.CLASS_EXPRESSION_BRACE_EMPTY));
        state.startsWithFunctionOrClass = true;
        return state;
      }
    }, {
      key: "reduceClassElement",
      value: function reduceClassElement(node, _ref22) {
        var method = _ref22.method;

        method = seq(this.sep(Sep.BEFORE_CLASS_ELEMENT), method, this.sep(Sep.AFTER_CLASS_ELEMENT));
        if (!node.isStatic) return method;
        return seq(this.t("static"), this.sep(Sep.AFTER_STATIC), method);
      }
    }, {
      key: "reduceComputedMemberAssignmentTarget",
      value: function reduceComputedMemberAssignmentTarget(node, _ref23) {
        var object = _ref23.object;
        var expression = _ref23.expression;

        var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
        return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_ASSIGNMENT_TARGET), this.bracket(expression, Sep.COMPUTED_MEMBER_ASSIGNMENT_TARGET_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_ASSIGNMENT_TARGET_BRACKET_FINAL)), {
          startsWithLet: object.startsWithLet,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithCurly: object.startsWithCurly,
          startsWithFunctionOrClass: object.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceComputedMemberExpression",
      value: function reduceComputedMemberExpression(node, _ref24) {
        var object = _ref24.object;
        var expression = _ref24.expression;

        var startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === "IdentifierExpression" && node.object.name === "let";
        return (0, _objectAssign2.default)(seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.COMPUTED_MEMBER_EXPRESSION), this.bracket(expression, Sep.COMPUTED_MEMBER_BRACKET_INTIAL, Sep.COMPUTED_MEMBER_BRACKET_FINAL)), {
          startsWithLet: object.startsWithLet,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithCurly: object.startsWithCurly,
          startsWithFunctionOrClass: object.startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceComputedPropertyName",
      value: function reduceComputedPropertyName(node, _ref25) {
        var expression = _ref25.expression;

        return this.bracket(this.p(node.expression, _coderep.Precedence.Assignment, expression), Sep.COMPUTED_PROPERTY_BRACKET_INTIAL, Sep.COMPUTED_PROPERTY_BRACKET_FINAL);
      }
    }, {
      key: "reduceConditionalExpression",
      value: function reduceConditionalExpression(node, _ref26) {
        var test = _ref26.test;
        var consequent = _ref26.consequent;
        var alternate = _ref26.alternate;

        var containsIn = test.containsIn || alternate.containsIn;
        var startsWithCurly = test.startsWithCurly;
        var startsWithLetSquareBracket = test.startsWithLetSquareBracket;
        var startsWithFunctionOrClass = test.startsWithFunctionOrClass;
        return (0, _objectAssign2.default)(seq(this.p(node.test, _coderep.Precedence.LogicalOR, test), this.sep(Sep.BEFORE_TERNARY_QUESTION), this.t("?"), this.sep(Sep.AFTER_TERNARY_QUESTION), this.p(node.consequent, _coderep.Precedence.Assignment, consequent), this.sep(Sep.BEFORE_TERNARY_COLON), this.t(":"), this.sep(Sep.AFTER_TERNARY_COLON), this.p(node.alternate, _coderep.Precedence.Assignment, alternate)), {
          containsIn: containsIn,
          startsWithCurly: startsWithCurly,
          startsWithLetSquareBracket: startsWithLetSquareBracket,
          startsWithFunctionOrClass: startsWithFunctionOrClass
        });
      }
    }, {
      key: "reduceContinueStatement",
      value: function reduceContinueStatement(node) {
        return seq(this.t("continue"), node.label ? seq(this.sep(Sep.BEFORE_JUMP_LABEL), this.t(node.label)) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceDataProperty",
      value: function reduceDataProperty(node, _ref27) {
        var name = _ref27.name;
        var expression = _ref27.expression;

        return seq(name, this.sep(Sep.BEFORE_PROP), this.t(":"), this.sep(Sep.AFTER_PROP), this.getAssignmentExpr(expression));
      }
    }, {
      key: "reduceDebuggerStatement",
      value: function reduceDebuggerStatement(node) {
        return seq(this.t("debugger"), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceDoWhileStatement",
      value: function reduceDoWhileStatement(node, _ref28) {
        var body = _ref28.body;
        var test = _ref28.test;

        return seq(this.t("do"), this.sep(Sep.AFTER_DO), body, this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceEmptyStatement",
      value: function reduceEmptyStatement(node) {
        return seq(this.t(";"), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceExpressionStatement",
      value: function reduceExpressionStatement(node, _ref29) {
        var expression = _ref29.expression;

        var needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;
        return seq(needsParens ? this.paren(expression, Sep.EXPRESSION_STATEMENT_PAREN_BEFORE, Sep.EXPRESSION_STATEMENT_PAREN_AFTER) : expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceForInStatement",
      value: function reduceForInStatement(node, _ref30) {
        var left = _ref30.left;
        var right = _ref30.right;
        var body = _ref30.body;

        var leftP = left;
        switch (node.left.type) {
          case "VariableDeclaration":
            leftP = noIn(markContainsIn(left));
            break;
          case "AssignmentTargetIdentifier":
            if (node.left.name === "let") {
              leftP = this.paren(left, Sep.FOR_IN_LET_PAREN_BEFORE, Sep.FOR_IN_LET_PAREN_BEFORE);
            }
            break;
        }
        return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FORIN_FOR), this.paren(seq(leftP, this.sep(Sep.BEFORE_FORIN_IN), this.t("in"), this.sep(Sep.AFTER_FORIN_FOR), right), Sep.FOR_IN_PAREN_BEFORE, Sep.FOR_IN_PAREN_AFTER), this.sep(Sep.BEFORE_FORIN_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceForOfStatement",
      value: function reduceForOfStatement(node, _ref31) {
        var left = _ref31.left;
        var right = _ref31.right;
        var body = _ref31.body;

        left = node.left.type === "VariableDeclaration" ? noIn(markContainsIn(left)) : left;
        return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOROF_FOR), this.paren(seq(left.startsWithLet ? this.paren(left, Sep.FOR_OF_LET_PAREN_BEFORE, Sep.FOR_OF_LET_PAREN_AFTER) : left, this.sep(Sep.BEFORE_FOROF_OF), this.t("of"), this.sep(Sep.AFTER_FOROF_FOR), this.p(node.right, _coderep.Precedence.Assignment, right)), Sep.FOR_OF_PAREN_BEFORE, Sep.FOR_OF_PAREN_AFTER), this.sep(Sep.BEFORE_FOROF_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceForStatement",
      value: function reduceForStatement(node, _ref32) {
        var init = _ref32.init;
        var test = _ref32.test;
        var update = _ref32.update;
        var body = _ref32.body;

        return (0, _objectAssign2.default)(seq(this.t("for"), this.sep(Sep.AFTER_FOR_FOR), this.paren(seq(init ? seq(this.sep(Sep.BEFORE_FOR_INIT), noIn(markContainsIn(init)), this.sep(Sep.AFTER_FOR_INIT)) : this.sep(Sep.EMPTY_FOR_INIT), this.t(";"), test ? seq(this.sep(Sep.BEFORE_FOR_TEST), test, this.sep(Sep.AFTER_FOR_TEST)) : this.sep(Sep.EMPTY_FOR_TEST), this.t(";"), update ? seq(this.sep(Sep.BEFORE_FOR_UPDATE), update, this.sep(Sep.AFTER_FOR_UPDATE)) : this.sep(Sep.EMPTY_FOR_UPDATE))), this.sep(Sep.BEFORE_FOR_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), {
          endsWithMissingElse: body.endsWithMissingElse
        });
      }
    }, {
      key: "reduceFunctionBody",
      value: function reduceFunctionBody(node, _ref33) {
        var directives = _ref33.directives;
        var statements = _ref33.statements;

        if (statements.length) {
          statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_FUNCTION_DIRECTIVES) : empty()], _toConsumableArray(statements)));
      }
    }, {
      key: "reduceFunctionDeclaration",
      value: function reduceFunctionDeclaration(node, _ref34) {
        var name = _ref34.name;
        var params = _ref34.params;
        var body = _ref34.body;

        return seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), node.name.name === "*default*" ? empty() : name, this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_DECLARATION_BODY), this.brace(body, node, Sep.FUNCTION_BRACE_INITIAL, Sep.FUNCTION_BRACE_FINAL, Sep.FUNCTION_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceFunctionExpression",
      value: function reduceFunctionExpression(node, _ref35) {
        var name = _ref35.name;
        var params = _ref35.params;
        var body = _ref35.body;

        var state = seq(this.t("function"), node.isGenerator ? seq(this.sep(Sep.BEFORE_GENERATOR_STAR), this.t("*"), this.sep(Sep.AFTER_GENERATOR_STAR)) : empty(), this.sep(Sep.BEFORE_FUNCTION_NAME(node)), name ? name : empty(), this.sep(Sep.BEFORE_FUNCTION_PARAMS), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_FUNCTION_EXPRESSION_BODY), this.brace(body, node, Sep.FUNCTION_EXPRESSION_BRACE_INITIAL, Sep.FUNCTION_EXPRESSION_BRACE_FINAL, Sep.FUNCTION_EXPRESSION_EMPTY));
        state.startsWithFunctionOrClass = true;
        return state;
      }
    }, {
      key: "reduceFormalParameters",
      value: function reduceFormalParameters(node, _ref36) {
        var items = _ref36.items;
        var rest = _ref36.rest;

        return this.commaSep(items.concat(rest == null ? [] : [seq(this.t("..."), this.sep(Sep.REST), rest)]), Sep.PARAMETER_BEFORE_COMMA, Sep.PARAMETER_AFTER_COMMA);
      }
    }, {
      key: "reduceArrowExpression",
      value: function reduceArrowExpression(node, _ref37) {
        var params = _ref37.params;
        var body = _ref37.body;

        if (node.params.rest != null || node.params.items.length !== 1 || node.params.items[0].type !== "BindingIdentifier") {
          params = this.paren(params, Sep.ARROW_PARAMETERS_PAREN_BEFORE, Sep.ARROW_PARAMETERS_PAREN_AFTER, Sep.ARROW_PARAMETERS_PAREN_EMPTY);
        }
        var containsIn = false;
        if (node.body.type === "FunctionBody") {
          body = this.brace(body, node, Sep.ARROW_BRACE_INITIAL, Sep.ARROW_BRACE_FINAL, Sep.ARROW_BRACE_EMPTY);
        } else if (body.startsWithCurly) {
          body = this.paren(body, Sep.ARROW_BODY_PAREN_BEFORE, Sep.ARROW_BODY_PAREN_AFTER);
        } else if (body.containsIn) {
          containsIn = true;
        }
        return (0, _objectAssign2.default)(seq(params, this.sep(Sep.BEFORE_ARROW), this.t("=>"), this.sep(Sep.AFTER_ARROW), this.p(node.body, _coderep.Precedence.Assignment, body)), { containsIn: containsIn });
      }
    }, {
      key: "reduceGetter",
      value: function reduceGetter(node, _ref38) {
        var name = _ref38.name;
        var body = _ref38.body;

        return seq(this.t("get"), this.sep(Sep.AFTER_GET), name, this.sep(Sep.BEFORE_GET_PARAMS), this.paren(empty(), null, null, Sep.GETTER_PARAMS), this.sep(Sep.BEFORE_GET_BODY), this.brace(body, node, Sep.GET_BRACE_INTIAL, Sep.GET_BRACE_FINAL, Sep.GET_BRACE_EMPTY));
      }
    }, {
      key: "reduceIdentifierExpression",
      value: function reduceIdentifierExpression(node) {
        var a = this.t(node.name);
        if (node.name === "let") {
          a.startsWithLet = true;
        }
        return a;
      }
    }, {
      key: "reduceIfStatement",
      value: function reduceIfStatement(node, _ref39) {
        var test = _ref39.test;
        var consequent = _ref39.consequent;
        var alternate = _ref39.alternate;

        if (alternate && consequent.endsWithMissingElse) {
          consequent = this.brace(consequent, node, Sep.MISSING_ELSE_INTIIAL, Sep.MISSING_ELSE_FINAL, Sep.MISSING_ELSE_EMPTY);
        }
        return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), consequent, alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), alternate) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
      }
    }, {
      key: "reduceImport",
      value: function reduceImport(node, _ref40) {
        var defaultBinding = _ref40.defaultBinding;
        var namedImports = _ref40.namedImports;

        var bindings = [];
        if (defaultBinding != null) {
          bindings.push(defaultBinding);
        }
        if (namedImports.length > 0) {
          bindings.push(this.brace(this.commaSep(namedImports, Sep.NAMED_IMPORT_BEFORE_COMMA, Sep.NAMED_IMPORT_AFTER_COMMA), node, Sep.IMPORT_BRACE_INTIAL, Sep.IMPORT_BRACE_FINAL, Sep.IMPORT_BRACE_EMPTY));
        }
        if (bindings.length === 0) {
          return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_MODULE), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
        }
        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_BINDINGS), this.commaSep(bindings, Sep.IMPORT_BEFORE_COMMA, Sep.IMPORT_AFTER_COMMA), this.sep(Sep.AFTER_IMPORT_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceImportNamespace",
      value: function reduceImportNamespace(node, _ref41) {
        var defaultBinding = _ref41.defaultBinding;
        var namespaceBinding = _ref41.namespaceBinding;

        return seq(this.t("import"), this.sep(Sep.BEFORE_IMPORT_NAMESPACE), defaultBinding == null ? empty() : seq(defaultBinding, this.sep(Sep.IMPORT_BEFORE_COMMA), this.t(","), this.sep(Sep.IMPORT_AFTER_COMMA)), this.sep(Sep.BEFORE_IMPORT_STAR), this.t("*"), this.sep(Sep.AFTER_IMPORT_STAR), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), namespaceBinding, this.sep(Sep.AFTER_NAMESPACE_BINDING), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceImportSpecifier",
      value: function reduceImportSpecifier(node, _ref42) {
        var binding = _ref42.binding;

        if (node.name == null) return binding;
        return seq(this.t(node.name), this.sep(Sep.BEFORE_IMPORT_AS), this.t("as"), this.sep(Sep.AFTER_IMPORT_AS), binding);
      }
    }, {
      key: "reduceExportAllFrom",
      value: function reduceExportAllFrom(node) {
        return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_STAR), this.t("*"), this.sep(Sep.AFTER_EXPORT_STAR), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceExportFrom",
      value: function reduceExportFrom(node, _ref43) {
        var namedExports = _ref43.namedExports;

        return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), this.sep(Sep.AFTER_EXPORT_FROM_BINDINGS), this.t("from"), this.sep(Sep.AFTER_FROM), this.t((0, _coderep.escapeStringLiteral)(node.moduleSpecifier)), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceExportLocals",
      value: function reduceExportLocals(node, _ref44) {
        var namedExports = _ref44.namedExports;

        return seq(this.t("export"), this.sep(Sep.BEFORE_EXPORT_BINDINGS), this.brace(this.commaSep(namedExports, Sep.EXPORTS_BEFORE_COMMA, Sep.EXPORTS_AFTER_COMMA), node, Sep.EXPORT_BRACE_INITIAL, Sep.EXPORT_BRACE_FINAL, Sep.EXPORT_BRACE_EMPTY), this.sep(Sep.AFTER_EXPORT_LOCAL_BINDINGS), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceExport",
      value: function reduceExport(node, _ref45) {
        var declaration = _ref45.declaration;

        switch (node.declaration.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            break;
          default:
            declaration = seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
        }
        return seq(this.t("export"), this.sep(Sep.AFTER_EXPORT), declaration);
      }
    }, {
      key: "reduceExportDefault",
      value: function reduceExportDefault(node, _ref46) {
        var body = _ref46.body;

        body = body.startsWithFunctionOrClass ? this.paren(body, Sep.EXPORT_PAREN_BEFORE, Sep.EXPORT_PAREN_AFTER) : body;
        switch (node.body.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), body);
          default:
            return seq(this.t("export"), this.sep(Sep.EXPORT_DEFAULT), this.t("default"), this.sep(Sep.AFTER_EXPORT_DEFAULT), this.p(node.body, _coderep.Precedence.Assignment, body), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
        }
      }
    }, {
      key: "reduceExportFromSpecifier",
      value: function reduceExportFromSpecifier(node) {
        if (node.exportedName == null) return this.t(node.name);
        return seq(this.t(node.name), this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
      }
    }, {
      key: "reduceExportLocalSpecifier",
      value: function reduceExportLocalSpecifier(node, _ref47) {
        var name = _ref47.name;

        if (node.exportedName == null) return name;
        return seq(name, this.sep(Sep.BEFORE_EXPORT_AS), this.t("as"), this.sep(Sep.AFTER_EXPORT_AS), this.t(node.exportedName));
      }
    }, {
      key: "reduceLabeledStatement",
      value: function reduceLabeledStatement(node, _ref48) {
        var body = _ref48.body;

        return (0, _objectAssign2.default)(seq(this.t(node.label), this.sep(Sep.BEFORE_LABEL_COLON), this.t(":"), this.sep(Sep.AFTER_LABEL_COLON), body), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceLiteralBooleanExpression",
      value: function reduceLiteralBooleanExpression(node) {
        return this.t(node.value.toString());
      }
    }, {
      key: "reduceLiteralNullExpression",
      value: function reduceLiteralNullExpression(node) {
        return this.t("null");
      }
    }, {
      key: "reduceLiteralInfinityExpression",
      value: function reduceLiteralInfinityExpression(node) {
        return this.t("2e308");
      }
    }, {
      key: "reduceLiteralNumericExpression",
      value: function reduceLiteralNumericExpression(node) {
        return new _coderep.NumberCodeRep(node.value);
      }
    }, {
      key: "reduceLiteralRegExpExpression",
      value: function reduceLiteralRegExpExpression(node) {
        return this.t("/" + node.pattern + "/" + (node.global ? 'g' : '') + (node.ignoreCase ? 'i' : '') + (node.multiLine ? 'm' : '') + (node.unicode ? 'u' : '') + (node.sticky ? 'y' : ''));
      }
    }, {
      key: "reduceLiteralStringExpression",
      value: function reduceLiteralStringExpression(node) {
        return this.t((0, _coderep.escapeStringLiteral)(node.value));
      }
    }, {
      key: "reduceMethod",
      value: function reduceMethod(node, _ref49) {
        var name = _ref49.name;
        var params = _ref49.params;
        var body = _ref49.body;

        return seq(node.isGenerator ? seq(this.t("*"), this.sep(Sep.AFTER_METHOD_GENERATOR_STAR)) : empty(), name, this.sep(Sep.AFTER_METHOD_NAME), this.paren(params, Sep.PARAMETERS_PAREN_BEFORE, Sep.PARAMETERS_PAREN_AFTER, Sep.PARAMETERS_PAREN_EMPTY), this.sep(Sep.BEFORE_METHOD_BODY), this.brace(body, node, Sep.METHOD_BRACE_INTIAL, Sep.METHOD_BRACE_FINAL, Sep.METHOD_BRACE_EMPTY));
      }
    }, {
      key: "reduceModule",
      value: function reduceModule(node, _ref50) {
        var directives = _ref50.directives;
        var items = _ref50.items;

        if (items.length) {
          items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_MODULE_DIRECTIVES) : empty()], _toConsumableArray(items)));
      }
    }, {
      key: "reduceNewExpression",
      value: function reduceNewExpression(node, _ref51) {
        var callee = _ref51.callee;
        var args = _ref51.arguments;

        var calleeRep = (0, _coderep.getPrecedence)(node.callee) == _coderep.Precedence.Call ? this.paren(callee, Sep.NEW_CALLEE_PAREN_BEFORE, Sep.NEW_CALLEE_PAREN_AFTER) : this.p(node.callee, (0, _coderep.getPrecedence)(node), callee);
        return seq(this.t("new"), this.sep(Sep.AFTER_NEW), calleeRep, args.length === 0 ? this.sep(Sep.EMPTY_NEW_CALL) : seq(this.sep(Sep.BEFORE_NEW_ARGS), this.paren(this.commaSep(args, Sep.ARGS_BEFORE_COMMA, Sep.ARGS_AFTER_COMMA), Sep.NEW_PAREN_BEFORE, Sep.NEW_PAREN_AFTER, Sep.NEW_PAREN_EMPTY)));
      }
    }, {
      key: "reduceNewTargetExpression",
      value: function reduceNewTargetExpression() {
        return seq(this.t("new"), this.sep(Sep.NEW_TARGET_BEFORE_DOT), this.t("."), this.sep(Sep.NEW_TARGET_AFTER_DOT), this.t("target"));
      }
    }, {
      key: "reduceObjectExpression",
      value: function reduceObjectExpression(node, _ref52) {
        var properties = _ref52.properties;

        var state = this.brace(this.commaSep(properties, Sep.OBJECT_BEFORE_COMMA, Sep.OBJECT_AFTER_COMMA), node, Sep.OBJECT_BRACE_INITIAL, Sep.OBJECT_BRACE_FINAL, Sep.OBJECT_EMPTY);
        state.startsWithCurly = true;
        return state;
      }
    }, {
      key: "reduceUpdateExpression",
      value: function reduceUpdateExpression(node, _ref53) {
        var operand = _ref53.operand;

        if (node.isPrefix) {
          return this.reduceUnaryExpression.apply(this, arguments);
        } else {
          return (0, _objectAssign2.default)(seq(this.p(node.operand, _coderep.Precedence.New, operand), this.sep(Sep.BEFORE_POSTFIX(node.operator)), this.t(node.operator)), {
            startsWithCurly: operand.startsWithCurly,
            startsWithLetSquareBracket: operand.startsWithLetSquareBracket,
            startsWithFunctionOrClass: operand.startsWithFunctionOrClass
          });
        }
      }
    }, {
      key: "reduceUnaryExpression",
      value: function reduceUnaryExpression(node, _ref54) {
        var operand = _ref54.operand;

        return seq(this.t(node.operator), this.sep(Sep.UNARY(node.operator)), this.p(node.operand, (0, _coderep.getPrecedence)(node), operand));
      }
    }, {
      key: "reduceReturnStatement",
      value: function reduceReturnStatement(node, _ref55) {
        var expression = _ref55.expression;

        return seq(this.t("return"), expression ? seq(this.sep(Sep.RETURN), expression) : empty(), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceScript",
      value: function reduceScript(node, _ref56) {
        var directives = _ref56.directives;
        var statements = _ref56.statements;

        if (statements.length) {
          statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);
        }
        return seq.apply(undefined, _toConsumableArray(directives).concat([directives.length ? this.sep(Sep.AFTER_SCRIPT_DIRECTIVES) : empty()], _toConsumableArray(statements)));
      }
    }, {
      key: "reduceSetter",
      value: function reduceSetter(node, _ref57) {
        var name = _ref57.name;
        var param = _ref57.param;
        var body = _ref57.body;

        return seq(this.t("set"), this.sep(Sep.AFTER_SET), name, this.sep(Sep.BEFORE_SET_PARAMS), this.paren(param, Sep.SETTER_PARAM_BEFORE, Sep.SETTER_PARAM_AFTER), this.sep(Sep.BEFORE_SET_BODY), this.brace(body, node, Sep.SET_BRACE_INTIIAL, Sep.SET_BRACE_FINAL, Sep.SET_BRACE_EMPTY));
      }
    }, {
      key: "reduceShorthandProperty",
      value: function reduceShorthandProperty(node, _ref58) {
        var name = _ref58.name;

        return name;
      }
    }, {
      key: "reduceStaticMemberAssignmentTarget",
      value: function reduceStaticMemberAssignmentTarget(node, _ref59) {
        var object = _ref59.object;

        var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_ASSIGNMENT_TARGET_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_ASSIGNMENT_TARGET_DOT), this.t(node.property));
        state.startsWithLet = object.startsWithLet;
        state.startsWithCurly = object.startsWithCurly;
        state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
        state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
        return state;
      }
    }, {
      key: "reduceStaticMemberExpression",
      value: function reduceStaticMemberExpression(node, _ref60) {
        var object = _ref60.object;

        var state = seq(this.p(node.object, (0, _coderep.getPrecedence)(node), object), this.sep(Sep.BEFORE_STATIC_MEMBER_DOT), this.t("."), this.sep(Sep.AFTER_STATIC_MEMBER_DOT), this.t(node.property));
        state.startsWithLet = object.startsWithLet;
        state.startsWithCurly = object.startsWithCurly;
        state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;
        state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;
        return state;
      }
    }, {
      key: "reduceStaticPropertyName",
      value: function reduceStaticPropertyName(node) {
        if (_esutils.keyword.isIdentifierNameES6(node.value)) {
          return this.t(node.value);
        }
        var n = parseFloat(node.value);
        if (n >= 0 && n.toString() === node.value) {
          return new _coderep.NumberCodeRep(n);
        }
        return this.t((0, _coderep.escapeStringLiteral)(node.value));
      }
    }, {
      key: "reduceSuper",
      value: function reduceSuper() {
        return this.t("super");
      }
    }, {
      key: "reduceSwitchCase",
      value: function reduceSwitchCase(node, _ref61) {
        var test = _ref61.test;
        var consequent = _ref61.consequent;

        return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_CASE_BODY));
      }
    }, {
      key: "reduceSwitchDefault",
      value: function reduceSwitchDefault(node, _ref62) {
        var consequent = _ref62.consequent;

        return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), this.sep(Sep.BEFORE_CASE_BODY), seq.apply(undefined, _toConsumableArray(consequent)), this.sep(Sep.AFTER_DEFAULT_BODY));
      }
    }, {
      key: "reduceSwitchStatement",
      value: function reduceSwitchStatement(node, _ref63) {
        var discriminant = _ref63.discriminant;
        var cases = _ref63.cases;

        return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(cases)), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceSwitchStatementWithDefault",
      value: function reduceSwitchStatementWithDefault(node, _ref64) {
        var discriminant = _ref64.discriminant;
        var preDefaultCases = _ref64.preDefaultCases;
        var defaultCase = _ref64.defaultCase;
        var postDefaultCases = _ref64.postDefaultCases;

        return seq(this.t("switch"), this.sep(Sep.BEFORE_SWITCH_DISCRIM), this.paren(discriminant, Sep.SWITCH_DISCRIM_PAREN_BEFORE, Sep.SWITCH_DISCRIM_PAREN_AFTER), this.sep(Sep.BEFORE_SWITCH_BODY), this.brace(seq.apply(undefined, _toConsumableArray(preDefaultCases).concat([defaultCase], _toConsumableArray(postDefaultCases))), node, Sep.SWITCH_BRACE_INTIAL, Sep.SWITCH_BRACE_FINAL, Sep.SWITCH_BRACE_EMPTY), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceTemplateExpression",
      value: function reduceTemplateExpression(node, _ref65) {
        var tag = _ref65.tag;
        var elements = _ref65.elements;

        var state = node.tag == null ? empty() : seq(this.p(node.tag, (0, _coderep.getPrecedence)(node), tag), this.sep(Sep.TEMPLATE_TAG));
        var templateData = "";
        state = seq(state, this.t("`"));
        for (var _i = 0, l = node.elements.length; _i < l; ++_i) {
          if (node.elements[_i].type === "TemplateElement") {
            var d = "";
            if (_i > 0) d += "}";
            d += node.elements[_i].rawValue;
            if (_i < l - 1) d += "${";
            state = seq(state, this.t(d));
          } else {
            state = seq(state, this.sep(Sep.BEFORE_TEMPLATE_EXPRESSION), elements[_i], this.sep(Sep.AFTER_TEMPLATE_EXPRESSION));
          }
        }
        state = seq(state, this.t("`"));
        if (node.tag != null) {
          state.startsWithCurly = tag.startsWithCurly;
          state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;
          state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;
        }
        return state;
      }
    }, {
      key: "reduceTemplateElement",
      value: function reduceTemplateElement(node) {
        return this.t(node.rawValue);
      }
    }, {
      key: "reduceThisExpression",
      value: function reduceThisExpression(node) {
        return this.t("this");
      }
    }, {
      key: "reduceThrowStatement",
      value: function reduceThrowStatement(node, _ref66) {
        var expression = _ref66.expression;

        return seq(this.t("throw"), this.sep(Sep.THROW), expression, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceTryCatchStatement",
      value: function reduceTryCatchStatement(node, _ref67) {
        var body = _ref67.body;
        var catchClause = _ref67.catchClause;

        return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, this.sep(Sep.BEFORE_CATCH), catchClause, this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceTryFinallyStatement",
      value: function reduceTryFinallyStatement(node, _ref68) {
        var body = _ref68.body;
        var catchClause = _ref68.catchClause;
        var finalizer = _ref68.finalizer;

        return seq(this.t("try"), this.sep(Sep.AFTER_TRY), body, catchClause ? seq(this.sep(Sep.BEFORE_CATCH), catchClause) : empty(), this.sep(Sep.BEFORE_FINALLY), this.t("finally"), this.sep(Sep.AFTER_FINALLY), finalizer, this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceYieldExpression",
      value: function reduceYieldExpression(node, _ref69) {
        var expression = _ref69.expression;

        if (node.expression == null) return this.t("yield");
        return seq(this.t("yield"), this.sep(Sep.YIELD), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
      }
    }, {
      key: "reduceYieldGeneratorExpression",
      value: function reduceYieldGeneratorExpression(node, _ref70) {
        var expression = _ref70.expression;

        return seq(this.t("yield"), this.sep(Sep.BEFORE_YIELD_STAR), this.t("*"), this.sep(Sep.AFTER_YIELD_STAR), this.p(node.expression, (0, _coderep.getPrecedence)(node), expression));
      }
    }, {
      key: "reduceDirective",
      value: function reduceDirective(node) {
        var delim = node.rawValue.match(/(^|[^\\])(\\\\)*"/) ? "'" : '"';
        return seq(this.t(delim + node.rawValue + delim), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceVariableDeclaration",
      value: function reduceVariableDeclaration(node, _ref71) {
        var declarators = _ref71.declarators;

        return seq(this.t(node.kind), this.sep(Sep.VARIABLE_DECLARATION), this.commaSep(declarators, Sep.DECLARATORS_BEFORE_COMMA, Sep.DECLARATORS_AFTER_COMMA));
      }
    }, {
      key: "reduceVariableDeclarationStatement",
      value: function reduceVariableDeclarationStatement(node, _ref72) {
        var declaration = _ref72.declaration;

        return seq(declaration, this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceVariableDeclarator",
      value: function reduceVariableDeclarator(node, _ref73) {
        var binding = _ref73.binding;
        var init = _ref73.init;

        var containsIn = init && init.containsIn && !init.containsGroup;
        if (init) {
          if (init.containsGroup) {
            init = this.paren(init, Sep.EXPRESSION_PAREN_BEFORE, Sep.EXPRESSION_PAREN_AFTER);
          } else {
            init = markContainsIn(init);
          }
        }
        return (0, _objectAssign2.default)(init == null ? binding : seq(binding, this.sep(Sep.BEFORE_INIT_EQUALS), this.t("="), this.sep(Sep.AFTER_INIT_EQUALS), init), { containsIn: containsIn });
      }
    }, {
      key: "reduceWhileStatement",
      value: function reduceWhileStatement(node, _ref74) {
        var test = _ref74.test;
        var body = _ref74.body;

        return (0, _objectAssign2.default)(seq(this.t("while"), this.sep(Sep.AFTER_WHILE), this.paren(test, Sep.WHILE_TEST_PAREN_BEFORE, Sep.WHILE_TEST_PAREN_AFTER), this.sep(Sep.BEFORE_WHILE_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }, {
      key: "reduceWithStatement",
      value: function reduceWithStatement(node, _ref75) {
        var object = _ref75.object;
        var body = _ref75.body;

        return (0, _objectAssign2.default)(seq(this.t("with"), this.sep(Sep.AFTER_WITH), this.paren(object, Sep.WITH_PAREN_BEFORE, Sep.WITH_PAREN_AFTER), this.sep(Sep.BEFORE_WITH_BODY), body, this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: body.endsWithMissingElse });
      }
    }]);

    return ExtensibleCodeGen;
  }();

  var INDENT = "  ";

  var Linebreak = function (_CodeRep) {
    _inherits(Linebreak, _CodeRep);

    function Linebreak() {
      _classCallCheck(this, Linebreak);

      var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Linebreak).call(this));

      _this5.indentation = 0;
      return _this5;
    }

    _createClass(Linebreak, [{
      key: "emit",
      value: function emit(ts) {
        ts.put("\n");
        for (var _i2 = 0; _i2 < this.indentation; ++_i2) {
          ts.put(INDENT);
        }
      }
    }]);

    return Linebreak;
  }(_coderep.CodeRep);

  function withoutTrailingLinebreak(state) {
    if (state && state instanceof _coderep.Seq) {
      var lastChild = state.children[state.children.length - 1];
      /* istanbul ignore next */
      while (lastChild instanceof _coderep.Empty) {
        state.children.pop();
        lastChild = state.children[state.children.length - 1];
      }
      /* istanbul ignore else */
      if (lastChild instanceof _coderep.Seq) {
        withoutTrailingLinebreak(lastChild);
      } else if (lastChild instanceof Linebreak) {
        state.children.pop();
      }
    }
    return state;
  }

  function indent(rep, includingFinal) {
    var finalLinebreak = void 0;
    function indentNode(node) {
      if (node instanceof Linebreak) {
        finalLinebreak = node;
        ++node.indentation;
      }
    }
    rep.forEach(indentNode);
    if (!includingFinal) {
      --finalLinebreak.indentation;
    }
    return rep;
  }

  var FormattedCodeGen = exports.FormattedCodeGen = function (_ExtensibleCodeGen) {
    _inherits(FormattedCodeGen, _ExtensibleCodeGen);

    function FormattedCodeGen() {
      _classCallCheck(this, FormattedCodeGen);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(FormattedCodeGen).apply(this, arguments));
    }

    _createClass(FormattedCodeGen, [{
      key: "parenToAvoidBeingDirective",
      value: function parenToAvoidBeingDirective(element, original) {
        if (element && element.type === "ExpressionStatement" && element.expression.type === "LiteralStringExpression") {
          return seq(this.paren(original.children[0], Sep.PAREN_AVOIDING_DIRECTIVE_BEFORE, Sep.PAREN_AVOIDING_DIRECTIVE_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(element)));
        }
        return original;
      }
    }, {
      key: "brace",
      value: function brace(rep, node) {
        if (isEmpty(rep)) {
          return this.t("{}");
        }

        switch (node.type) {
          case "ObjectAssignmentTarget":
          case "ObjectBinding":
          case "Import":
          case "ExportFrom":
          case "ExportLocals":
          case "ObjectExpression":
            return new _coderep.Brace(rep);
        }

        rep = seq(new Linebreak(), rep);
        indent(rep, false);
        return new _coderep.Brace(rep);
      }
    }, {
      key: "reduceDoWhileStatement",
      value: function reduceDoWhileStatement(node, _ref76) {
        var body = _ref76.body;
        var test = _ref76.test;

        return seq(this.t("do"), this.sep(Sep.AFTER_DO), withoutTrailingLinebreak(body), this.sep(Sep.BEFORE_DOWHILE_WHILE), this.t("while"), this.sep(Sep.AFTER_DOWHILE_WHILE), this.paren(test, Sep.DO_WHILE_TEST_PAREN_BEFORE, Sep.DO_WHILE_TEST_PAREN_AFTER), this.semiOp(), this.sep(Sep.AFTER_STATEMENT(node)));
      }
    }, {
      key: "reduceIfStatement",
      value: function reduceIfStatement(node, _ref77) {
        var test = _ref77.test;
        var consequent = _ref77.consequent;
        var alternate = _ref77.alternate;

        if (alternate && consequent.endsWithMissingElse) {
          consequent = this.brace(consequent, node);
        }
        return (0, _objectAssign2.default)(seq(this.t("if"), this.sep(Sep.AFTER_IF), this.paren(test, Sep.IF_PAREN_BEFORE, Sep.IF_PAREN_AFTER), this.sep(Sep.AFTER_IF_TEST), withoutTrailingLinebreak(consequent), alternate ? seq(this.sep(Sep.BEFORE_ELSE), this.t("else"), this.sep(Sep.AFTER_ELSE), withoutTrailingLinebreak(alternate)) : empty(), this.sep(Sep.AFTER_STATEMENT(node))), { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });
      }
    }, {
      key: "reduceSwitchCase",
      value: function reduceSwitchCase(node, _ref78) {
        var test = _ref78.test;
        var consequent = _ref78.consequent;

        consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
        return seq(this.t("case"), this.sep(Sep.BEFORE_CASE_TEST), test, this.sep(Sep.AFTER_CASE_TEST), this.t(":"), consequent, this.sep(Sep.AFTER_CASE_BODY));
      }
    }, {
      key: "reduceSwitchDefault",
      value: function reduceSwitchDefault(node, _ref79) {
        var consequent = _ref79.consequent;

        consequent = indent(withoutTrailingLinebreak(seq.apply(undefined, [this.sep(Sep.BEFORE_CASE_BODY)].concat(_toConsumableArray(consequent)))), true);
        return seq(this.t("default"), this.sep(Sep.DEFAULT), this.t(":"), consequent, this.sep(Sep.AFTER_DEFAULT_BODY));
      }
    }, {
      key: "sep",
      value: function sep(separator) {
        switch (separator.type) {
          case "ARRAY_AFTER_COMMA":
          case "OBJECT_AFTER_COMMA":
          case "ARGS_AFTER_COMMA":
          case "PARAMETER_AFTER_COMMA":
          case "DECLARATORS_AFTER_COMMA":
          case "NAMED_IMPORT_AFTER_COMMA":
          case "IMPORT_AFTER_COMMA":
          case "BEFORE_DEFAULT_EQUALS":
          case "AFTER_DEFAULT_EQUALS":
          case "AFTER_PROP":
          case "BEFORE_JUMP_LABEL":
          case "BEFORE_CATCH":
          case "BEFORE_CATCH_BINDING":
          case "AFTER_CATCH_BINDING":
          case "BEFORE_CLASS_NAME":
          case "BEFORE_EXTENDS":
          case "AFTER_EXTENDS":
          case "BEFORE_CLASS_DECLARATION_ELEMENTS":
          case "BEFORE_CLASS_EXPRESSION_ELEMENTS":
          case "AFTER_STATIC":
          case "BEFORE_TERNARY_QUESTION":
          case "AFTER_TERNARY_QUESTION":
          case "BEFORE_TERNARY_COLON":
          case "AFTER_TERNARY_COLON":
          case "AFTER_DO":
          case "BEFORE_DOWHILE_WHILE":
          case "AFTER_DOWHILE_WHILE":
          case "AFTER_FORIN_FOR":
          case "BEFORE_FORIN_IN":
          case "AFTER_FORIN_FOR":
          case "BEFORE_FORIN_BODY":
          case "AFTER_FOROF_FOR":
          case "BEFORE_FOROF_OF":
          case "AFTER_FOROF_FOR":
          case "BEFORE_FOROF_BODY":
          case "AFTER_FOR_FOR":
          case "BEFORE_FOR_TEST":
          case "BEFORE_FOR_UPDATE":
          case "BEFORE_FOR_BODY":
          case "BEFORE_FUNCTION_DECLARATION_BODY":
          case "BEFORE_FUNCTION_EXPRESSION_BODY":
          case "BEFORE_ARROW":
          case "AFTER_ARROW":
          case "AFTER_GET":
          case "BEFORE_GET_BODY":
          case "AFTER_IF":
          case "AFTER_IF_TEST":
          case "BEFORE_ELSE":
          case "AFTER_ELSE":
          case "BEFORE_IMPORT_BINDINGS":
          case "BEFORE_IMPORT_MODULE":
          case "AFTER_IMPORT_BINDINGS":
          case "AFTER_FROM":
          case "BEFORE_IMPORT_NAMESPACE":
          case "BEFORE_IMPORT_STAR":
          case "AFTER_IMPORT_STAR":
          case "AFTER_IMPORT_AS":
          case "AFTER_NAMESPACE_BINDING":
          case "BEFORE_IMPORT_AS":
          case "AFTER_IMPORT_AS":
          case "EXPORTS_AFTER_COMMA":
          case "BEFORE_EXPORT_STAR":
          case "AFTER_EXPORT_STAR":
          case "BEFORE_EXPORT_BINDINGS":
          case "AFTER_EXPORT_FROM_BINDINGS":
          case "AFTER_EXPORT":
          case "AFTER_EXPORT_DEFAULT":
          case "BEFORE_EXPORT_AS":
          case "AFTER_EXPORT_AS":
          case "AFTER_LABEL_COLON":
          case "BEFORE_METHOD_BODY":
          case "AFTER_NEW":
          case "RETURN":
          case "AFTER_SET":
          case "BEFORE_SET_BODY":
          case "BEFORE_SET_PARAMS":
          case "BEFORE_CASE_TEST":
          case "BEFORE_SWITCH_DISCRIM":
          case "BEFORE_SWITCH_BODY":
          case "THROW":
          case "AFTER_TRY":
          case "BEFORE_CATCH":
          case "BEFORE_FINALLY":
          case "AFTER_FINALLY":
          case "VARIABLE_DECLARATION":
          case "YIELD":
          case "AFTER_YIELD_STAR":
          case "DECLARATORS_AFTER_COMMA":
          case "BEFORE_INIT_EQUALS":
          case "AFTER_INIT_EQUALS":
          case "AFTER_WHILE":
          case "BEFORE_WHILE_BODY":
          case "AFTER_WITH":
          case "BEFORE_WITH_BODY":
          case "BEFORE_FUNCTION_NAME":
          case "AFTER_BINOP":
          case "BEFORE_ASSIGN_OP":
          case "AFTER_ASSIGN_OP":
            return this.t(" ");
          case "AFTER_STATEMENT":
            switch (separator.node.type) {
              case "ForInStatement":
              case "ForOfStatement":
              case "ForStatement":
              case "WhileStatement":
              case "WithStatement":
                return empty(); // because those already end with an AFTER_STATEMENT
              default:
                return new Linebreak();
            }
          case "AFTER_CLASS_ELEMENT":
          case "BEFORE_CASE_BODY":
          case "AFTER_CASE_BODY":
          case "AFTER_DEFAULT_BODY":
            return new Linebreak();
          case "BEFORE_BINOP":
            return separator.op === "," ? empty() : this.t(" ");
          case "UNARY":
            return separator.op === "delete" || separator.op === "void" || separator.op === "typeof" ? this.t(" ") : empty();
          default:
            return empty();
        }
      }
    }]);

    return FormattedCodeGen;
  }(ExtensibleCodeGen);
});
System.registerDynamic("npm:shift-codegen@5.0.2/dist/coderep.js", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  exports.getPrecedence = getPrecedence;
  exports.escapeStringLiteral = escapeStringLiteral;

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var Precedence = {
    Sequence: 0,
    Yield: 1,
    Assignment: 1,
    Conditional: 2,
    ArrowFunction: 2,
    LogicalOR: 3,
    LogicalAND: 4,
    BitwiseOR: 5,
    BitwiseXOR: 6,
    BitwiseAND: 7,
    Equality: 8,
    Relational: 9,
    BitwiseSHIFT: 10,
    Additive: 11,
    Multiplicative: 12,
    Exponential: 13,
    Prefix: 14,
    Postfix: 15,
    New: 16,
    Call: 17,
    TaggedTemplate: 18,
    Member: 19,
    Primary: 20
  };

  exports.Precedence = Precedence;

  var BinaryPrecedence = {
    ",": Precedence.Sequence,
    "||": Precedence.LogicalOR,
    "&&": Precedence.LogicalAND,
    "|": Precedence.BitwiseOR,
    "^": Precedence.BitwiseXOR,
    "&": Precedence.BitwiseAND,
    "==": Precedence.Equality,
    "!=": Precedence.Equality,
    "===": Precedence.Equality,
    "!==": Precedence.Equality,
    "<": Precedence.Relational,
    ">": Precedence.Relational,
    "<=": Precedence.Relational,
    ">=": Precedence.Relational,
    "in": Precedence.Relational,
    "instanceof": Precedence.Relational,
    "<<": Precedence.BitwiseSHIFT,
    ">>": Precedence.BitwiseSHIFT,
    ">>>": Precedence.BitwiseSHIFT,
    "+": Precedence.Additive,
    "-": Precedence.Additive,
    "*": Precedence.Multiplicative,
    "%": Precedence.Multiplicative,
    "/": Precedence.Multiplicative,
    "**": Precedence.Exponential
  };

  function getPrecedence(node) {
    switch (node.type) {
      case "ArrayExpression":
      case "FunctionExpression":
      case "IdentifierExpression":
      case "LiteralBooleanExpression":
      case "LiteralNullExpression":
      case "LiteralNumericExpression":
      case "LiteralInfinityExpression":
      case "LiteralRegExpExpression":
      case "LiteralStringExpression":
      case "ObjectExpression":
      case "ThisExpression":
        return Precedence.Primary;

      case "ArrowExpression":
      case "AssignmentExpression":
      case "CompoundAssignmentExpression":
      case "YieldExpression":
      case "YieldGeneratorExpression":
        return Precedence.Assignment;

      case "ConditionalExpression":
        return Precedence.Conditional;

      case "ComputedMemberExpression":
      case "StaticMemberExpression":
      case "ComputedMemberAssignmentTarget":
      case "StaticMemberAssignmentTarget":
        switch (node.object.type) {
          case "CallExpression":
          case "ComputedMemberExpression":
          case "StaticMemberExpression":
          case "TemplateExpression":
            return getPrecedence(node.object);
          default:
            return Precedence.Member;
        }

      case "TemplateExpression":
        if (node.tag == null) return Precedence.Member;
        switch (node.tag.type) {
          case "CallExpression":
          case "ComputedMemberExpression":
          case "StaticMemberExpression":
          case "TemplateExpression":
            return getPrecedence(node.tag);
          default:
            return Precedence.Member;
        }

      case "BinaryExpression":
        return BinaryPrecedence[node.operator];

      case "CallExpression":
        return Precedence.Call;
      case "NewExpression":
        return node.arguments.length === 0 ? Precedence.New : Precedence.Member;
      case "UpdateExpression":
        return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;
      case "UnaryExpression":
        return Precedence.Prefix;
    }
  }

  function escapeStringLiteral(stringValue) {
    var result = "";
    var nSingle = 0,
        nDouble = 0;
    for (var i = 0, l = stringValue.length; i < l; ++i) {
      var ch = stringValue[i];
      if (ch === "\"") {
        ++nDouble;
      } else if (ch === "'") {
        ++nSingle;
      }
    }
    var delim = nDouble > nSingle ? "'" : "\"";
    result += delim;
    for (var _i = 0; _i < stringValue.length; _i++) {
      var _ch = stringValue.charAt(_i);
      switch (_ch) {
        case delim:
          result += "\\" + delim;
          break;
        case "\n":
          result += "\\n";
          break;
        case "\r":
          result += "\\r";
          break;
        case "\\":
          result += "\\\\";
          break;
        case "\u2028":
          result += "\\u2028";
          break;
        case "\u2029":
          result += "\\u2029";
          break;
        default:
          result += _ch;
          break;
      }
    }
    result += delim;
    return result;
  }

  var CodeRep = exports.CodeRep = function () {
    function CodeRep() {
      _classCallCheck(this, CodeRep);

      this.containsIn = false;
      this.containsGroup = false;
      // restricted lookaheads: {, function, class, let, let [
      this.startsWithCurly = false;
      this.startsWithFunctionOrClass = false;
      this.startsWithLet = false;
      this.startsWithLetSquareBracket = false;
      this.endsWithMissingElse = false;
    }

    _createClass(CodeRep, [{
      key: "forEach",
      value: function forEach(f) {
        // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.
        f(this);
      }
    }]);

    return CodeRep;
  }();

  var Empty = exports.Empty = function (_CodeRep) {
    _inherits(Empty, _CodeRep);

    function Empty() {
      _classCallCheck(this, Empty);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Empty).call(this));
    }

    _createClass(Empty, [{
      key: "emit",
      value: function emit() {}
    }]);

    return Empty;
  }(CodeRep);

  var Token = exports.Token = function (_CodeRep2) {
    _inherits(Token, _CodeRep2);

    function Token(token) {
      _classCallCheck(this, Token);

      var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Token).call(this));

      _this2.token = token;
      return _this2;
    }

    _createClass(Token, [{
      key: "emit",
      value: function emit(ts) {
        ts.put(this.token);
      }
    }]);

    return Token;
  }(CodeRep);

  var NumberCodeRep = exports.NumberCodeRep = function (_CodeRep3) {
    _inherits(NumberCodeRep, _CodeRep3);

    function NumberCodeRep(number) {
      _classCallCheck(this, NumberCodeRep);

      var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(NumberCodeRep).call(this));

      _this3.number = number;
      return _this3;
    }

    _createClass(NumberCodeRep, [{
      key: "emit",
      value: function emit(ts) {
        ts.putNumber(this.number);
      }
    }]);

    return NumberCodeRep;
  }(CodeRep);

  var Paren = exports.Paren = function (_CodeRep4) {
    _inherits(Paren, _CodeRep4);

    function Paren(expr) {
      _classCallCheck(this, Paren);

      var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Paren).call(this));

      _this4.expr = expr;
      return _this4;
    }

    _createClass(Paren, [{
      key: "emit",
      value: function emit(ts) {
        ts.put("(");
        this.expr.emit(ts, false);
        ts.put(")");
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.expr.forEach(f);
      }
    }]);

    return Paren;
  }(CodeRep);

  var Bracket = exports.Bracket = function (_CodeRep5) {
    _inherits(Bracket, _CodeRep5);

    function Bracket(expr) {
      _classCallCheck(this, Bracket);

      var _this5 = _possibleConstructorReturn(this, Object.getPrototypeOf(Bracket).call(this));

      _this5.expr = expr;
      return _this5;
    }

    _createClass(Bracket, [{
      key: "emit",
      value: function emit(ts) {
        ts.put("[");
        this.expr.emit(ts, false);
        ts.put("]");
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.expr.forEach(f);
      }
    }]);

    return Bracket;
  }(CodeRep);

  var Brace = exports.Brace = function (_CodeRep6) {
    _inherits(Brace, _CodeRep6);

    function Brace(expr) {
      _classCallCheck(this, Brace);

      var _this6 = _possibleConstructorReturn(this, Object.getPrototypeOf(Brace).call(this));

      _this6.expr = expr;
      return _this6;
    }

    _createClass(Brace, [{
      key: "emit",
      value: function emit(ts) {
        ts.put("{");
        this.expr.emit(ts, false);
        ts.put("}");
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.expr.forEach(f);
      }
    }]);

    return Brace;
  }(CodeRep);

  var NoIn = exports.NoIn = function (_CodeRep7) {
    _inherits(NoIn, _CodeRep7);

    function NoIn(expr) {
      _classCallCheck(this, NoIn);

      var _this7 = _possibleConstructorReturn(this, Object.getPrototypeOf(NoIn).call(this));

      _this7.expr = expr;
      return _this7;
    }

    _createClass(NoIn, [{
      key: "emit",
      value: function emit(ts) {
        this.expr.emit(ts, true);
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.expr.forEach(f);
      }
    }]);

    return NoIn;
  }(CodeRep);

  var ContainsIn = exports.ContainsIn = function (_CodeRep8) {
    _inherits(ContainsIn, _CodeRep8);

    function ContainsIn(expr) {
      _classCallCheck(this, ContainsIn);

      var _this8 = _possibleConstructorReturn(this, Object.getPrototypeOf(ContainsIn).call(this));

      _this8.expr = expr;
      return _this8;
    }

    _createClass(ContainsIn, [{
      key: "emit",
      value: function emit(ts, noIn) {
        if (noIn) {
          ts.put("(");
          this.expr.emit(ts, false);
          ts.put(")");
        } else {
          this.expr.emit(ts, false);
        }
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.expr.forEach(f);
      }
    }]);

    return ContainsIn;
  }(CodeRep);

  var Seq = exports.Seq = function (_CodeRep9) {
    _inherits(Seq, _CodeRep9);

    function Seq(children) {
      _classCallCheck(this, Seq);

      var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(Seq).call(this));

      _this9.children = children;
      return _this9;
    }

    _createClass(Seq, [{
      key: "emit",
      value: function emit(ts, noIn) {
        this.children.forEach(function (cr) {
          return cr.emit(ts, noIn);
        });
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.children.forEach(function (x) {
          return x.forEach(f);
        });
      }
    }]);

    return Seq;
  }(CodeRep);

  var Semi = exports.Semi = function (_Token) {
    _inherits(Semi, _Token);

    function Semi() {
      _classCallCheck(this, Semi);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(Semi).call(this, ";"));
    }

    return Semi;
  }(Token);

  var CommaSep = exports.CommaSep = function (_CodeRep10) {
    _inherits(CommaSep, _CodeRep10);

    function CommaSep(children) {
      _classCallCheck(this, CommaSep);

      var _this11 = _possibleConstructorReturn(this, Object.getPrototypeOf(CommaSep).call(this));

      _this11.children = children;
      return _this11;
    }

    _createClass(CommaSep, [{
      key: "emit",
      value: function emit(ts, noIn) {
        var first = true;
        this.children.forEach(function (cr) {
          if (first) {
            first = false;
          } else {
            ts.put(",");
          }
          cr.emit(ts, noIn);
        });
      }
    }, {
      key: "forEach",
      value: function forEach(f) {
        f(this);
        this.children.forEach(function (x) {
          return x.forEach(f);
        });
      }
    }]);

    return CommaSep;
  }(CodeRep);

  var SemiOp = exports.SemiOp = function (_CodeRep11) {
    _inherits(SemiOp, _CodeRep11);

    function SemiOp() {
      _classCallCheck(this, SemiOp);

      return _possibleConstructorReturn(this, Object.getPrototypeOf(SemiOp).call(this));
    }

    _createClass(SemiOp, [{
      key: "emit",
      value: function emit(ts) {
        ts.putOptionalSemi();
      }
    }]);

    return SemiOp;
  }(CodeRep);
});
System.registerDynamic("npm:shift-reducer@4.0.0/dist/clone-reducer.js", ["shift-ast"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }(); /**
        * Copyright 2016 Shape Security, Inc.
        *
        * Licensed under the Apache License, Version 2.0 (the "License")
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

  var _shiftAst = $__require('shift-ast');

  var Shift = _interopRequireWildcard(_shiftAst);

  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }newObj.default = obj;return newObj;
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var CloneReducer = function () {
    function CloneReducer() {
      _classCallCheck(this, CloneReducer);
    }

    _createClass(CloneReducer, [{
      key: 'reduceArrayAssignmentTarget',
      value: function reduceArrayAssignmentTarget(node, _ref) {
        var elements = _ref.elements;
        var rest = _ref.rest;

        return new Shift.ArrayAssignmentTarget(node, { elements: elements, rest: rest });
      }
    }, {
      key: 'reduceArrayBinding',
      value: function reduceArrayBinding(node, _ref2) {
        var elements = _ref2.elements;
        var rest = _ref2.rest;

        return new Shift.ArrayBinding(node, { elements: elements, rest: rest });
      }
    }, {
      key: 'reduceArrayExpression',
      value: function reduceArrayExpression(node, _ref3) {
        var elements = _ref3.elements;

        return new Shift.ArrayExpression(node, { elements: elements });
      }
    }, {
      key: 'reduceArrowExpression',
      value: function reduceArrowExpression(node, _ref4) {
        var params = _ref4.params;
        var body = _ref4.body;

        return new Shift.ArrowExpression(node, { params: params, body: body });
      }
    }, {
      key: 'reduceAssignmentExpression',
      value: function reduceAssignmentExpression(node, _ref5) {
        var binding = _ref5.binding;
        var expression = _ref5.expression;

        return new Shift.AssignmentExpression(node, { binding: binding, expression: expression });
      }
    }, {
      key: 'reduceAssignmentTargetIdentifier',
      value: function reduceAssignmentTargetIdentifier(node) {
        return new Shift.AssignmentTargetIdentifier(node, { name: node.name });
      }
    }, {
      key: 'reduceAssignmentTargetPropertyIdentifier',
      value: function reduceAssignmentTargetPropertyIdentifier(node, _ref6) {
        var binding = _ref6.binding;
        var init = _ref6.init;

        return new Shift.AssignmentTargetPropertyIdentifier(node, { binding: binding, init: init });
      }
    }, {
      key: 'reduceAssignmentTargetPropertyProperty',
      value: function reduceAssignmentTargetPropertyProperty(node, _ref7) {
        var name = _ref7.name;
        var binding = _ref7.binding;

        return new Shift.AssignmentTargetPropertyProperty(node, { name: name, binding: binding });
      }
    }, {
      key: 'reduceAssignmentTargetWithDefault',
      value: function reduceAssignmentTargetWithDefault(node, _ref8) {
        var binding = _ref8.binding;
        var init = _ref8.init;

        return new Shift.AssignmentTargetWithDefault(node, { binding: binding, init: init });
      }
    }, {
      key: 'reduceBinaryExpression',
      value: function reduceBinaryExpression(node, _ref9) {
        var left = _ref9.left;
        var right = _ref9.right;

        return new Shift.BinaryExpression(node, { left: left, operator: node.operator, right: right });
      }
    }, {
      key: 'reduceBindingIdentifier',
      value: function reduceBindingIdentifier(node) {
        return new Shift.BindingIdentifier(node, { name: node.name });
      }
    }, {
      key: 'reduceBindingPropertyIdentifier',
      value: function reduceBindingPropertyIdentifier(node, _ref10) {
        var binding = _ref10.binding;
        var init = _ref10.init;

        return new Shift.BindingPropertyIdentifier(node, { binding: binding, init: init });
      }
    }, {
      key: 'reduceBindingPropertyProperty',
      value: function reduceBindingPropertyProperty(node, _ref11) {
        var name = _ref11.name;
        var binding = _ref11.binding;

        return new Shift.BindingPropertyProperty(node, { name: name, binding: binding });
      }
    }, {
      key: 'reduceBindingWithDefault',
      value: function reduceBindingWithDefault(node, _ref12) {
        var binding = _ref12.binding;
        var init = _ref12.init;

        return new Shift.BindingWithDefault(node, { binding: binding, init: init });
      }
    }, {
      key: 'reduceBlock',
      value: function reduceBlock(node, _ref13) {
        var statements = _ref13.statements;

        return new Shift.Block(node, { statements: statements });
      }
    }, {
      key: 'reduceBlockStatement',
      value: function reduceBlockStatement(node, _ref14) {
        var block = _ref14.block;

        return new Shift.BlockStatement(node, { block: block });
      }
    }, {
      key: 'reduceBreakStatement',
      value: function reduceBreakStatement(node) {
        return new Shift.BreakStatement(node, { label: node.label });
      }
    }, {
      key: 'reduceCallExpression',
      value: function reduceCallExpression(node, _ref15) {
        var callee = _ref15.callee;
        var _arguments = _ref15.arguments;

        return new Shift.CallExpression(node, { callee: callee, arguments: _arguments });
      }
    }, {
      key: 'reduceCatchClause',
      value: function reduceCatchClause(node, _ref16) {
        var binding = _ref16.binding;
        var body = _ref16.body;

        return new Shift.CatchClause(node, { binding: binding, body: body });
      }
    }, {
      key: 'reduceClassDeclaration',
      value: function reduceClassDeclaration(node, _ref17) {
        var name = _ref17.name;
        var _super = _ref17.super;
        var elements = _ref17.elements;

        return new Shift.ClassDeclaration(node, { name: name, super: _super, elements: elements });
      }
    }, {
      key: 'reduceClassElement',
      value: function reduceClassElement(node, _ref18) {
        var method = _ref18.method;

        return new Shift.ClassElement(node, { isStatic: node.isStatic, method: method });
      }
    }, {
      key: 'reduceClassExpression',
      value: function reduceClassExpression(node, _ref19) {
        var name = _ref19.name;
        var _super = _ref19.super;
        var elements = _ref19.elements;

        return new Shift.ClassExpression(node, { name: name, super: _super, elements: elements });
      }
    }, {
      key: 'reduceCompoundAssignmentExpression',
      value: function reduceCompoundAssignmentExpression(node, _ref20) {
        var binding = _ref20.binding;
        var expression = _ref20.expression;

        return new Shift.CompoundAssignmentExpression(node, { binding: binding, operator: node.operator, expression: expression });
      }
    }, {
      key: 'reduceComputedMemberAssignmentTarget',
      value: function reduceComputedMemberAssignmentTarget(node, _ref21) {
        var object = _ref21.object;
        var expression = _ref21.expression;

        return new Shift.ComputedMemberAssignmentTarget(node, { object: object, expression: expression });
      }
    }, {
      key: 'reduceComputedMemberExpression',
      value: function reduceComputedMemberExpression(node, _ref22) {
        var object = _ref22.object;
        var expression = _ref22.expression;

        return new Shift.ComputedMemberExpression(node, { object: object, expression: expression });
      }
    }, {
      key: 'reduceComputedPropertyName',
      value: function reduceComputedPropertyName(node, _ref23) {
        var expression = _ref23.expression;

        return new Shift.ComputedPropertyName(node, { expression: expression });
      }
    }, {
      key: 'reduceConditionalExpression',
      value: function reduceConditionalExpression(node, _ref24) {
        var test = _ref24.test;
        var consequent = _ref24.consequent;
        var alternate = _ref24.alternate;

        return new Shift.ConditionalExpression(node, { test: test, consequent: consequent, alternate: alternate });
      }
    }, {
      key: 'reduceContinueStatement',
      value: function reduceContinueStatement(node) {
        return new Shift.ContinueStatement(node, { label: node.label });
      }
    }, {
      key: 'reduceDataProperty',
      value: function reduceDataProperty(node, _ref25) {
        var name = _ref25.name;
        var expression = _ref25.expression;

        return new Shift.DataProperty(node, { name: name, expression: expression });
      }
    }, {
      key: 'reduceDebuggerStatement',
      value: function reduceDebuggerStatement(node) {
        return new Shift.DebuggerStatement();
      }
    }, {
      key: 'reduceDirective',
      value: function reduceDirective(node) {
        return new Shift.Directive(node, { rawValue: node.rawValue });
      }
    }, {
      key: 'reduceDoWhileStatement',
      value: function reduceDoWhileStatement(node, _ref26) {
        var body = _ref26.body;
        var test = _ref26.test;

        return new Shift.DoWhileStatement(node, { body: body, test: test });
      }
    }, {
      key: 'reduceEmptyStatement',
      value: function reduceEmptyStatement(node) {
        return new Shift.EmptyStatement();
      }
    }, {
      key: 'reduceExport',
      value: function reduceExport(node, _ref27) {
        var declaration = _ref27.declaration;

        return new Shift.Export(node, { declaration: declaration });
      }
    }, {
      key: 'reduceExportAllFrom',
      value: function reduceExportAllFrom(node) {
        return new Shift.ExportAllFrom(node, { moduleSpecifier: node.moduleSpecifier });
      }
    }, {
      key: 'reduceExportDefault',
      value: function reduceExportDefault(node, _ref28) {
        var body = _ref28.body;

        return new Shift.ExportDefault(node, { body: body });
      }
    }, {
      key: 'reduceExportFrom',
      value: function reduceExportFrom(node, _ref29) {
        var namedExports = _ref29.namedExports;

        return new Shift.ExportFrom(node, { namedExports: namedExports, moduleSpecifier: node.moduleSpecifier });
      }
    }, {
      key: 'reduceExportFromSpecifier',
      value: function reduceExportFromSpecifier(node) {
        return new Shift.ExportFromSpecifier(node, { name: node.name, exportedName: node.exportedName });
      }
    }, {
      key: 'reduceExportLocalSpecifier',
      value: function reduceExportLocalSpecifier(node, _ref30) {
        var name = _ref30.name;

        return new Shift.ExportLocalSpecifier(node, { name: name, exportedName: node.exportedName });
      }
    }, {
      key: 'reduceExportLocals',
      value: function reduceExportLocals(node, _ref31) {
        var namedExports = _ref31.namedExports;

        return new Shift.ExportLocals(node, { namedExports: namedExports });
      }
    }, {
      key: 'reduceExpressionStatement',
      value: function reduceExpressionStatement(node, _ref32) {
        var expression = _ref32.expression;

        return new Shift.ExpressionStatement(node, { expression: expression });
      }
    }, {
      key: 'reduceForInStatement',
      value: function reduceForInStatement(node, _ref33) {
        var left = _ref33.left;
        var right = _ref33.right;
        var body = _ref33.body;

        return new Shift.ForInStatement(node, { left: left, right: right, body: body });
      }
    }, {
      key: 'reduceForOfStatement',
      value: function reduceForOfStatement(node, _ref34) {
        var left = _ref34.left;
        var right = _ref34.right;
        var body = _ref34.body;

        return new Shift.ForOfStatement(node, { left: left, right: right, body: body });
      }
    }, {
      key: 'reduceForStatement',
      value: function reduceForStatement(node, _ref35) {
        var init = _ref35.init;
        var test = _ref35.test;
        var update = _ref35.update;
        var body = _ref35.body;

        return new Shift.ForStatement(node, { init: init, test: test, update: update, body: body });
      }
    }, {
      key: 'reduceFormalParameters',
      value: function reduceFormalParameters(node, _ref36) {
        var items = _ref36.items;
        var rest = _ref36.rest;

        return new Shift.FormalParameters(node, { items: items, rest: rest });
      }
    }, {
      key: 'reduceFunctionBody',
      value: function reduceFunctionBody(node, _ref37) {
        var directives = _ref37.directives;
        var statements = _ref37.statements;

        return new Shift.FunctionBody(node, { directives: directives, statements: statements });
      }
    }, {
      key: 'reduceFunctionDeclaration',
      value: function reduceFunctionDeclaration(node, _ref38) {
        var name = _ref38.name;
        var params = _ref38.params;
        var body = _ref38.body;

        return new Shift.FunctionDeclaration(node, { isGenerator: node.isGenerator, name: name, params: params, body: body });
      }
    }, {
      key: 'reduceFunctionExpression',
      value: function reduceFunctionExpression(node, _ref39) {
        var name = _ref39.name;
        var params = _ref39.params;
        var body = _ref39.body;

        return new Shift.FunctionExpression(node, { isGenerator: node.isGenerator, name: name, params: params, body: body });
      }
    }, {
      key: 'reduceGetter',
      value: function reduceGetter(node, _ref40) {
        var name = _ref40.name;
        var body = _ref40.body;

        return new Shift.Getter(node, { name: name, body: body });
      }
    }, {
      key: 'reduceIdentifierExpression',
      value: function reduceIdentifierExpression(node) {
        return new Shift.IdentifierExpression(node, { name: node.name });
      }
    }, {
      key: 'reduceIfStatement',
      value: function reduceIfStatement(node, _ref41) {
        var test = _ref41.test;
        var consequent = _ref41.consequent;
        var alternate = _ref41.alternate;

        return new Shift.IfStatement(node, { test: test, consequent: consequent, alternate: alternate });
      }
    }, {
      key: 'reduceImport',
      value: function reduceImport(node, _ref42) {
        var defaultBinding = _ref42.defaultBinding;
        var namedImports = _ref42.namedImports;

        return new Shift.Import(node, { defaultBinding: defaultBinding, namedImports: namedImports, moduleSpecifier: node.moduleSpecifier });
      }
    }, {
      key: 'reduceImportNamespace',
      value: function reduceImportNamespace(node, _ref43) {
        var defaultBinding = _ref43.defaultBinding;
        var namespaceBinding = _ref43.namespaceBinding;

        return new Shift.ImportNamespace(node, { defaultBinding: defaultBinding, namespaceBinding: namespaceBinding, moduleSpecifier: node.moduleSpecifier });
      }
    }, {
      key: 'reduceImportSpecifier',
      value: function reduceImportSpecifier(node, _ref44) {
        var binding = _ref44.binding;

        return new Shift.ImportSpecifier(node, { name: node.name, binding: binding });
      }
    }, {
      key: 'reduceLabeledStatement',
      value: function reduceLabeledStatement(node, _ref45) {
        var body = _ref45.body;

        return new Shift.LabeledStatement(node, { label: node.label, body: body });
      }
    }, {
      key: 'reduceLiteralBooleanExpression',
      value: function reduceLiteralBooleanExpression(node) {
        return new Shift.LiteralBooleanExpression(node, { value: node.value });
      }
    }, {
      key: 'reduceLiteralInfinityExpression',
      value: function reduceLiteralInfinityExpression(node) {
        return new Shift.LiteralInfinityExpression();
      }
    }, {
      key: 'reduceLiteralNullExpression',
      value: function reduceLiteralNullExpression(node) {
        return new Shift.LiteralNullExpression();
      }
    }, {
      key: 'reduceLiteralNumericExpression',
      value: function reduceLiteralNumericExpression(node) {
        return new Shift.LiteralNumericExpression(node, { value: node.value });
      }
    }, {
      key: 'reduceLiteralRegExpExpression',
      value: function reduceLiteralRegExpExpression(node) {
        return new Shift.LiteralRegExpExpression(node, { pattern: node.pattern, global: node.global, ignoreCase: node.ignoreCase, multiLine: node.multiLine, sticky: node.sticky, unicode: node.unicode });
      }
    }, {
      key: 'reduceLiteralStringExpression',
      value: function reduceLiteralStringExpression(node) {
        return new Shift.LiteralStringExpression(node, { value: node.value });
      }
    }, {
      key: 'reduceMethod',
      value: function reduceMethod(node, _ref46) {
        var name = _ref46.name;
        var params = _ref46.params;
        var body = _ref46.body;

        return new Shift.Method(node, { isGenerator: node.isGenerator, name: name, params: params, body: body });
      }
    }, {
      key: 'reduceModule',
      value: function reduceModule(node, _ref47) {
        var directives = _ref47.directives;
        var items = _ref47.items;

        return new Shift.Module(node, { directives: directives, items: items });
      }
    }, {
      key: 'reduceNewExpression',
      value: function reduceNewExpression(node, _ref48) {
        var callee = _ref48.callee;
        var _arguments = _ref48.arguments;

        return new Shift.NewExpression(node, { callee: callee, arguments: _arguments });
      }
    }, {
      key: 'reduceNewTargetExpression',
      value: function reduceNewTargetExpression(node) {
        return new Shift.NewTargetExpression();
      }
    }, {
      key: 'reduceObjectAssignmentTarget',
      value: function reduceObjectAssignmentTarget(node, _ref49) {
        var properties = _ref49.properties;

        return new Shift.ObjectAssignmentTarget(node, { properties: properties });
      }
    }, {
      key: 'reduceObjectBinding',
      value: function reduceObjectBinding(node, _ref50) {
        var properties = _ref50.properties;

        return new Shift.ObjectBinding(node, { properties: properties });
      }
    }, {
      key: 'reduceObjectExpression',
      value: function reduceObjectExpression(node, _ref51) {
        var properties = _ref51.properties;

        return new Shift.ObjectExpression(node, { properties: properties });
      }
    }, {
      key: 'reduceReturnStatement',
      value: function reduceReturnStatement(node, _ref52) {
        var expression = _ref52.expression;

        return new Shift.ReturnStatement(node, { expression: expression });
      }
    }, {
      key: 'reduceScript',
      value: function reduceScript(node, _ref53) {
        var directives = _ref53.directives;
        var statements = _ref53.statements;

        return new Shift.Script(node, { directives: directives, statements: statements });
      }
    }, {
      key: 'reduceSetter',
      value: function reduceSetter(node, _ref54) {
        var name = _ref54.name;
        var param = _ref54.param;
        var body = _ref54.body;

        return new Shift.Setter(node, { name: name, param: param, body: body });
      }
    }, {
      key: 'reduceShorthandProperty',
      value: function reduceShorthandProperty(node, _ref55) {
        var name = _ref55.name;

        return new Shift.ShorthandProperty(node, { name: name });
      }
    }, {
      key: 'reduceSpreadElement',
      value: function reduceSpreadElement(node, _ref56) {
        var expression = _ref56.expression;

        return new Shift.SpreadElement(node, { expression: expression });
      }
    }, {
      key: 'reduceStaticMemberAssignmentTarget',
      value: function reduceStaticMemberAssignmentTarget(node, _ref57) {
        var object = _ref57.object;

        return new Shift.StaticMemberAssignmentTarget(node, { object: object, property: node.property });
      }
    }, {
      key: 'reduceStaticMemberExpression',
      value: function reduceStaticMemberExpression(node, _ref58) {
        var object = _ref58.object;

        return new Shift.StaticMemberExpression(node, { object: object, property: node.property });
      }
    }, {
      key: 'reduceStaticPropertyName',
      value: function reduceStaticPropertyName(node) {
        return new Shift.StaticPropertyName(node, { value: node.value });
      }
    }, {
      key: 'reduceSuper',
      value: function reduceSuper(node) {
        return new Shift.Super();
      }
    }, {
      key: 'reduceSwitchCase',
      value: function reduceSwitchCase(node, _ref59) {
        var test = _ref59.test;
        var consequent = _ref59.consequent;

        return new Shift.SwitchCase(node, { test: test, consequent: consequent });
      }
    }, {
      key: 'reduceSwitchDefault',
      value: function reduceSwitchDefault(node, _ref60) {
        var consequent = _ref60.consequent;

        return new Shift.SwitchDefault(node, { consequent: consequent });
      }
    }, {
      key: 'reduceSwitchStatement',
      value: function reduceSwitchStatement(node, _ref61) {
        var discriminant = _ref61.discriminant;
        var cases = _ref61.cases;

        return new Shift.SwitchStatement(node, { discriminant: discriminant, cases: cases });
      }
    }, {
      key: 'reduceSwitchStatementWithDefault',
      value: function reduceSwitchStatementWithDefault(node, _ref62) {
        var discriminant = _ref62.discriminant;
        var preDefaultCases = _ref62.preDefaultCases;
        var defaultCase = _ref62.defaultCase;
        var postDefaultCases = _ref62.postDefaultCases;

        return new Shift.SwitchStatementWithDefault(node, { discriminant: discriminant, preDefaultCases: preDefaultCases, defaultCase: defaultCase, postDefaultCases: postDefaultCases });
      }
    }, {
      key: 'reduceTemplateElement',
      value: function reduceTemplateElement(node) {
        return new Shift.TemplateElement(node, { rawValue: node.rawValue });
      }
    }, {
      key: 'reduceTemplateExpression',
      value: function reduceTemplateExpression(node, _ref63) {
        var tag = _ref63.tag;
        var elements = _ref63.elements;

        return new Shift.TemplateExpression(node, { tag: tag, elements: elements });
      }
    }, {
      key: 'reduceThisExpression',
      value: function reduceThisExpression(node) {
        return new Shift.ThisExpression();
      }
    }, {
      key: 'reduceThrowStatement',
      value: function reduceThrowStatement(node, _ref64) {
        var expression = _ref64.expression;

        return new Shift.ThrowStatement(node, { expression: expression });
      }
    }, {
      key: 'reduceTryCatchStatement',
      value: function reduceTryCatchStatement(node, _ref65) {
        var body = _ref65.body;
        var catchClause = _ref65.catchClause;

        return new Shift.TryCatchStatement(node, { body: body, catchClause: catchClause });
      }
    }, {
      key: 'reduceTryFinallyStatement',
      value: function reduceTryFinallyStatement(node, _ref66) {
        var body = _ref66.body;
        var catchClause = _ref66.catchClause;
        var finalizer = _ref66.finalizer;

        return new Shift.TryFinallyStatement(node, { body: body, catchClause: catchClause, finalizer: finalizer });
      }
    }, {
      key: 'reduceUnaryExpression',
      value: function reduceUnaryExpression(node, _ref67) {
        var operand = _ref67.operand;

        return new Shift.UnaryExpression(node, { operator: node.operator, operand: operand });
      }
    }, {
      key: 'reduceUpdateExpression',
      value: function reduceUpdateExpression(node, _ref68) {
        var operand = _ref68.operand;

        return new Shift.UpdateExpression(node, { isPrefix: node.isPrefix, operator: node.operator, operand: operand });
      }
    }, {
      key: 'reduceVariableDeclaration',
      value: function reduceVariableDeclaration(node, _ref69) {
        var declarators = _ref69.declarators;

        return new Shift.VariableDeclaration(node, { kind: node.kind, declarators: declarators });
      }
    }, {
      key: 'reduceVariableDeclarationStatement',
      value: function reduceVariableDeclarationStatement(node, _ref70) {
        var declaration = _ref70.declaration;

        return new Shift.VariableDeclarationStatement(node, { declaration: declaration });
      }
    }, {
      key: 'reduceVariableDeclarator',
      value: function reduceVariableDeclarator(node, _ref71) {
        var binding = _ref71.binding;
        var init = _ref71.init;

        return new Shift.VariableDeclarator(node, { binding: binding, init: init });
      }
    }, {
      key: 'reduceWhileStatement',
      value: function reduceWhileStatement(node, _ref72) {
        var test = _ref72.test;
        var body = _ref72.body;

        return new Shift.WhileStatement(node, { test: test, body: body });
      }
    }, {
      key: 'reduceWithStatement',
      value: function reduceWithStatement(node, _ref73) {
        var object = _ref73.object;
        var body = _ref73.body;

        return new Shift.WithStatement(node, { object: object, body: body });
      }
    }, {
      key: 'reduceYieldExpression',
      value: function reduceYieldExpression(node, _ref74) {
        var expression = _ref74.expression;

        return new Shift.YieldExpression(node, { expression: expression });
      }
    }, {
      key: 'reduceYieldGeneratorExpression',
      value: function reduceYieldGeneratorExpression(node, _ref75) {
        var expression = _ref75.expression;

        return new Shift.YieldGeneratorExpression(node, { expression: expression });
      }
    }]);

    return CloneReducer;
  }();

  exports.default = CloneReducer;
});
System.registerDynamic("npm:shift-ast@4.0.0.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-ast@4.0.0/dist/index.js", [], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // Generated by src/generate.js.

  /**
   * Copyright 2016 Shape Security, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var ArrayAssignmentTarget = exports.ArrayAssignmentTarget = function ArrayAssignmentTarget(_ref) {
    var elements = _ref.elements;
    var rest = _ref.rest;

    _classCallCheck(this, ArrayAssignmentTarget);

    this.type = 'ArrayAssignmentTarget';
    this.elements = elements;
    this.rest = rest;
  };

  var ArrayBinding = exports.ArrayBinding = function ArrayBinding(_ref2) {
    var elements = _ref2.elements;
    var rest = _ref2.rest;

    _classCallCheck(this, ArrayBinding);

    this.type = 'ArrayBinding';
    this.elements = elements;
    this.rest = rest;
  };

  var ArrayExpression = exports.ArrayExpression = function ArrayExpression(_ref3) {
    var elements = _ref3.elements;

    _classCallCheck(this, ArrayExpression);

    this.type = 'ArrayExpression';
    this.elements = elements;
  };

  var ArrowExpression = exports.ArrowExpression = function ArrowExpression(_ref4) {
    var params = _ref4.params;
    var body = _ref4.body;

    _classCallCheck(this, ArrowExpression);

    this.type = 'ArrowExpression';
    this.params = params;
    this.body = body;
  };

  var AssignmentExpression = exports.AssignmentExpression = function AssignmentExpression(_ref5) {
    var binding = _ref5.binding;
    var expression = _ref5.expression;

    _classCallCheck(this, AssignmentExpression);

    this.type = 'AssignmentExpression';
    this.binding = binding;
    this.expression = expression;
  };

  var AssignmentTargetIdentifier = exports.AssignmentTargetIdentifier = function AssignmentTargetIdentifier(_ref6) {
    var name = _ref6.name;

    _classCallCheck(this, AssignmentTargetIdentifier);

    this.type = 'AssignmentTargetIdentifier';
    this.name = name;
  };

  var AssignmentTargetPropertyIdentifier = exports.AssignmentTargetPropertyIdentifier = function AssignmentTargetPropertyIdentifier(_ref7) {
    var binding = _ref7.binding;
    var init = _ref7.init;

    _classCallCheck(this, AssignmentTargetPropertyIdentifier);

    this.type = 'AssignmentTargetPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  };

  var AssignmentTargetPropertyProperty = exports.AssignmentTargetPropertyProperty = function AssignmentTargetPropertyProperty(_ref8) {
    var name = _ref8.name;
    var binding = _ref8.binding;

    _classCallCheck(this, AssignmentTargetPropertyProperty);

    this.type = 'AssignmentTargetPropertyProperty';
    this.name = name;
    this.binding = binding;
  };

  var AssignmentTargetWithDefault = exports.AssignmentTargetWithDefault = function AssignmentTargetWithDefault(_ref9) {
    var binding = _ref9.binding;
    var init = _ref9.init;

    _classCallCheck(this, AssignmentTargetWithDefault);

    this.type = 'AssignmentTargetWithDefault';
    this.binding = binding;
    this.init = init;
  };

  var BinaryExpression = exports.BinaryExpression = function BinaryExpression(_ref10) {
    var left = _ref10.left;
    var operator = _ref10.operator;
    var right = _ref10.right;

    _classCallCheck(this, BinaryExpression);

    this.type = 'BinaryExpression';
    this.left = left;
    this.operator = operator;
    this.right = right;
  };

  var BindingIdentifier = exports.BindingIdentifier = function BindingIdentifier(_ref11) {
    var name = _ref11.name;

    _classCallCheck(this, BindingIdentifier);

    this.type = 'BindingIdentifier';
    this.name = name;
  };

  var BindingPropertyIdentifier = exports.BindingPropertyIdentifier = function BindingPropertyIdentifier(_ref12) {
    var binding = _ref12.binding;
    var init = _ref12.init;

    _classCallCheck(this, BindingPropertyIdentifier);

    this.type = 'BindingPropertyIdentifier';
    this.binding = binding;
    this.init = init;
  };

  var BindingPropertyProperty = exports.BindingPropertyProperty = function BindingPropertyProperty(_ref13) {
    var name = _ref13.name;
    var binding = _ref13.binding;

    _classCallCheck(this, BindingPropertyProperty);

    this.type = 'BindingPropertyProperty';
    this.name = name;
    this.binding = binding;
  };

  var BindingWithDefault = exports.BindingWithDefault = function BindingWithDefault(_ref14) {
    var binding = _ref14.binding;
    var init = _ref14.init;

    _classCallCheck(this, BindingWithDefault);

    this.type = 'BindingWithDefault';
    this.binding = binding;
    this.init = init;
  };

  var Block = exports.Block = function Block(_ref15) {
    var statements = _ref15.statements;

    _classCallCheck(this, Block);

    this.type = 'Block';
    this.statements = statements;
  };

  var BlockStatement = exports.BlockStatement = function BlockStatement(_ref16) {
    var block = _ref16.block;

    _classCallCheck(this, BlockStatement);

    this.type = 'BlockStatement';
    this.block = block;
  };

  var BreakStatement = exports.BreakStatement = function BreakStatement(_ref17) {
    var label = _ref17.label;

    _classCallCheck(this, BreakStatement);

    this.type = 'BreakStatement';
    this.label = label;
  };

  var CallExpression = exports.CallExpression = function CallExpression(_ref18) {
    var callee = _ref18.callee;
    var _arguments = _ref18.arguments;

    _classCallCheck(this, CallExpression);

    this.type = 'CallExpression';
    this.callee = callee;
    this.arguments = _arguments;
  };

  var CatchClause = exports.CatchClause = function CatchClause(_ref19) {
    var binding = _ref19.binding;
    var body = _ref19.body;

    _classCallCheck(this, CatchClause);

    this.type = 'CatchClause';
    this.binding = binding;
    this.body = body;
  };

  var ClassDeclaration = exports.ClassDeclaration = function ClassDeclaration(_ref20) {
    var name = _ref20.name;
    var _super = _ref20.super;
    var elements = _ref20.elements;

    _classCallCheck(this, ClassDeclaration);

    this.type = 'ClassDeclaration';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  };

  var ClassElement = exports.ClassElement = function ClassElement(_ref21) {
    var isStatic = _ref21.isStatic;
    var method = _ref21.method;

    _classCallCheck(this, ClassElement);

    this.type = 'ClassElement';
    this.isStatic = isStatic;
    this.method = method;
  };

  var ClassExpression = exports.ClassExpression = function ClassExpression(_ref22) {
    var name = _ref22.name;
    var _super = _ref22.super;
    var elements = _ref22.elements;

    _classCallCheck(this, ClassExpression);

    this.type = 'ClassExpression';
    this.name = name;
    this.super = _super;
    this.elements = elements;
  };

  var CompoundAssignmentExpression = exports.CompoundAssignmentExpression = function CompoundAssignmentExpression(_ref23) {
    var binding = _ref23.binding;
    var operator = _ref23.operator;
    var expression = _ref23.expression;

    _classCallCheck(this, CompoundAssignmentExpression);

    this.type = 'CompoundAssignmentExpression';
    this.binding = binding;
    this.operator = operator;
    this.expression = expression;
  };

  var ComputedMemberAssignmentTarget = exports.ComputedMemberAssignmentTarget = function ComputedMemberAssignmentTarget(_ref24) {
    var object = _ref24.object;
    var expression = _ref24.expression;

    _classCallCheck(this, ComputedMemberAssignmentTarget);

    this.type = 'ComputedMemberAssignmentTarget';
    this.object = object;
    this.expression = expression;
  };

  var ComputedMemberExpression = exports.ComputedMemberExpression = function ComputedMemberExpression(_ref25) {
    var object = _ref25.object;
    var expression = _ref25.expression;

    _classCallCheck(this, ComputedMemberExpression);

    this.type = 'ComputedMemberExpression';
    this.object = object;
    this.expression = expression;
  };

  var ComputedPropertyName = exports.ComputedPropertyName = function ComputedPropertyName(_ref26) {
    var expression = _ref26.expression;

    _classCallCheck(this, ComputedPropertyName);

    this.type = 'ComputedPropertyName';
    this.expression = expression;
  };

  var ConditionalExpression = exports.ConditionalExpression = function ConditionalExpression(_ref27) {
    var test = _ref27.test;
    var consequent = _ref27.consequent;
    var alternate = _ref27.alternate;

    _classCallCheck(this, ConditionalExpression);

    this.type = 'ConditionalExpression';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  };

  var ContinueStatement = exports.ContinueStatement = function ContinueStatement(_ref28) {
    var label = _ref28.label;

    _classCallCheck(this, ContinueStatement);

    this.type = 'ContinueStatement';
    this.label = label;
  };

  var DataProperty = exports.DataProperty = function DataProperty(_ref29) {
    var name = _ref29.name;
    var expression = _ref29.expression;

    _classCallCheck(this, DataProperty);

    this.type = 'DataProperty';
    this.name = name;
    this.expression = expression;
  };

  var DebuggerStatement = exports.DebuggerStatement = function DebuggerStatement() {
    _classCallCheck(this, DebuggerStatement);

    this.type = 'DebuggerStatement';
  };

  var Directive = exports.Directive = function Directive(_ref30) {
    var rawValue = _ref30.rawValue;

    _classCallCheck(this, Directive);

    this.type = 'Directive';
    this.rawValue = rawValue;
  };

  var DoWhileStatement = exports.DoWhileStatement = function DoWhileStatement(_ref31) {
    var body = _ref31.body;
    var test = _ref31.test;

    _classCallCheck(this, DoWhileStatement);

    this.type = 'DoWhileStatement';
    this.body = body;
    this.test = test;
  };

  var EmptyStatement = exports.EmptyStatement = function EmptyStatement() {
    _classCallCheck(this, EmptyStatement);

    this.type = 'EmptyStatement';
  };

  var Export = exports.Export = function Export(_ref32) {
    var declaration = _ref32.declaration;

    _classCallCheck(this, Export);

    this.type = 'Export';
    this.declaration = declaration;
  };

  var ExportAllFrom = exports.ExportAllFrom = function ExportAllFrom(_ref33) {
    var moduleSpecifier = _ref33.moduleSpecifier;

    _classCallCheck(this, ExportAllFrom);

    this.type = 'ExportAllFrom';
    this.moduleSpecifier = moduleSpecifier;
  };

  var ExportDefault = exports.ExportDefault = function ExportDefault(_ref34) {
    var body = _ref34.body;

    _classCallCheck(this, ExportDefault);

    this.type = 'ExportDefault';
    this.body = body;
  };

  var ExportFrom = exports.ExportFrom = function ExportFrom(_ref35) {
    var namedExports = _ref35.namedExports;
    var moduleSpecifier = _ref35.moduleSpecifier;

    _classCallCheck(this, ExportFrom);

    this.type = 'ExportFrom';
    this.namedExports = namedExports;
    this.moduleSpecifier = moduleSpecifier;
  };

  var ExportFromSpecifier = exports.ExportFromSpecifier = function ExportFromSpecifier(_ref36) {
    var name = _ref36.name;
    var exportedName = _ref36.exportedName;

    _classCallCheck(this, ExportFromSpecifier);

    this.type = 'ExportFromSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  };

  var ExportLocalSpecifier = exports.ExportLocalSpecifier = function ExportLocalSpecifier(_ref37) {
    var name = _ref37.name;
    var exportedName = _ref37.exportedName;

    _classCallCheck(this, ExportLocalSpecifier);

    this.type = 'ExportLocalSpecifier';
    this.name = name;
    this.exportedName = exportedName;
  };

  var ExportLocals = exports.ExportLocals = function ExportLocals(_ref38) {
    var namedExports = _ref38.namedExports;

    _classCallCheck(this, ExportLocals);

    this.type = 'ExportLocals';
    this.namedExports = namedExports;
  };

  var ExpressionStatement = exports.ExpressionStatement = function ExpressionStatement(_ref39) {
    var expression = _ref39.expression;

    _classCallCheck(this, ExpressionStatement);

    this.type = 'ExpressionStatement';
    this.expression = expression;
  };

  var ForInStatement = exports.ForInStatement = function ForInStatement(_ref40) {
    var left = _ref40.left;
    var right = _ref40.right;
    var body = _ref40.body;

    _classCallCheck(this, ForInStatement);

    this.type = 'ForInStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  };

  var ForOfStatement = exports.ForOfStatement = function ForOfStatement(_ref41) {
    var left = _ref41.left;
    var right = _ref41.right;
    var body = _ref41.body;

    _classCallCheck(this, ForOfStatement);

    this.type = 'ForOfStatement';
    this.left = left;
    this.right = right;
    this.body = body;
  };

  var ForStatement = exports.ForStatement = function ForStatement(_ref42) {
    var init = _ref42.init;
    var test = _ref42.test;
    var update = _ref42.update;
    var body = _ref42.body;

    _classCallCheck(this, ForStatement);

    this.type = 'ForStatement';
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
  };

  var FormalParameters = exports.FormalParameters = function FormalParameters(_ref43) {
    var items = _ref43.items;
    var rest = _ref43.rest;

    _classCallCheck(this, FormalParameters);

    this.type = 'FormalParameters';
    this.items = items;
    this.rest = rest;
  };

  var FunctionBody = exports.FunctionBody = function FunctionBody(_ref44) {
    var directives = _ref44.directives;
    var statements = _ref44.statements;

    _classCallCheck(this, FunctionBody);

    this.type = 'FunctionBody';
    this.directives = directives;
    this.statements = statements;
  };

  var FunctionDeclaration = exports.FunctionDeclaration = function FunctionDeclaration(_ref45) {
    var isGenerator = _ref45.isGenerator;
    var name = _ref45.name;
    var params = _ref45.params;
    var body = _ref45.body;

    _classCallCheck(this, FunctionDeclaration);

    this.type = 'FunctionDeclaration';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  };

  var FunctionExpression = exports.FunctionExpression = function FunctionExpression(_ref46) {
    var isGenerator = _ref46.isGenerator;
    var name = _ref46.name;
    var params = _ref46.params;
    var body = _ref46.body;

    _classCallCheck(this, FunctionExpression);

    this.type = 'FunctionExpression';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  };

  var Getter = exports.Getter = function Getter(_ref47) {
    var name = _ref47.name;
    var body = _ref47.body;

    _classCallCheck(this, Getter);

    this.type = 'Getter';
    this.name = name;
    this.body = body;
  };

  var IdentifierExpression = exports.IdentifierExpression = function IdentifierExpression(_ref48) {
    var name = _ref48.name;

    _classCallCheck(this, IdentifierExpression);

    this.type = 'IdentifierExpression';
    this.name = name;
  };

  var IfStatement = exports.IfStatement = function IfStatement(_ref49) {
    var test = _ref49.test;
    var consequent = _ref49.consequent;
    var alternate = _ref49.alternate;

    _classCallCheck(this, IfStatement);

    this.type = 'IfStatement';
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  };

  var Import = exports.Import = function Import(_ref50) {
    var defaultBinding = _ref50.defaultBinding;
    var namedImports = _ref50.namedImports;
    var moduleSpecifier = _ref50.moduleSpecifier;

    _classCallCheck(this, Import);

    this.type = 'Import';
    this.defaultBinding = defaultBinding;
    this.namedImports = namedImports;
    this.moduleSpecifier = moduleSpecifier;
  };

  var ImportNamespace = exports.ImportNamespace = function ImportNamespace(_ref51) {
    var defaultBinding = _ref51.defaultBinding;
    var namespaceBinding = _ref51.namespaceBinding;
    var moduleSpecifier = _ref51.moduleSpecifier;

    _classCallCheck(this, ImportNamespace);

    this.type = 'ImportNamespace';
    this.defaultBinding = defaultBinding;
    this.namespaceBinding = namespaceBinding;
    this.moduleSpecifier = moduleSpecifier;
  };

  var ImportSpecifier = exports.ImportSpecifier = function ImportSpecifier(_ref52) {
    var name = _ref52.name;
    var binding = _ref52.binding;

    _classCallCheck(this, ImportSpecifier);

    this.type = 'ImportSpecifier';
    this.name = name;
    this.binding = binding;
  };

  var LabeledStatement = exports.LabeledStatement = function LabeledStatement(_ref53) {
    var label = _ref53.label;
    var body = _ref53.body;

    _classCallCheck(this, LabeledStatement);

    this.type = 'LabeledStatement';
    this.label = label;
    this.body = body;
  };

  var LiteralBooleanExpression = exports.LiteralBooleanExpression = function LiteralBooleanExpression(_ref54) {
    var value = _ref54.value;

    _classCallCheck(this, LiteralBooleanExpression);

    this.type = 'LiteralBooleanExpression';
    this.value = value;
  };

  var LiteralInfinityExpression = exports.LiteralInfinityExpression = function LiteralInfinityExpression() {
    _classCallCheck(this, LiteralInfinityExpression);

    this.type = 'LiteralInfinityExpression';
  };

  var LiteralNullExpression = exports.LiteralNullExpression = function LiteralNullExpression() {
    _classCallCheck(this, LiteralNullExpression);

    this.type = 'LiteralNullExpression';
  };

  var LiteralNumericExpression = exports.LiteralNumericExpression = function LiteralNumericExpression(_ref55) {
    var value = _ref55.value;

    _classCallCheck(this, LiteralNumericExpression);

    this.type = 'LiteralNumericExpression';
    this.value = value;
  };

  var LiteralRegExpExpression = exports.LiteralRegExpExpression = function LiteralRegExpExpression(_ref56) {
    var pattern = _ref56.pattern;
    var global = _ref56.global;
    var ignoreCase = _ref56.ignoreCase;
    var multiLine = _ref56.multiLine;
    var sticky = _ref56.sticky;
    var unicode = _ref56.unicode;

    _classCallCheck(this, LiteralRegExpExpression);

    this.type = 'LiteralRegExpExpression';
    this.pattern = pattern;
    this.global = global;
    this.ignoreCase = ignoreCase;
    this.multiLine = multiLine;
    this.sticky = sticky;
    this.unicode = unicode;
  };

  var LiteralStringExpression = exports.LiteralStringExpression = function LiteralStringExpression(_ref57) {
    var value = _ref57.value;

    _classCallCheck(this, LiteralStringExpression);

    this.type = 'LiteralStringExpression';
    this.value = value;
  };

  var Method = exports.Method = function Method(_ref58) {
    var isGenerator = _ref58.isGenerator;
    var name = _ref58.name;
    var params = _ref58.params;
    var body = _ref58.body;

    _classCallCheck(this, Method);

    this.type = 'Method';
    this.isGenerator = isGenerator;
    this.name = name;
    this.params = params;
    this.body = body;
  };

  var Module = exports.Module = function Module(_ref59) {
    var directives = _ref59.directives;
    var items = _ref59.items;

    _classCallCheck(this, Module);

    this.type = 'Module';
    this.directives = directives;
    this.items = items;
  };

  var NewExpression = exports.NewExpression = function NewExpression(_ref60) {
    var callee = _ref60.callee;
    var _arguments = _ref60.arguments;

    _classCallCheck(this, NewExpression);

    this.type = 'NewExpression';
    this.callee = callee;
    this.arguments = _arguments;
  };

  var NewTargetExpression = exports.NewTargetExpression = function NewTargetExpression() {
    _classCallCheck(this, NewTargetExpression);

    this.type = 'NewTargetExpression';
  };

  var ObjectAssignmentTarget = exports.ObjectAssignmentTarget = function ObjectAssignmentTarget(_ref61) {
    var properties = _ref61.properties;

    _classCallCheck(this, ObjectAssignmentTarget);

    this.type = 'ObjectAssignmentTarget';
    this.properties = properties;
  };

  var ObjectBinding = exports.ObjectBinding = function ObjectBinding(_ref62) {
    var properties = _ref62.properties;

    _classCallCheck(this, ObjectBinding);

    this.type = 'ObjectBinding';
    this.properties = properties;
  };

  var ObjectExpression = exports.ObjectExpression = function ObjectExpression(_ref63) {
    var properties = _ref63.properties;

    _classCallCheck(this, ObjectExpression);

    this.type = 'ObjectExpression';
    this.properties = properties;
  };

  var ReturnStatement = exports.ReturnStatement = function ReturnStatement(_ref64) {
    var expression = _ref64.expression;

    _classCallCheck(this, ReturnStatement);

    this.type = 'ReturnStatement';
    this.expression = expression;
  };

  var Script = exports.Script = function Script(_ref65) {
    var directives = _ref65.directives;
    var statements = _ref65.statements;

    _classCallCheck(this, Script);

    this.type = 'Script';
    this.directives = directives;
    this.statements = statements;
  };

  var Setter = exports.Setter = function Setter(_ref66) {
    var name = _ref66.name;
    var param = _ref66.param;
    var body = _ref66.body;

    _classCallCheck(this, Setter);

    this.type = 'Setter';
    this.name = name;
    this.param = param;
    this.body = body;
  };

  var ShorthandProperty = exports.ShorthandProperty = function ShorthandProperty(_ref67) {
    var name = _ref67.name;

    _classCallCheck(this, ShorthandProperty);

    this.type = 'ShorthandProperty';
    this.name = name;
  };

  var SpreadElement = exports.SpreadElement = function SpreadElement(_ref68) {
    var expression = _ref68.expression;

    _classCallCheck(this, SpreadElement);

    this.type = 'SpreadElement';
    this.expression = expression;
  };

  var StaticMemberAssignmentTarget = exports.StaticMemberAssignmentTarget = function StaticMemberAssignmentTarget(_ref69) {
    var object = _ref69.object;
    var property = _ref69.property;

    _classCallCheck(this, StaticMemberAssignmentTarget);

    this.type = 'StaticMemberAssignmentTarget';
    this.object = object;
    this.property = property;
  };

  var StaticMemberExpression = exports.StaticMemberExpression = function StaticMemberExpression(_ref70) {
    var object = _ref70.object;
    var property = _ref70.property;

    _classCallCheck(this, StaticMemberExpression);

    this.type = 'StaticMemberExpression';
    this.object = object;
    this.property = property;
  };

  var StaticPropertyName = exports.StaticPropertyName = function StaticPropertyName(_ref71) {
    var value = _ref71.value;

    _classCallCheck(this, StaticPropertyName);

    this.type = 'StaticPropertyName';
    this.value = value;
  };

  var Super = exports.Super = function Super() {
    _classCallCheck(this, Super);

    this.type = 'Super';
  };

  var SwitchCase = exports.SwitchCase = function SwitchCase(_ref72) {
    var test = _ref72.test;
    var consequent = _ref72.consequent;

    _classCallCheck(this, SwitchCase);

    this.type = 'SwitchCase';
    this.test = test;
    this.consequent = consequent;
  };

  var SwitchDefault = exports.SwitchDefault = function SwitchDefault(_ref73) {
    var consequent = _ref73.consequent;

    _classCallCheck(this, SwitchDefault);

    this.type = 'SwitchDefault';
    this.consequent = consequent;
  };

  var SwitchStatement = exports.SwitchStatement = function SwitchStatement(_ref74) {
    var discriminant = _ref74.discriminant;
    var cases = _ref74.cases;

    _classCallCheck(this, SwitchStatement);

    this.type = 'SwitchStatement';
    this.discriminant = discriminant;
    this.cases = cases;
  };

  var SwitchStatementWithDefault = exports.SwitchStatementWithDefault = function SwitchStatementWithDefault(_ref75) {
    var discriminant = _ref75.discriminant;
    var preDefaultCases = _ref75.preDefaultCases;
    var defaultCase = _ref75.defaultCase;
    var postDefaultCases = _ref75.postDefaultCases;

    _classCallCheck(this, SwitchStatementWithDefault);

    this.type = 'SwitchStatementWithDefault';
    this.discriminant = discriminant;
    this.preDefaultCases = preDefaultCases;
    this.defaultCase = defaultCase;
    this.postDefaultCases = postDefaultCases;
  };

  var TemplateElement = exports.TemplateElement = function TemplateElement(_ref76) {
    var rawValue = _ref76.rawValue;

    _classCallCheck(this, TemplateElement);

    this.type = 'TemplateElement';
    this.rawValue = rawValue;
  };

  var TemplateExpression = exports.TemplateExpression = function TemplateExpression(_ref77) {
    var tag = _ref77.tag;
    var elements = _ref77.elements;

    _classCallCheck(this, TemplateExpression);

    this.type = 'TemplateExpression';
    this.tag = tag;
    this.elements = elements;
  };

  var ThisExpression = exports.ThisExpression = function ThisExpression() {
    _classCallCheck(this, ThisExpression);

    this.type = 'ThisExpression';
  };

  var ThrowStatement = exports.ThrowStatement = function ThrowStatement(_ref78) {
    var expression = _ref78.expression;

    _classCallCheck(this, ThrowStatement);

    this.type = 'ThrowStatement';
    this.expression = expression;
  };

  var TryCatchStatement = exports.TryCatchStatement = function TryCatchStatement(_ref79) {
    var body = _ref79.body;
    var catchClause = _ref79.catchClause;

    _classCallCheck(this, TryCatchStatement);

    this.type = 'TryCatchStatement';
    this.body = body;
    this.catchClause = catchClause;
  };

  var TryFinallyStatement = exports.TryFinallyStatement = function TryFinallyStatement(_ref80) {
    var body = _ref80.body;
    var catchClause = _ref80.catchClause;
    var finalizer = _ref80.finalizer;

    _classCallCheck(this, TryFinallyStatement);

    this.type = 'TryFinallyStatement';
    this.body = body;
    this.catchClause = catchClause;
    this.finalizer = finalizer;
  };

  var UnaryExpression = exports.UnaryExpression = function UnaryExpression(_ref81) {
    var operator = _ref81.operator;
    var operand = _ref81.operand;

    _classCallCheck(this, UnaryExpression);

    this.type = 'UnaryExpression';
    this.operator = operator;
    this.operand = operand;
  };

  var UpdateExpression = exports.UpdateExpression = function UpdateExpression(_ref82) {
    var isPrefix = _ref82.isPrefix;
    var operator = _ref82.operator;
    var operand = _ref82.operand;

    _classCallCheck(this, UpdateExpression);

    this.type = 'UpdateExpression';
    this.isPrefix = isPrefix;
    this.operator = operator;
    this.operand = operand;
  };

  var VariableDeclaration = exports.VariableDeclaration = function VariableDeclaration(_ref83) {
    var kind = _ref83.kind;
    var declarators = _ref83.declarators;

    _classCallCheck(this, VariableDeclaration);

    this.type = 'VariableDeclaration';
    this.kind = kind;
    this.declarators = declarators;
  };

  var VariableDeclarationStatement = exports.VariableDeclarationStatement = function VariableDeclarationStatement(_ref84) {
    var declaration = _ref84.declaration;

    _classCallCheck(this, VariableDeclarationStatement);

    this.type = 'VariableDeclarationStatement';
    this.declaration = declaration;
  };

  var VariableDeclarator = exports.VariableDeclarator = function VariableDeclarator(_ref85) {
    var binding = _ref85.binding;
    var init = _ref85.init;

    _classCallCheck(this, VariableDeclarator);

    this.type = 'VariableDeclarator';
    this.binding = binding;
    this.init = init;
  };

  var WhileStatement = exports.WhileStatement = function WhileStatement(_ref86) {
    var test = _ref86.test;
    var body = _ref86.body;

    _classCallCheck(this, WhileStatement);

    this.type = 'WhileStatement';
    this.test = test;
    this.body = body;
  };

  var WithStatement = exports.WithStatement = function WithStatement(_ref87) {
    var object = _ref87.object;
    var body = _ref87.body;

    _classCallCheck(this, WithStatement);

    this.type = 'WithStatement';
    this.object = object;
    this.body = body;
  };

  var YieldExpression = exports.YieldExpression = function YieldExpression(_ref88) {
    var expression = _ref88.expression;

    _classCallCheck(this, YieldExpression);

    this.type = 'YieldExpression';
    this.expression = expression;
  };

  var YieldGeneratorExpression = exports.YieldGeneratorExpression = function YieldGeneratorExpression(_ref89) {
    var expression = _ref89.expression;

    _classCallCheck(this, YieldGeneratorExpression);

    this.type = 'YieldGeneratorExpression';
    this.expression = expression;
  };
});
System.registerDynamic("npm:shift-reducer@4.0.0/dist/monoidal-reducer.js", ["shift-ast"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }(); /**
        * Copyright 2016 Shape Security, Inc.
        *
        * Licensed under the Apache License, Version 2.0 (the "License")
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

  var _shiftAst = $__require('shift-ast');

  var _shiftAst2 = _interopRequireDefault(_shiftAst);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var MonoidalReducer = function () {
    function MonoidalReducer(monoid) {
      _classCallCheck(this, MonoidalReducer);

      this.identity = monoid.empty();
      var concat = monoid.prototype && monoid.prototype.concat || monoid.concat;
      this.append = function (a, b) {
        return concat.call(a, b);
      };
    }

    _createClass(MonoidalReducer, [{
      key: 'fold',
      value: function fold(list, a) {
        var _this = this;

        return list.reduce(function (memo, x) {
          return _this.append(memo, x);
        }, a == null ? this.identity : a);
      }
    }, {
      key: 'reduceArrayAssignmentTarget',
      value: function reduceArrayAssignmentTarget(node, _ref) {
        var elements = _ref.elements;
        var rest = _ref.rest;

        return this.append(this.fold(elements.filter(function (n) {
          return n !== null;
        })), rest === null ? this.identity : rest);
      }
    }, {
      key: 'reduceArrayBinding',
      value: function reduceArrayBinding(node, _ref2) {
        var elements = _ref2.elements;
        var rest = _ref2.rest;

        return this.append(this.fold(elements.filter(function (n) {
          return n !== null;
        })), rest === null ? this.identity : rest);
      }
    }, {
      key: 'reduceArrayExpression',
      value: function reduceArrayExpression(node, _ref3) {
        var elements = _ref3.elements;

        return this.fold(elements.filter(function (n) {
          return n !== null;
        }));
      }
    }, {
      key: 'reduceArrowExpression',
      value: function reduceArrowExpression(node, _ref4) {
        var params = _ref4.params;
        var body = _ref4.body;

        return this.append(params, body);
      }
    }, {
      key: 'reduceAssignmentExpression',
      value: function reduceAssignmentExpression(node, _ref5) {
        var binding = _ref5.binding;
        var expression = _ref5.expression;

        return this.append(binding, expression);
      }
    }, {
      key: 'reduceAssignmentTargetIdentifier',
      value: function reduceAssignmentTargetIdentifier(node) {
        return this.identity;
      }
    }, {
      key: 'reduceAssignmentTargetPropertyIdentifier',
      value: function reduceAssignmentTargetPropertyIdentifier(node, _ref6) {
        var binding = _ref6.binding;
        var init = _ref6.init;

        return this.append(binding, init === null ? this.identity : init);
      }
    }, {
      key: 'reduceAssignmentTargetPropertyProperty',
      value: function reduceAssignmentTargetPropertyProperty(node, _ref7) {
        var name = _ref7.name;
        var binding = _ref7.binding;

        return this.append(name, binding);
      }
    }, {
      key: 'reduceAssignmentTargetWithDefault',
      value: function reduceAssignmentTargetWithDefault(node, _ref8) {
        var binding = _ref8.binding;
        var init = _ref8.init;

        return this.append(binding, init);
      }
    }, {
      key: 'reduceBinaryExpression',
      value: function reduceBinaryExpression(node, _ref9) {
        var left = _ref9.left;
        var right = _ref9.right;

        return this.append(left, right);
      }
    }, {
      key: 'reduceBindingIdentifier',
      value: function reduceBindingIdentifier(node) {
        return this.identity;
      }
    }, {
      key: 'reduceBindingPropertyIdentifier',
      value: function reduceBindingPropertyIdentifier(node, _ref10) {
        var binding = _ref10.binding;
        var init = _ref10.init;

        return this.append(binding, init === null ? this.identity : init);
      }
    }, {
      key: 'reduceBindingPropertyProperty',
      value: function reduceBindingPropertyProperty(node, _ref11) {
        var name = _ref11.name;
        var binding = _ref11.binding;

        return this.append(name, binding);
      }
    }, {
      key: 'reduceBindingWithDefault',
      value: function reduceBindingWithDefault(node, _ref12) {
        var binding = _ref12.binding;
        var init = _ref12.init;

        return this.append(binding, init);
      }
    }, {
      key: 'reduceBlock',
      value: function reduceBlock(node, _ref13) {
        var statements = _ref13.statements;

        return this.fold(statements);
      }
    }, {
      key: 'reduceBlockStatement',
      value: function reduceBlockStatement(node, _ref14) {
        var block = _ref14.block;

        return block;
      }
    }, {
      key: 'reduceBreakStatement',
      value: function reduceBreakStatement(node) {
        return this.identity;
      }
    }, {
      key: 'reduceCallExpression',
      value: function reduceCallExpression(node, _ref15) {
        var callee = _ref15.callee;
        var _arguments = _ref15.arguments;

        return this.append(callee, this.fold(_arguments));
      }
    }, {
      key: 'reduceCatchClause',
      value: function reduceCatchClause(node, _ref16) {
        var binding = _ref16.binding;
        var body = _ref16.body;

        return this.append(binding, body);
      }
    }, {
      key: 'reduceClassDeclaration',
      value: function reduceClassDeclaration(node, _ref17) {
        var name = _ref17.name;
        var _super = _ref17.super;
        var elements = _ref17.elements;

        return this.fold([name, _super === null ? this.identity : _super, this.fold(elements)]);
      }
    }, {
      key: 'reduceClassElement',
      value: function reduceClassElement(node, _ref18) {
        var method = _ref18.method;

        return method;
      }
    }, {
      key: 'reduceClassExpression',
      value: function reduceClassExpression(node, _ref19) {
        var name = _ref19.name;
        var _super = _ref19.super;
        var elements = _ref19.elements;

        return this.fold([name === null ? this.identity : name, _super === null ? this.identity : _super, this.fold(elements)]);
      }
    }, {
      key: 'reduceCompoundAssignmentExpression',
      value: function reduceCompoundAssignmentExpression(node, _ref20) {
        var binding = _ref20.binding;
        var expression = _ref20.expression;

        return this.append(binding, expression);
      }
    }, {
      key: 'reduceComputedMemberAssignmentTarget',
      value: function reduceComputedMemberAssignmentTarget(node, _ref21) {
        var object = _ref21.object;
        var expression = _ref21.expression;

        return this.append(object, expression);
      }
    }, {
      key: 'reduceComputedMemberExpression',
      value: function reduceComputedMemberExpression(node, _ref22) {
        var object = _ref22.object;
        var expression = _ref22.expression;

        return this.append(object, expression);
      }
    }, {
      key: 'reduceComputedPropertyName',
      value: function reduceComputedPropertyName(node, _ref23) {
        var expression = _ref23.expression;

        return expression;
      }
    }, {
      key: 'reduceConditionalExpression',
      value: function reduceConditionalExpression(node, _ref24) {
        var test = _ref24.test;
        var consequent = _ref24.consequent;
        var alternate = _ref24.alternate;

        return this.fold([test, consequent, alternate]);
      }
    }, {
      key: 'reduceContinueStatement',
      value: function reduceContinueStatement(node) {
        return this.identity;
      }
    }, {
      key: 'reduceDataProperty',
      value: function reduceDataProperty(node, _ref25) {
        var name = _ref25.name;
        var expression = _ref25.expression;

        return this.append(name, expression);
      }
    }, {
      key: 'reduceDebuggerStatement',
      value: function reduceDebuggerStatement(node) {
        return this.identity;
      }
    }, {
      key: 'reduceDirective',
      value: function reduceDirective(node) {
        return this.identity;
      }
    }, {
      key: 'reduceDoWhileStatement',
      value: function reduceDoWhileStatement(node, _ref26) {
        var body = _ref26.body;
        var test = _ref26.test;

        return this.append(body, test);
      }
    }, {
      key: 'reduceEmptyStatement',
      value: function reduceEmptyStatement(node) {
        return this.identity;
      }
    }, {
      key: 'reduceExport',
      value: function reduceExport(node, _ref27) {
        var declaration = _ref27.declaration;

        return declaration;
      }
    }, {
      key: 'reduceExportAllFrom',
      value: function reduceExportAllFrom(node) {
        return this.identity;
      }
    }, {
      key: 'reduceExportDefault',
      value: function reduceExportDefault(node, _ref28) {
        var body = _ref28.body;

        return body;
      }
    }, {
      key: 'reduceExportFrom',
      value: function reduceExportFrom(node, _ref29) {
        var namedExports = _ref29.namedExports;

        return this.fold(namedExports);
      }
    }, {
      key: 'reduceExportFromSpecifier',
      value: function reduceExportFromSpecifier(node) {
        return this.identity;
      }
    }, {
      key: 'reduceExportLocalSpecifier',
      value: function reduceExportLocalSpecifier(node, _ref30) {
        var name = _ref30.name;

        return name;
      }
    }, {
      key: 'reduceExportLocals',
      value: function reduceExportLocals(node, _ref31) {
        var namedExports = _ref31.namedExports;

        return this.fold(namedExports);
      }
    }, {
      key: 'reduceExpressionStatement',
      value: function reduceExpressionStatement(node, _ref32) {
        var expression = _ref32.expression;

        return expression;
      }
    }, {
      key: 'reduceForInStatement',
      value: function reduceForInStatement(node, _ref33) {
        var left = _ref33.left;
        var right = _ref33.right;
        var body = _ref33.body;

        return this.fold([left, right, body]);
      }
    }, {
      key: 'reduceForOfStatement',
      value: function reduceForOfStatement(node, _ref34) {
        var left = _ref34.left;
        var right = _ref34.right;
        var body = _ref34.body;

        return this.fold([left, right, body]);
      }
    }, {
      key: 'reduceForStatement',
      value: function reduceForStatement(node, _ref35) {
        var init = _ref35.init;
        var test = _ref35.test;
        var update = _ref35.update;
        var body = _ref35.body;

        return this.fold([init === null ? this.identity : init, test === null ? this.identity : test, update === null ? this.identity : update, body]);
      }
    }, {
      key: 'reduceFormalParameters',
      value: function reduceFormalParameters(node, _ref36) {
        var items = _ref36.items;
        var rest = _ref36.rest;

        return this.append(this.fold(items), rest === null ? this.identity : rest);
      }
    }, {
      key: 'reduceFunctionBody',
      value: function reduceFunctionBody(node, _ref37) {
        var directives = _ref37.directives;
        var statements = _ref37.statements;

        return this.append(this.fold(directives), this.fold(statements));
      }
    }, {
      key: 'reduceFunctionDeclaration',
      value: function reduceFunctionDeclaration(node, _ref38) {
        var name = _ref38.name;
        var params = _ref38.params;
        var body = _ref38.body;

        return this.fold([name, params, body]);
      }
    }, {
      key: 'reduceFunctionExpression',
      value: function reduceFunctionExpression(node, _ref39) {
        var name = _ref39.name;
        var params = _ref39.params;
        var body = _ref39.body;

        return this.fold([name === null ? this.identity : name, params, body]);
      }
    }, {
      key: 'reduceGetter',
      value: function reduceGetter(node, _ref40) {
        var name = _ref40.name;
        var body = _ref40.body;

        return this.append(name, body);
      }
    }, {
      key: 'reduceIdentifierExpression',
      value: function reduceIdentifierExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceIfStatement',
      value: function reduceIfStatement(node, _ref41) {
        var test = _ref41.test;
        var consequent = _ref41.consequent;
        var alternate = _ref41.alternate;

        return this.fold([test, consequent, alternate === null ? this.identity : alternate]);
      }
    }, {
      key: 'reduceImport',
      value: function reduceImport(node, _ref42) {
        var defaultBinding = _ref42.defaultBinding;
        var namedImports = _ref42.namedImports;

        return this.append(defaultBinding === null ? this.identity : defaultBinding, this.fold(namedImports));
      }
    }, {
      key: 'reduceImportNamespace',
      value: function reduceImportNamespace(node, _ref43) {
        var defaultBinding = _ref43.defaultBinding;
        var namespaceBinding = _ref43.namespaceBinding;

        return this.append(defaultBinding === null ? this.identity : defaultBinding, namespaceBinding);
      }
    }, {
      key: 'reduceImportSpecifier',
      value: function reduceImportSpecifier(node, _ref44) {
        var binding = _ref44.binding;

        return binding;
      }
    }, {
      key: 'reduceLabeledStatement',
      value: function reduceLabeledStatement(node, _ref45) {
        var body = _ref45.body;

        return body;
      }
    }, {
      key: 'reduceLiteralBooleanExpression',
      value: function reduceLiteralBooleanExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceLiteralInfinityExpression',
      value: function reduceLiteralInfinityExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceLiteralNullExpression',
      value: function reduceLiteralNullExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceLiteralNumericExpression',
      value: function reduceLiteralNumericExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceLiteralRegExpExpression',
      value: function reduceLiteralRegExpExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceLiteralStringExpression',
      value: function reduceLiteralStringExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceMethod',
      value: function reduceMethod(node, _ref46) {
        var name = _ref46.name;
        var params = _ref46.params;
        var body = _ref46.body;

        return this.fold([name, params, body]);
      }
    }, {
      key: 'reduceModule',
      value: function reduceModule(node, _ref47) {
        var directives = _ref47.directives;
        var items = _ref47.items;

        return this.append(this.fold(directives), this.fold(items));
      }
    }, {
      key: 'reduceNewExpression',
      value: function reduceNewExpression(node, _ref48) {
        var callee = _ref48.callee;
        var _arguments = _ref48.arguments;

        return this.append(callee, this.fold(_arguments));
      }
    }, {
      key: 'reduceNewTargetExpression',
      value: function reduceNewTargetExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceObjectAssignmentTarget',
      value: function reduceObjectAssignmentTarget(node, _ref49) {
        var properties = _ref49.properties;

        return this.fold(properties);
      }
    }, {
      key: 'reduceObjectBinding',
      value: function reduceObjectBinding(node, _ref50) {
        var properties = _ref50.properties;

        return this.fold(properties);
      }
    }, {
      key: 'reduceObjectExpression',
      value: function reduceObjectExpression(node, _ref51) {
        var properties = _ref51.properties;

        return this.fold(properties);
      }
    }, {
      key: 'reduceReturnStatement',
      value: function reduceReturnStatement(node, _ref52) {
        var expression = _ref52.expression;

        return expression === null ? this.identity : expression;
      }
    }, {
      key: 'reduceScript',
      value: function reduceScript(node, _ref53) {
        var directives = _ref53.directives;
        var statements = _ref53.statements;

        return this.append(this.fold(directives), this.fold(statements));
      }
    }, {
      key: 'reduceSetter',
      value: function reduceSetter(node, _ref54) {
        var name = _ref54.name;
        var param = _ref54.param;
        var body = _ref54.body;

        return this.fold([name, param, body]);
      }
    }, {
      key: 'reduceShorthandProperty',
      value: function reduceShorthandProperty(node, _ref55) {
        var name = _ref55.name;

        return name;
      }
    }, {
      key: 'reduceSpreadElement',
      value: function reduceSpreadElement(node, _ref56) {
        var expression = _ref56.expression;

        return expression;
      }
    }, {
      key: 'reduceStaticMemberAssignmentTarget',
      value: function reduceStaticMemberAssignmentTarget(node, _ref57) {
        var object = _ref57.object;

        return object;
      }
    }, {
      key: 'reduceStaticMemberExpression',
      value: function reduceStaticMemberExpression(node, _ref58) {
        var object = _ref58.object;

        return object;
      }
    }, {
      key: 'reduceStaticPropertyName',
      value: function reduceStaticPropertyName(node) {
        return this.identity;
      }
    }, {
      key: 'reduceSuper',
      value: function reduceSuper(node) {
        return this.identity;
      }
    }, {
      key: 'reduceSwitchCase',
      value: function reduceSwitchCase(node, _ref59) {
        var test = _ref59.test;
        var consequent = _ref59.consequent;

        return this.append(test, this.fold(consequent));
      }
    }, {
      key: 'reduceSwitchDefault',
      value: function reduceSwitchDefault(node, _ref60) {
        var consequent = _ref60.consequent;

        return this.fold(consequent);
      }
    }, {
      key: 'reduceSwitchStatement',
      value: function reduceSwitchStatement(node, _ref61) {
        var discriminant = _ref61.discriminant;
        var cases = _ref61.cases;

        return this.append(discriminant, this.fold(cases));
      }
    }, {
      key: 'reduceSwitchStatementWithDefault',
      value: function reduceSwitchStatementWithDefault(node, _ref62) {
        var discriminant = _ref62.discriminant;
        var preDefaultCases = _ref62.preDefaultCases;
        var defaultCase = _ref62.defaultCase;
        var postDefaultCases = _ref62.postDefaultCases;

        return this.fold([discriminant, this.fold(preDefaultCases), defaultCase, this.fold(postDefaultCases)]);
      }
    }, {
      key: 'reduceTemplateElement',
      value: function reduceTemplateElement(node) {
        return this.identity;
      }
    }, {
      key: 'reduceTemplateExpression',
      value: function reduceTemplateExpression(node, _ref63) {
        var tag = _ref63.tag;
        var elements = _ref63.elements;

        return this.append(tag === null ? this.identity : tag, this.fold(elements));
      }
    }, {
      key: 'reduceThisExpression',
      value: function reduceThisExpression(node) {
        return this.identity;
      }
    }, {
      key: 'reduceThrowStatement',
      value: function reduceThrowStatement(node, _ref64) {
        var expression = _ref64.expression;

        return expression;
      }
    }, {
      key: 'reduceTryCatchStatement',
      value: function reduceTryCatchStatement(node, _ref65) {
        var body = _ref65.body;
        var catchClause = _ref65.catchClause;

        return this.append(body, catchClause);
      }
    }, {
      key: 'reduceTryFinallyStatement',
      value: function reduceTryFinallyStatement(node, _ref66) {
        var body = _ref66.body;
        var catchClause = _ref66.catchClause;
        var finalizer = _ref66.finalizer;

        return this.fold([body, catchClause === null ? this.identity : catchClause, finalizer]);
      }
    }, {
      key: 'reduceUnaryExpression',
      value: function reduceUnaryExpression(node, _ref67) {
        var operand = _ref67.operand;

        return operand;
      }
    }, {
      key: 'reduceUpdateExpression',
      value: function reduceUpdateExpression(node, _ref68) {
        var operand = _ref68.operand;

        return operand;
      }
    }, {
      key: 'reduceVariableDeclaration',
      value: function reduceVariableDeclaration(node, _ref69) {
        var declarators = _ref69.declarators;

        return this.fold(declarators);
      }
    }, {
      key: 'reduceVariableDeclarationStatement',
      value: function reduceVariableDeclarationStatement(node, _ref70) {
        var declaration = _ref70.declaration;

        return declaration;
      }
    }, {
      key: 'reduceVariableDeclarator',
      value: function reduceVariableDeclarator(node, _ref71) {
        var binding = _ref71.binding;
        var init = _ref71.init;

        return this.append(binding, init === null ? this.identity : init);
      }
    }, {
      key: 'reduceWhileStatement',
      value: function reduceWhileStatement(node, _ref72) {
        var test = _ref72.test;
        var body = _ref72.body;

        return this.append(test, body);
      }
    }, {
      key: 'reduceWithStatement',
      value: function reduceWithStatement(node, _ref73) {
        var object = _ref73.object;
        var body = _ref73.body;

        return this.append(object, body);
      }
    }, {
      key: 'reduceYieldExpression',
      value: function reduceYieldExpression(node, _ref74) {
        var expression = _ref74.expression;

        return expression === null ? this.identity : expression;
      }
    }, {
      key: 'reduceYieldGeneratorExpression',
      value: function reduceYieldGeneratorExpression(node, _ref75) {
        var expression = _ref75.expression;

        return expression;
      }
    }]);

    return MonoidalReducer;
  }();

  exports.default = MonoidalReducer;
});
System.registerDynamic("npm:shift-reducer@4.0.0.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-reducer@4.0.0/dist/index.js", ["./clone-reducer", "./monoidal-reducer"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = reduce;

  var _cloneReducer = $__require("./clone-reducer");

  Object.defineProperty(exports, "CloneReducer", {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_cloneReducer).default;
    }
  });

  var _monoidalReducer = $__require("./monoidal-reducer");

  Object.defineProperty(exports, "MonoidalReducer", {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_monoidalReducer).default;
    }
  });

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  /**
   * Copyright 2016 Shape Security, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var director = {
    ArrayAssignmentTarget: function ArrayAssignmentTarget(reducer, node) {
      var _this = this;

      return reducer.reduceArrayAssignmentTarget(node, { elements: node.elements.map(function (v) {
          return v && _this[v.type](reducer, v);
        }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
    },
    ArrayBinding: function ArrayBinding(reducer, node) {
      var _this2 = this;

      return reducer.reduceArrayBinding(node, { elements: node.elements.map(function (v) {
          return v && _this2[v.type](reducer, v);
        }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
    },
    ArrayExpression: function ArrayExpression(reducer, node) {
      var _this3 = this;

      return reducer.reduceArrayExpression(node, { elements: node.elements.map(function (v) {
          return v && _this3[v.type](reducer, v);
        }) });
    },
    ArrowExpression: function ArrowExpression(reducer, node) {
      return reducer.reduceArrowExpression(node, { params: this.FormalParameters(reducer, node.params), body: this[node.body.type](reducer, node.body) });
    },
    AssignmentExpression: function AssignmentExpression(reducer, node) {
      return reducer.reduceAssignmentExpression(node, { binding: this[node.binding.type](reducer, node.binding), expression: this[node.expression.type](reducer, node.expression) });
    },
    AssignmentTargetIdentifier: function AssignmentTargetIdentifier(reducer, node) {
      return reducer.reduceAssignmentTargetIdentifier(node);
    },
    AssignmentTargetPropertyIdentifier: function AssignmentTargetPropertyIdentifier(reducer, node) {
      return reducer.reduceAssignmentTargetPropertyIdentifier(node, { binding: this.AssignmentTargetIdentifier(reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
    },
    AssignmentTargetPropertyProperty: function AssignmentTargetPropertyProperty(reducer, node) {
      return reducer.reduceAssignmentTargetPropertyProperty(node, { name: this[node.name.type](reducer, node.name), binding: this[node.binding.type](reducer, node.binding) });
    },
    AssignmentTargetWithDefault: function AssignmentTargetWithDefault(reducer, node) {
      return reducer.reduceAssignmentTargetWithDefault(node, { binding: this[node.binding.type](reducer, node.binding), init: this[node.init.type](reducer, node.init) });
    },
    BinaryExpression: function BinaryExpression(reducer, node) {
      return reducer.reduceBinaryExpression(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right) });
    },
    BindingIdentifier: function BindingIdentifier(reducer, node) {
      return reducer.reduceBindingIdentifier(node);
    },
    BindingPropertyIdentifier: function BindingPropertyIdentifier(reducer, node) {
      return reducer.reduceBindingPropertyIdentifier(node, { binding: this.BindingIdentifier(reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
    },
    BindingPropertyProperty: function BindingPropertyProperty(reducer, node) {
      return reducer.reduceBindingPropertyProperty(node, { name: this[node.name.type](reducer, node.name), binding: this[node.binding.type](reducer, node.binding) });
    },
    BindingWithDefault: function BindingWithDefault(reducer, node) {
      return reducer.reduceBindingWithDefault(node, { binding: this[node.binding.type](reducer, node.binding), init: this[node.init.type](reducer, node.init) });
    },
    Block: function Block(reducer, node) {
      var _this4 = this;

      return reducer.reduceBlock(node, { statements: node.statements.map(function (v) {
          return _this4[v.type](reducer, v);
        }) });
    },
    BlockStatement: function BlockStatement(reducer, node) {
      return reducer.reduceBlockStatement(node, { block: this.Block(reducer, node.block) });
    },
    BreakStatement: function BreakStatement(reducer, node) {
      return reducer.reduceBreakStatement(node);
    },
    CallExpression: function CallExpression(reducer, node) {
      var _this5 = this;

      return reducer.reduceCallExpression(node, { callee: this[node.callee.type](reducer, node.callee), arguments: node.arguments.map(function (v) {
          return _this5[v.type](reducer, v);
        }) });
    },
    CatchClause: function CatchClause(reducer, node) {
      return reducer.reduceCatchClause(node, { binding: this[node.binding.type](reducer, node.binding), body: this.Block(reducer, node.body) });
    },
    ClassDeclaration: function ClassDeclaration(reducer, node) {
      var _this6 = this;

      return reducer.reduceClassDeclaration(node, { name: this.BindingIdentifier(reducer, node.name), super: node.super && this[node.super.type](reducer, node.super), elements: node.elements.map(function (v) {
          return _this6.ClassElement(reducer, v);
        }) });
    },
    ClassElement: function ClassElement(reducer, node) {
      return reducer.reduceClassElement(node, { method: this[node.method.type](reducer, node.method) });
    },
    ClassExpression: function ClassExpression(reducer, node) {
      var _this7 = this;

      return reducer.reduceClassExpression(node, { name: node.name && this.BindingIdentifier(reducer, node.name), super: node.super && this[node.super.type](reducer, node.super), elements: node.elements.map(function (v) {
          return _this7.ClassElement(reducer, v);
        }) });
    },
    CompoundAssignmentExpression: function CompoundAssignmentExpression(reducer, node) {
      return reducer.reduceCompoundAssignmentExpression(node, { binding: this[node.binding.type](reducer, node.binding), expression: this[node.expression.type](reducer, node.expression) });
    },
    ComputedMemberAssignmentTarget: function ComputedMemberAssignmentTarget(reducer, node) {
      return reducer.reduceComputedMemberAssignmentTarget(node, { object: this[node.object.type](reducer, node.object), expression: this[node.expression.type](reducer, node.expression) });
    },
    ComputedMemberExpression: function ComputedMemberExpression(reducer, node) {
      return reducer.reduceComputedMemberExpression(node, { object: this[node.object.type](reducer, node.object), expression: this[node.expression.type](reducer, node.expression) });
    },
    ComputedPropertyName: function ComputedPropertyName(reducer, node) {
      return reducer.reduceComputedPropertyName(node, { expression: this[node.expression.type](reducer, node.expression) });
    },
    ConditionalExpression: function ConditionalExpression(reducer, node) {
      return reducer.reduceConditionalExpression(node, { test: this[node.test.type](reducer, node.test), consequent: this[node.consequent.type](reducer, node.consequent), alternate: this[node.alternate.type](reducer, node.alternate) });
    },
    ContinueStatement: function ContinueStatement(reducer, node) {
      return reducer.reduceContinueStatement(node);
    },
    DataProperty: function DataProperty(reducer, node) {
      return reducer.reduceDataProperty(node, { name: this[node.name.type](reducer, node.name), expression: this[node.expression.type](reducer, node.expression) });
    },
    DebuggerStatement: function DebuggerStatement(reducer, node) {
      return reducer.reduceDebuggerStatement(node);
    },
    Directive: function Directive(reducer, node) {
      return reducer.reduceDirective(node);
    },
    DoWhileStatement: function DoWhileStatement(reducer, node) {
      return reducer.reduceDoWhileStatement(node, { body: this[node.body.type](reducer, node.body), test: this[node.test.type](reducer, node.test) });
    },
    EmptyStatement: function EmptyStatement(reducer, node) {
      return reducer.reduceEmptyStatement(node);
    },
    Export: function Export(reducer, node) {
      return reducer.reduceExport(node, { declaration: this[node.declaration.type](reducer, node.declaration) });
    },
    ExportAllFrom: function ExportAllFrom(reducer, node) {
      return reducer.reduceExportAllFrom(node);
    },
    ExportDefault: function ExportDefault(reducer, node) {
      return reducer.reduceExportDefault(node, { body: this[node.body.type](reducer, node.body) });
    },
    ExportFrom: function ExportFrom(reducer, node) {
      var _this8 = this;

      return reducer.reduceExportFrom(node, { namedExports: node.namedExports.map(function (v) {
          return _this8.ExportFromSpecifier(reducer, v);
        }) });
    },
    ExportFromSpecifier: function ExportFromSpecifier(reducer, node) {
      return reducer.reduceExportFromSpecifier(node);
    },
    ExportLocalSpecifier: function ExportLocalSpecifier(reducer, node) {
      return reducer.reduceExportLocalSpecifier(node, { name: this.IdentifierExpression(reducer, node.name) });
    },
    ExportLocals: function ExportLocals(reducer, node) {
      var _this9 = this;

      return reducer.reduceExportLocals(node, { namedExports: node.namedExports.map(function (v) {
          return _this9.ExportLocalSpecifier(reducer, v);
        }) });
    },
    ExpressionStatement: function ExpressionStatement(reducer, node) {
      return reducer.reduceExpressionStatement(node, { expression: this[node.expression.type](reducer, node.expression) });
    },
    ForInStatement: function ForInStatement(reducer, node) {
      return reducer.reduceForInStatement(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right), body: this[node.body.type](reducer, node.body) });
    },
    ForOfStatement: function ForOfStatement(reducer, node) {
      return reducer.reduceForOfStatement(node, { left: this[node.left.type](reducer, node.left), right: this[node.right.type](reducer, node.right), body: this[node.body.type](reducer, node.body) });
    },
    ForStatement: function ForStatement(reducer, node) {
      return reducer.reduceForStatement(node, { init: node.init && this[node.init.type](reducer, node.init), test: node.test && this[node.test.type](reducer, node.test), update: node.update && this[node.update.type](reducer, node.update), body: this[node.body.type](reducer, node.body) });
    },
    FormalParameters: function FormalParameters(reducer, node) {
      var _this10 = this;

      return reducer.reduceFormalParameters(node, { items: node.items.map(function (v) {
          return _this10[v.type](reducer, v);
        }), rest: node.rest && this[node.rest.type](reducer, node.rest) });
    },
    FunctionBody: function FunctionBody(reducer, node) {
      var _this11 = this;

      return reducer.reduceFunctionBody(node, { directives: node.directives.map(function (v) {
          return _this11.Directive(reducer, v);
        }), statements: node.statements.map(function (v) {
          return _this11[v.type](reducer, v);
        }) });
    },
    FunctionDeclaration: function FunctionDeclaration(reducer, node) {
      return reducer.reduceFunctionDeclaration(node, { name: this.BindingIdentifier(reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
    },
    FunctionExpression: function FunctionExpression(reducer, node) {
      return reducer.reduceFunctionExpression(node, { name: node.name && this.BindingIdentifier(reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
    },
    Getter: function Getter(reducer, node) {
      return reducer.reduceGetter(node, { name: this[node.name.type](reducer, node.name), body: this.FunctionBody(reducer, node.body) });
    },
    IdentifierExpression: function IdentifierExpression(reducer, node) {
      return reducer.reduceIdentifierExpression(node);
    },
    IfStatement: function IfStatement(reducer, node) {
      return reducer.reduceIfStatement(node, { test: this[node.test.type](reducer, node.test), consequent: this[node.consequent.type](reducer, node.consequent), alternate: node.alternate && this[node.alternate.type](reducer, node.alternate) });
    },
    Import: function Import(reducer, node) {
      var _this12 = this;

      return reducer.reduceImport(node, { defaultBinding: node.defaultBinding && this.BindingIdentifier(reducer, node.defaultBinding), namedImports: node.namedImports.map(function (v) {
          return _this12.ImportSpecifier(reducer, v);
        }) });
    },
    ImportNamespace: function ImportNamespace(reducer, node) {
      return reducer.reduceImportNamespace(node, { defaultBinding: node.defaultBinding && this.BindingIdentifier(reducer, node.defaultBinding), namespaceBinding: this.BindingIdentifier(reducer, node.namespaceBinding) });
    },
    ImportSpecifier: function ImportSpecifier(reducer, node) {
      return reducer.reduceImportSpecifier(node, { binding: this.BindingIdentifier(reducer, node.binding) });
    },
    LabeledStatement: function LabeledStatement(reducer, node) {
      return reducer.reduceLabeledStatement(node, { body: this[node.body.type](reducer, node.body) });
    },
    LiteralBooleanExpression: function LiteralBooleanExpression(reducer, node) {
      return reducer.reduceLiteralBooleanExpression(node);
    },
    LiteralInfinityExpression: function LiteralInfinityExpression(reducer, node) {
      return reducer.reduceLiteralInfinityExpression(node);
    },
    LiteralNullExpression: function LiteralNullExpression(reducer, node) {
      return reducer.reduceLiteralNullExpression(node);
    },
    LiteralNumericExpression: function LiteralNumericExpression(reducer, node) {
      return reducer.reduceLiteralNumericExpression(node);
    },
    LiteralRegExpExpression: function LiteralRegExpExpression(reducer, node) {
      return reducer.reduceLiteralRegExpExpression(node);
    },
    LiteralStringExpression: function LiteralStringExpression(reducer, node) {
      return reducer.reduceLiteralStringExpression(node);
    },
    Method: function Method(reducer, node) {
      return reducer.reduceMethod(node, { name: this[node.name.type](reducer, node.name), params: this.FormalParameters(reducer, node.params), body: this.FunctionBody(reducer, node.body) });
    },
    Module: function Module(reducer, node) {
      var _this13 = this;

      return reducer.reduceModule(node, { directives: node.directives.map(function (v) {
          return _this13.Directive(reducer, v);
        }), items: node.items.map(function (v) {
          return _this13[v.type](reducer, v);
        }) });
    },
    NewExpression: function NewExpression(reducer, node) {
      var _this14 = this;

      return reducer.reduceNewExpression(node, { callee: this[node.callee.type](reducer, node.callee), arguments: node.arguments.map(function (v) {
          return _this14[v.type](reducer, v);
        }) });
    },
    NewTargetExpression: function NewTargetExpression(reducer, node) {
      return reducer.reduceNewTargetExpression(node);
    },
    ObjectAssignmentTarget: function ObjectAssignmentTarget(reducer, node) {
      var _this15 = this;

      return reducer.reduceObjectAssignmentTarget(node, { properties: node.properties.map(function (v) {
          return _this15[v.type](reducer, v);
        }) });
    },
    ObjectBinding: function ObjectBinding(reducer, node) {
      var _this16 = this;

      return reducer.reduceObjectBinding(node, { properties: node.properties.map(function (v) {
          return _this16[v.type](reducer, v);
        }) });
    },
    ObjectExpression: function ObjectExpression(reducer, node) {
      var _this17 = this;

      return reducer.reduceObjectExpression(node, { properties: node.properties.map(function (v) {
          return _this17[v.type](reducer, v);
        }) });
    },
    ReturnStatement: function ReturnStatement(reducer, node) {
      return reducer.reduceReturnStatement(node, { expression: node.expression && this[node.expression.type](reducer, node.expression) });
    },
    Script: function Script(reducer, node) {
      var _this18 = this;

      return reducer.reduceScript(node, { directives: node.directives.map(function (v) {
          return _this18.Directive(reducer, v);
        }), statements: node.statements.map(function (v) {
          return _this18[v.type](reducer, v);
        }) });
    },
    Setter: function Setter(reducer, node) {
      return reducer.reduceSetter(node, { name: this[node.name.type](reducer, node.name), param: this[node.param.type](reducer, node.param), body: this.FunctionBody(reducer, node.body) });
    },
    ShorthandProperty: function ShorthandProperty(reducer, node) {
      return reducer.reduceShorthandProperty(node, { name: this.IdentifierExpression(reducer, node.name) });
    },
    SpreadElement: function SpreadElement(reducer, node) {
      return reducer.reduceSpreadElement(node, { expression: this[node.expression.type](reducer, node.expression) });
    },
    StaticMemberAssignmentTarget: function StaticMemberAssignmentTarget(reducer, node) {
      return reducer.reduceStaticMemberAssignmentTarget(node, { object: this[node.object.type](reducer, node.object) });
    },
    StaticMemberExpression: function StaticMemberExpression(reducer, node) {
      return reducer.reduceStaticMemberExpression(node, { object: this[node.object.type](reducer, node.object) });
    },
    StaticPropertyName: function StaticPropertyName(reducer, node) {
      return reducer.reduceStaticPropertyName(node);
    },
    Super: function Super(reducer, node) {
      return reducer.reduceSuper(node);
    },
    SwitchCase: function SwitchCase(reducer, node) {
      var _this19 = this;

      return reducer.reduceSwitchCase(node, { test: this[node.test.type](reducer, node.test), consequent: node.consequent.map(function (v) {
          return _this19[v.type](reducer, v);
        }) });
    },
    SwitchDefault: function SwitchDefault(reducer, node) {
      var _this20 = this;

      return reducer.reduceSwitchDefault(node, { consequent: node.consequent.map(function (v) {
          return _this20[v.type](reducer, v);
        }) });
    },
    SwitchStatement: function SwitchStatement(reducer, node) {
      var _this21 = this;

      return reducer.reduceSwitchStatement(node, { discriminant: this[node.discriminant.type](reducer, node.discriminant), cases: node.cases.map(function (v) {
          return _this21.SwitchCase(reducer, v);
        }) });
    },
    SwitchStatementWithDefault: function SwitchStatementWithDefault(reducer, node) {
      var _this22 = this;

      return reducer.reduceSwitchStatementWithDefault(node, { discriminant: this[node.discriminant.type](reducer, node.discriminant), preDefaultCases: node.preDefaultCases.map(function (v) {
          return _this22.SwitchCase(reducer, v);
        }), defaultCase: this.SwitchDefault(reducer, node.defaultCase), postDefaultCases: node.postDefaultCases.map(function (v) {
          return _this22.SwitchCase(reducer, v);
        }) });
    },
    TemplateElement: function TemplateElement(reducer, node) {
      return reducer.reduceTemplateElement(node);
    },
    TemplateExpression: function TemplateExpression(reducer, node) {
      var _this23 = this;

      return reducer.reduceTemplateExpression(node, { tag: node.tag && this[node.tag.type](reducer, node.tag), elements: node.elements.map(function (v) {
          return _this23[v.type](reducer, v);
        }) });
    },
    ThisExpression: function ThisExpression(reducer, node) {
      return reducer.reduceThisExpression(node);
    },
    ThrowStatement: function ThrowStatement(reducer, node) {
      return reducer.reduceThrowStatement(node, { expression: this[node.expression.type](reducer, node.expression) });
    },
    TryCatchStatement: function TryCatchStatement(reducer, node) {
      return reducer.reduceTryCatchStatement(node, { body: this.Block(reducer, node.body), catchClause: this.CatchClause(reducer, node.catchClause) });
    },
    TryFinallyStatement: function TryFinallyStatement(reducer, node) {
      return reducer.reduceTryFinallyStatement(node, { body: this.Block(reducer, node.body), catchClause: node.catchClause && this.CatchClause(reducer, node.catchClause), finalizer: this.Block(reducer, node.finalizer) });
    },
    UnaryExpression: function UnaryExpression(reducer, node) {
      return reducer.reduceUnaryExpression(node, { operand: this[node.operand.type](reducer, node.operand) });
    },
    UpdateExpression: function UpdateExpression(reducer, node) {
      return reducer.reduceUpdateExpression(node, { operand: this[node.operand.type](reducer, node.operand) });
    },
    VariableDeclaration: function VariableDeclaration(reducer, node) {
      var _this24 = this;

      return reducer.reduceVariableDeclaration(node, { declarators: node.declarators.map(function (v) {
          return _this24.VariableDeclarator(reducer, v);
        }) });
    },
    VariableDeclarationStatement: function VariableDeclarationStatement(reducer, node) {
      return reducer.reduceVariableDeclarationStatement(node, { declaration: this.VariableDeclaration(reducer, node.declaration) });
    },
    VariableDeclarator: function VariableDeclarator(reducer, node) {
      return reducer.reduceVariableDeclarator(node, { binding: this[node.binding.type](reducer, node.binding), init: node.init && this[node.init.type](reducer, node.init) });
    },
    WhileStatement: function WhileStatement(reducer, node) {
      return reducer.reduceWhileStatement(node, { test: this[node.test.type](reducer, node.test), body: this[node.body.type](reducer, node.body) });
    },
    WithStatement: function WithStatement(reducer, node) {
      return reducer.reduceWithStatement(node, { object: this[node.object.type](reducer, node.object), body: this[node.body.type](reducer, node.body) });
    },
    YieldExpression: function YieldExpression(reducer, node) {
      return reducer.reduceYieldExpression(node, { expression: node.expression && this[node.expression.type](reducer, node.expression) });
    },
    YieldGeneratorExpression: function YieldGeneratorExpression(reducer, node) {
      return reducer.reduceYieldGeneratorExpression(node, { expression: this[node.expression.type](reducer, node.expression) });
    }
  };

  function reduce(reducer, node) {
    return director[node.type](reducer, node);
  }
});
System.registerDynamic("npm:shift-codegen@5.0.2/dist/token_stream.js", ["esutils"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TokenStream = undefined;

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }(); /**
        * Copyright 2014 Shape Security, Inc.
        *
        * Licensed under the Apache License, Version 2.0 (the "License")
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *     http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

  var _esutils = $__require("esutils");

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function numberDot(fragment) {
    if (fragment.indexOf(".") < 0 && fragment.indexOf("e") < 0 && fragment.indexOf("x") < 0) {
      return "..";
    }
    return ".";
  }

  function renderNumber(n) {
    var s;
    if (n >= 1e3 && n % 10 === 0) {
      s = n.toString(10);
      if (/[eE]/.test(s)) {
        return s.replace(/[eE]\+/, "e");
      }
      return n.toString(10).replace(/0+$/, function (match) {
        return "e" + match.length;
      });
    } else if (n % 1 === 0) {
      if (n > 1e15 && n < 1e20) {
        return "0x" + n.toString(16).toUpperCase();
      }
      return n.toString(10).replace(/[eE]\+/, "e");
    } else {
      return n.toString(10).replace(/^0\./, ".").replace(/[eE]\+/, "e");
    }
  }

  var TokenStream = exports.TokenStream = function () {
    function TokenStream() {
      _classCallCheck(this, TokenStream);

      this.result = "";
      this.lastNumber = null;
      this.lastChar = null;
      this.optionalSemi = false;
    }

    _createClass(TokenStream, [{
      key: "putNumber",
      value: function putNumber(number) {
        var tokenStr = renderNumber(number);
        this.put(tokenStr);
        this.lastNumber = tokenStr;
      }
    }, {
      key: "putOptionalSemi",
      value: function putOptionalSemi() {
        this.optionalSemi = true;
      }
    }, {
      key: "put",
      value: function put(tokenStr) {
        if (this.optionalSemi) {
          this.optionalSemi = false;
          if (tokenStr !== "}") {
            this.put(";");
          }
        }
        if (this.lastNumber !== null && tokenStr.length == 1) {
          if (tokenStr === ".") {
            this.result += numberDot(this.lastNumber);
            this.lastNumber = null;
            this.lastChar = ".";
            return;
          }
        }
        this.lastNumber = null;
        var rightChar = tokenStr.charAt(0);
        var lastChar = this.lastChar;
        this.lastChar = tokenStr.charAt(tokenStr.length - 1);
        if (lastChar && ((lastChar == "+" || lastChar == "-") && lastChar == rightChar || _esutils.code.isIdentifierPartES6(lastChar.charCodeAt(0)) && _esutils.code.isIdentifierPartES6(rightChar.charCodeAt(0)) || lastChar == "/" && (rightChar == "i" || rightChar == "/"))) {
          this.result += " ";
        }

        this.result += tokenStr;
      }
    }]);

    return TokenStream;
  }();
});
System.registerDynamic("npm:shift-codegen@5.0.2.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-codegen@5.0.2/dist/index.js", ["./minimal-codegen", "./formatted-codegen", "./coderep", "shift-reducer", "./token_stream"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SemiOp = exports.CommaSep = exports.Semi = exports.Seq = exports.ContainsIn = exports.NoIn = exports.Brace = exports.Bracket = exports.Paren = exports.NumberCodeRep = exports.Token = exports.Empty = exports.CodeRep = exports.escapeStringLiteral = exports.getPrecedence = exports.Precedence = exports.Sep = exports.FormattedCodeGen = exports.ExtensibleCodeGen = exports.MinimalCodeGen = undefined;
  exports.default = codeGen;

  var _minimalCodegen = $__require("./minimal-codegen");

  Object.defineProperty(exports, "MinimalCodeGen", {
    enumerable: true,
    get: function get() {
      return _interopRequireDefault(_minimalCodegen).default;
    }
  });

  var _formattedCodegen = $__require("./formatted-codegen");

  Object.defineProperty(exports, "ExtensibleCodeGen", {
    enumerable: true,
    get: function get() {
      return _formattedCodegen.ExtensibleCodeGen;
    }
  });
  Object.defineProperty(exports, "FormattedCodeGen", {
    enumerable: true,
    get: function get() {
      return _formattedCodegen.FormattedCodeGen;
    }
  });
  Object.defineProperty(exports, "Sep", {
    enumerable: true,
    get: function get() {
      return _formattedCodegen.Sep;
    }
  });

  var _coderep = $__require("./coderep");

  Object.defineProperty(exports, "Precedence", {
    enumerable: true,
    get: function get() {
      return _coderep.Precedence;
    }
  });
  Object.defineProperty(exports, "getPrecedence", {
    enumerable: true,
    get: function get() {
      return _coderep.getPrecedence;
    }
  });
  Object.defineProperty(exports, "escapeStringLiteral", {
    enumerable: true,
    get: function get() {
      return _coderep.escapeStringLiteral;
    }
  });
  Object.defineProperty(exports, "CodeRep", {
    enumerable: true,
    get: function get() {
      return _coderep.CodeRep;
    }
  });
  Object.defineProperty(exports, "Empty", {
    enumerable: true,
    get: function get() {
      return _coderep.Empty;
    }
  });
  Object.defineProperty(exports, "Token", {
    enumerable: true,
    get: function get() {
      return _coderep.Token;
    }
  });
  Object.defineProperty(exports, "NumberCodeRep", {
    enumerable: true,
    get: function get() {
      return _coderep.NumberCodeRep;
    }
  });
  Object.defineProperty(exports, "Paren", {
    enumerable: true,
    get: function get() {
      return _coderep.Paren;
    }
  });
  Object.defineProperty(exports, "Bracket", {
    enumerable: true,
    get: function get() {
      return _coderep.Bracket;
    }
  });
  Object.defineProperty(exports, "Brace", {
    enumerable: true,
    get: function get() {
      return _coderep.Brace;
    }
  });
  Object.defineProperty(exports, "NoIn", {
    enumerable: true,
    get: function get() {
      return _coderep.NoIn;
    }
  });
  Object.defineProperty(exports, "ContainsIn", {
    enumerable: true,
    get: function get() {
      return _coderep.ContainsIn;
    }
  });
  Object.defineProperty(exports, "Seq", {
    enumerable: true,
    get: function get() {
      return _coderep.Seq;
    }
  });
  Object.defineProperty(exports, "Semi", {
    enumerable: true,
    get: function get() {
      return _coderep.Semi;
    }
  });
  Object.defineProperty(exports, "CommaSep", {
    enumerable: true,
    get: function get() {
      return _coderep.CommaSep;
    }
  });
  Object.defineProperty(exports, "SemiOp", {
    enumerable: true,
    get: function get() {
      return _coderep.SemiOp;
    }
  });

  var _shiftReducer = $__require("shift-reducer");

  var _shiftReducer2 = _interopRequireDefault(_shiftReducer);

  var _token_stream = $__require("./token_stream");

  var _minimalCodegen2 = _interopRequireDefault(_minimalCodegen);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function codeGen(script) {
    var generator = arguments.length <= 1 || arguments[1] === undefined ? new _minimalCodegen2.default() : arguments[1];

    var ts = new _token_stream.TokenStream();
    var rep = (0, _shiftReducer2.default)(generator, script);
    rep.emit(ts);
    return ts.result;
  }
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/shift-reader.js", ["shift-parser/dist/tokenizer", "immutable", "./syntax", "ramda", "ramda-fantasy", "./errors", "./terms", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _tokenizer = $__require("shift-parser/dist/tokenizer"),
      _tokenizer2 = _interopRequireDefault(_tokenizer),
      _immutable = $__require("immutable"),
      _syntax = $__require("./syntax"),
      _syntax2 = _interopRequireDefault(_syntax),
      _ramda = $__require("ramda"),
      R = _interopRequireWildcard(_ramda),
      _ramdaFantasy = $__require("ramda-fantasy"),
      _errors = $__require("./errors"),
      _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms);function _interopRequireWildcard(c) {
    if (c && c.__esModule) return c;var d = {};if (null != c) for (var e in c) Object.prototype.hasOwnProperty.call(c, e) && (d[e] = c[e]);return d.default = c, d;
  }function _interopRequireDefault(c) {
    return c && c.__esModule ? c : { default: c };
  }const Just = _ramdaFantasy.Maybe.Just,
        Nothing = _ramdaFantasy.Maybe.Nothing,
        LSYNTAX = { name: "left-syntax" },
        RSYNTAX = { name: "right-syntax" },
        AT = { klass: _tokenizer.TokenClass.Punctuator, name: "@" },
        literalKeywords = ["this", "null", "true", "false"],
        isLeftBracket = R.whereEq({ type: _tokenizer.TokenType.LBRACK }),
        isLeftBrace = R.whereEq({ type: _tokenizer.TokenType.LBRACE }),
        isLeftParen = R.whereEq({ type: _tokenizer.TokenType.LPAREN }),
        isRightBracket = R.whereEq({ type: _tokenizer.TokenType.RBRACK }),
        isRightBrace = R.whereEq({ type: _tokenizer.TokenType.RBRACE }),
        isRightParen = R.whereEq({ type: _tokenizer.TokenType.RPAREN }),
        isEOS = R.whereEq({ type: _tokenizer.TokenType.EOS }),
        isLeftSyntax = R.whereEq({ type: LSYNTAX }),
        isRightSyntax = R.whereEq({ type: RSYNTAX }),
        isLeftDelimiter = R.anyPass([isLeftBracket, isLeftBrace, isLeftParen, isLeftSyntax]),
        isRightDelimiter = R.anyPass([isRightBracket, isRightBrace, isRightParen, isRightSyntax]),
        isMatchingDelimiters = R.cond([[isLeftBracket, (c, d) => isRightBracket(d)], [isLeftBrace, (c, d) => isRightBrace(d)], [isLeftParen, (c, d) => isRightParen(d)], [isLeftSyntax, (c, d) => isRightSyntax(d)], [R.T, R.F]]),
        assignOps = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ","],
        binaryOps = ["+", "-", "*", "/", "%", "<<", ">>", ">>>", "&", "|", "^", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!==", "instanceof"],
        unaryOps = ["++", "--", "~", "!", "delete", "void", "typeof", "yield", "throw", "new"],
        isEmpty = R.whereEq({ size: 0 }),
        isPunctuator = c => c.match("punctuator"),
        isKeyword = c => c.match("keyword"),
        isParens = c => c.match("parens"),
        isBraces = c => c.match("braces"),
        isIdentifier = c => c.match("identifier"),
        isVal = R.curry((c, d) => d.val() === c),
        isDot = R.allPass([isPunctuator, isVal(".")]),
        isColon = R.allPass([isPunctuator, isVal(":")]),
        isFunctionKeyword = R.allPass([isKeyword, isVal("function")]),
        isOperator = c => (c.match("punctuator") || c.match("keyword")) && R.any(R.equals(c.val()), assignOps.concat(binaryOps).concat(unaryOps)),
        isNonLiteralKeyword = R.allPass([isKeyword, c => R.none(R.equals(c.val()), literalKeywords)]),
        isKeywordExprPrefix = R.allPass([isKeyword, c => R.any(R.equals(c.val()), ["instanceof", "typeof", "delete", "void", "yield", "throw", "new", "case"])]);let last = c => c.last(),
      safeLast = R.pipe(R.cond([[isEmpty, R.always(Nothing())], [R.T, R.compose(_ramdaFantasy.Maybe.of, last)]])),
      stuffTrue = R.curry((c, d) => d ? Just(c) : Nothing()),
      stuffFalse = R.curry((c, d) => d ? Nothing() : Just(c)),
      isTopColon = R.pipe(safeLast, R.map(isColon), _ramdaFantasy.Maybe.maybe(!1, R.identity)),
      isTopPunctuator = R.pipe(safeLast, R.map(isPunctuator), _ramdaFantasy.Maybe.maybe(!1, R.identity)),
      isExprReturn = R.curry((c, d) => {
    let e = safeLast(d),
        f = pop(d).chain(safeLast);return !!f.map(isDot).getOrElse(!1) || e.map(g => {
      return g.match("keyword") && "return" === g.val() && g.lineNumber() === c;
    }).getOrElse(!1);
  });const isTopOperator = R.pipe(safeLast, R.map(isOperator), _ramdaFantasy.Maybe.maybe(!1, R.identity)),
        isTopKeywordExprPrefix = R.pipe(safeLast, R.map(isKeywordExprPrefix), _ramdaFantasy.Maybe.maybe(!1, R.identity));let isExprPrefix = R.curry((c, d) => R.cond([[isEmpty, R.always(d)], [isTopColon, R.always(d)], [isTopKeywordExprPrefix, R.T], [isTopOperator, R.T], [isTopPunctuator, R.always(d)], [isExprReturn(c), R.T], [R.T, R.F]])),
      curly = c => safeLast(c).map(isBraces).chain(stuffTrue(c)),
      paren = c => safeLast(c).map(isParens).chain(stuffTrue(c)),
      func = c => safeLast(c).map(isFunctionKeyword).chain(stuffTrue(c)),
      ident = c => safeLast(c).map(isIdentifier).chain(stuffTrue(c)),
      nonLiteralKeyword = c => safeLast(c).map(isNonLiteralKeyword).chain(stuffTrue(c)),
      opt = R.curry((c, d, e) => {
    let f = R.pipeK(c, d)(_ramdaFantasy.Maybe.of(e));return _ramdaFantasy.Maybe.isJust(f) ? f : _ramdaFantasy.Maybe.of(e);
  }),
      notDot = R.ifElse(R.whereEq({ size: 0 }), Just, c => safeLast(c).map(d => !(d.match("punctuator") && "." === d.val())).chain(stuffTrue(c))),
      pop = R.compose(Just, c => c.pop());const functionPrefix = R.pipeK(curly, pop, paren, pop, opt(ident, pop), func),
        isRegexPrefix = c => R.anyPass([isEmpty, isTopPunctuator, R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, R.pipeK(paren, pop, nonLiteralKeyword, pop, notDot), _ramdaFantasy.Maybe.isJust), R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, R.chain(d => {
    return safeLast(d).map(e => e.lineNumber()).chain(e => {
      return pop(d).map(isExprPrefix(e, c));
    }).chain(stuffFalse(d));
  }), _ramdaFantasy.Maybe.isJust), d => {
    let e = R.pipe(_ramdaFantasy.Maybe.of, functionPrefix, _ramdaFantasy.Maybe.isJust)(d);return !e && R.pipe(_ramdaFantasy.Maybe.of, R.chain(curly), R.chain(f => {
      return safeLast(f).map(g => g.lineNumber()).chain(g => {
        return pop(f).map(isExprPrefix(g, c));
      }).chain(stuffFalse(f));
    }), _ramdaFantasy.Maybe.isJust)(d);
  }]);function lastEl(c) {
    return c[c.length - 1];
  }class Reader extends _tokenizer2.default {
    constructor(c, d, e) {
      if (super(Array.isArray(c) ? c.join("") : c), this.delimStack = new Map(), this.insideSyntaxTemplate = [!1], this.context = d, Array.isArray(c)) {
        let f = 0;this.replacementIndex = R.reduce((g, h) => {
          return g.push({ index: f + h[0].length, replacement: h[1] }), f += h[0].length, g;
        }, [], R.zip(c, e));
      }
    }read() {
      let c = 0 >= arguments.length || arguments[0] === void 0 ? [] : arguments[0],
          d = 1 >= arguments.length || arguments[1] === void 0 ? !1 : arguments[1],
          e = 2 >= arguments.length || arguments[2] === void 0 ? !1 : arguments[2],
          f = (0, _immutable.List)();for (;;) {
        let g = this.advance(f, d);if (g.scopesets || g instanceof _terms2.default) {
          c.push(g);continue;
        }if (Array.isArray(g)) {
          Array.prototype.push.apply(c, g);continue;
        }if (_immutable.List.isList(g)) {
          Array.prototype.push.apply(c, g.toArray());continue;
        }if (isEOS(g)) {
          if (c[0] && isLeftDelimiter(c[0].token)) throw this.createUnexpected(g);break;
        }if (isLeftDelimiter(g)) {
          isLeftSyntax(g) && this.insideSyntaxTemplate.push(!0);let h = g.slice.startLocation.line,
              i = !isLeftBrace(g) || isExprPrefix(h, d)(f),
              j = this.read([new _syntax2.default(g, this.context)], i, !1),
              k = new _syntax2.default(j, this.context);if (f = f.concat(k), c.push(k), e) break;
        } else if (isRightDelimiter(g)) {
          if (c[0] && !isMatchingDelimiters(c[0].token, g)) throw this.createUnexpected(g);let h = new _syntax2.default(g, this.context);c.push(h), lastEl(this.insideSyntaxTemplate) && isRightSyntax(g) && this.insideSyntaxTemplate.pop();break;
        } else {
          let h = new _syntax2.default(g, this.context);f = f.concat(h), c.push(h);
        }
      }return (0, _immutable.List)(c);
    }advance(c, d) {
      if (this.lastIndex = this.index, this.lastLine = this.line, this.lastLineStart = this.lineStart, this.skipComment(), this.startIndex = this.index, this.startLine = this.line, this.startLineStart = this.lineStart, this.replacementIndex && this.replacementIndex[0] && this.index >= this.replacementIndex[0].index) {
        let g = this.replacementIndex[0].replacement;return this.replacementIndex.shift(), g;
      }let e = this.source.charCodeAt(this.index);if (96 === e) {
        let g,
            h = [],
            i = this.getLocation(),
            j = this.index;if (this.index++, lastEl(this.insideSyntaxTemplate)) {
          let k = this.getSlice(j, i);return { type: RSYNTAX, value: "`", slice: k };
        }do g = this.scanTemplateElement(), h.push(g), g.interp && (g = this.read([], !1, !0), (0, _errors.assert)(1 === g.size, "should only have read a single delimiter inside a template"), h.push(g.get(0))); while (!g.tail);return { type: _tokenizer.TokenType.TEMPLATE, items: (0, _immutable.List)(h), slice: this.getSlice(j, i) };
      }if (35 === e) {
        let g = this.getLocation(),
            h = this.index,
            i = this.getSlice(h, g);return this.index++, 96 === this.source.charCodeAt(this.index) ? (this.index++, { type: LSYNTAX, value: "#`", slice: i }) : { type: _tokenizer.TokenType.IDENTIFIER, value: "#", slice: i };
      }if (64 === e) {
        let g = this.getLocation(),
            h = this.index,
            i = this.getSlice(h, g);return this.index++, { type: AT, value: "@", slice: i };
      }let f = super.advance();return f.type === _tokenizer.TokenType.DIV && isRegexPrefix(d)(c) ? super.scanRegExp("/") : f;
    }scanTemplateElement() {
      for (let e, c = this.getLocation(), d = this.index; this.index < this.source.length;) switch (e = this.source.charCodeAt(this.index), e) {case 96:
          {
            let f = this.getSlice(d, c);return this.index++, { type: _tokenizer.TokenType.TEMPLATE, tail: !0, interp: !1, slice: f };
          }case 36:
          if (123 === this.source.charCodeAt(this.index + 1)) {
            let f = this.getSlice(d, c);return this.index += 1, { type: _tokenizer.TokenType.TEMPLATE, tail: !1, interp: !0, slice: f };
          }this.index++;break;case 92:
          {
            let f = this.scanStringEscape("", null)[1];if (null != f) throw this.createILLEGAL();break;
          }default:
          this.index++;}throw this.createILLEGAL();
    }
  }exports.default = Reader;
});
System.registerDynamic("npm:sweet-spec@1.1.0.json", [], true, function() {
  return {
    "main": "dist/term-spec.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:sweet-spec@1.1.0/dist/term-spec.js", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  const Term_16 = Object.create(Object.prototype, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, _descendants: { value: new Map(), writable: false, configurable: false, enumerable: false }, hasDescendant: { value: function (name_110) {
        return this._descendants.has(name_110);
      }, writable: false, configurable: false, enumerable: true }, getDescendant: { value: function (name_111) {
        return this._descendants.get(name_111);
      }, writable: false, configurable: false, enumerable: true }, getAttributes: { value: function () {
        return this._attributes;
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_112) {
        return this._attributes.some(a_113 => a_113.attrName === attr_112);
      }, writable: false, configurable: false, enumerable: true } });
  const BindingWithDefault_17 = Object.create(Term_16, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "init", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_114) {
        return this.getAttributes().some(a_115 => a_115.attrName === attr_114);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(BindingWithDefault_17);
  Term_16._descendants.set("BindingWithDefault", BindingWithDefault_17);
  const BindingIdentifier_18 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_116) {
        return this.getAttributes().some(a_117 => a_117.attrName === attr_116);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(BindingIdentifier_18);
  Term_16._descendants.set("BindingIdentifier", BindingIdentifier_18);
  const ArrayBinding_19 = Object.create(Term_16, { _attributes: { value: [{ attrName: "elements", attrType: { name: "any" } }, { attrName: "restElement", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_118) {
        return this.getAttributes().some(a_119 => a_119.attrName === attr_118);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ArrayBinding_19);
  Term_16._descendants.set("ArrayBinding", ArrayBinding_19);
  const ObjectBinding_20 = Object.create(Term_16, { _attributes: { value: [{ attrName: "properties", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_120) {
        return this.getAttributes().some(a_121 => a_121.attrName === attr_120);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ObjectBinding_20);
  Term_16._descendants.set("ObjectBinding", ObjectBinding_20);
  const BindingPropertyIdentifier_21 = Object.create(Term_16, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "init", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_122) {
        return this.getAttributes().some(a_123 => a_123.attrName === attr_122);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(BindingPropertyIdentifier_21);
  Term_16._descendants.set("BindingPropertyIdentifier", BindingPropertyIdentifier_21);
  const BindingPropertyProperty_22 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "binding", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_124) {
        return this.getAttributes().some(a_125 => a_125.attrName === attr_124);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(BindingPropertyProperty_22);
  Term_16._descendants.set("BindingPropertyProperty", BindingPropertyProperty_22);
  const Statement_23 = Object.create(Term_16, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_126) {
        return this.getAttributes().some(a_127 => a_127.attrName === attr_126);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Statement_23);
  Term_16._descendants.set("Statement", Statement_23);
  const Expression_24 = Object.create(Term_16, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_128) {
        return this.getAttributes().some(a_129 => a_129.attrName === attr_128);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Expression_24);
  Term_16._descendants.set("Expression", Expression_24);
  const ClassExpression_25 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "super", attrType: { name: "any" } }, { attrName: "elements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_130) {
        return this.getAttributes().some(a_131 => a_131.attrName === attr_130);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ClassExpression_25);
  Expression_24._descendants.set("ClassExpression", ClassExpression_25);
  const ClassDeclaration_26 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "super", attrType: { name: "any" } }, { attrName: "elements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_132) {
        return this.getAttributes().some(a_133 => a_133.attrName === attr_132);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ClassDeclaration_26);
  Statement_23._descendants.set("ClassDeclaration", ClassDeclaration_26);
  const ClassElement_27 = Object.create(Term_16, { _attributes: { value: [{ attrName: "isStatic", attrType: { name: "any" } }, { attrName: "method", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_134) {
        return this.getAttributes().some(a_135 => a_135.attrName === attr_134);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ClassElement_27);
  Term_16._descendants.set("ClassElement", ClassElement_27);
  const Module_28 = Object.create(Term_16, { _attributes: { value: [{ attrName: "directives", attrType: { name: "any" } }, { attrName: "items", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_136) {
        return this.getAttributes().some(a_137 => a_137.attrName === attr_136);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Module_28);
  Term_16._descendants.set("Module", Module_28);
  const Import_29 = Object.create(Term_16, { _attributes: { value: [{ attrName: "moduleSpecifier", attrType: { name: "any" } }, { attrName: "defaultBinding", attrType: { name: "any" } }, { attrName: "namedImports", attrType: { name: "any" } }, { attrName: "forSyntax", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_138) {
        return this.getAttributes().some(a_139 => a_139.attrName === attr_138);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Import_29);
  Term_16._descendants.set("Import", Import_29);
  const ImportNamespace_30 = Object.create(Term_16, { _attributes: { value: [{ attrName: "moduleSpecifier", attrType: { name: "any" } }, { attrName: "defaultBinding", attrType: { name: "any" } }, { attrName: "namespaceBinding", attrType: { name: "any" } }, { attrName: "forSyntax", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_140) {
        return this.getAttributes().some(a_141 => a_141.attrName === attr_140);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ImportNamespace_30);
  Term_16._descendants.set("ImportNamespace", ImportNamespace_30);
  const ImportSpecifier_31 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "binding", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_142) {
        return this.getAttributes().some(a_143 => a_143.attrName === attr_142);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ImportSpecifier_31);
  Term_16._descendants.set("ImportSpecifier", ImportSpecifier_31);
  const ExportAllFrom_32 = Object.create(Term_16, { _attributes: { value: [{ attrName: "moduleSpecifier", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_144) {
        return this.getAttributes().some(a_145 => a_145.attrName === attr_144);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ExportAllFrom_32);
  Term_16._descendants.set("ExportAllFrom", ExportAllFrom_32);
  const ExportFrom_33 = Object.create(Term_16, { _attributes: { value: [{ attrName: "namedExports", attrType: { name: "any" } }, { attrName: "moduleSpecifier", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_146) {
        return this.getAttributes().some(a_147 => a_147.attrName === attr_146);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ExportFrom_33);
  Term_16._descendants.set("ExportFrom", ExportFrom_33);
  const Export_34 = Object.create(Term_16, { _attributes: { value: [{ attrName: "declaration", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_148) {
        return this.getAttributes().some(a_149 => a_149.attrName === attr_148);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Export_34);
  Term_16._descendants.set("Export", Export_34);
  const ExportDefault_35 = Object.create(Term_16, { _attributes: { value: [{ attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_150) {
        return this.getAttributes().some(a_151 => a_151.attrName === attr_150);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ExportDefault_35);
  Term_16._descendants.set("ExportDefault", ExportDefault_35);
  const ExportSpecifier_36 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "exportedName", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_152) {
        return this.getAttributes().some(a_153 => a_153.attrName === attr_152);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ExportSpecifier_36);
  Term_16._descendants.set("ExportSpecifier", ExportSpecifier_36);
  const Method_37 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }, { attrName: "isGenerator", attrType: { name: "any" } }, { attrName: "params", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_154) {
        return this.getAttributes().some(a_155 => a_155.attrName === attr_154);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Method_37);
  Term_16._descendants.set("Method", Method_37);
  const Getter_38 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_156) {
        return this.getAttributes().some(a_157 => a_157.attrName === attr_156);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Getter_38);
  Term_16._descendants.set("Getter", Getter_38);
  const Setter_39 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }, { attrName: "param", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_158) {
        return this.getAttributes().some(a_159 => a_159.attrName === attr_158);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Setter_39);
  Term_16._descendants.set("Setter", Setter_39);
  const DataProperty_40 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_160) {
        return this.getAttributes().some(a_161 => a_161.attrName === attr_160);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(DataProperty_40);
  Term_16._descendants.set("DataProperty", DataProperty_40);
  const ShorthandProperty_41 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_162) {
        return this.getAttributes().some(a_163 => a_163.attrName === attr_162);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ShorthandProperty_41);
  Term_16._descendants.set("ShorthandProperty", ShorthandProperty_41);
  const StaticPropertyName_42 = Object.create(Term_16, { _attributes: { value: [{ attrName: "value", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_164) {
        return this.getAttributes().some(a_165 => a_165.attrName === attr_164);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(StaticPropertyName_42);
  Term_16._descendants.set("StaticPropertyName", StaticPropertyName_42);
  const ComputedPropertyName_43 = Object.create(Term_16, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_166) {
        return this.getAttributes().some(a_167 => a_167.attrName === attr_166);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(ComputedPropertyName_43);
  Term_16._descendants.set("ComputedPropertyName", ComputedPropertyName_43);
  const LiteralBooleanExpression_44 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "value", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_168) {
        return this.getAttributes().some(a_169 => a_169.attrName === attr_168);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralBooleanExpression_44);
  Expression_24._descendants.set("LiteralBooleanExpression", LiteralBooleanExpression_44);
  const LiteralInfinityExpression_45 = Object.create(Expression_24, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_170) {
        return this.getAttributes().some(a_171 => a_171.attrName === attr_170);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralInfinityExpression_45);
  Expression_24._descendants.set("LiteralInfinityExpression", LiteralInfinityExpression_45);
  const LiteralNullExpression_46 = Object.create(Expression_24, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_172) {
        return this.getAttributes().some(a_173 => a_173.attrName === attr_172);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralNullExpression_46);
  Expression_24._descendants.set("LiteralNullExpression", LiteralNullExpression_46);
  const LiteralNumericExpression_47 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "value", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_174) {
        return this.getAttributes().some(a_175 => a_175.attrName === attr_174);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralNumericExpression_47);
  Expression_24._descendants.set("LiteralNumericExpression", LiteralNumericExpression_47);
  const LiteralRegExpExpression_48 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "pattern", attrType: { name: "any" } }, { attrName: "flags", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_176) {
        return this.getAttributes().some(a_177 => a_177.attrName === attr_176);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralRegExpExpression_48);
  Expression_24._descendants.set("LiteralRegExpExpression", LiteralRegExpExpression_48);
  const LiteralStringExpression_49 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "value", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_178) {
        return this.getAttributes().some(a_179 => a_179.attrName === attr_178);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(LiteralStringExpression_49);
  Expression_24._descendants.set("LiteralStringExpression", LiteralStringExpression_49);
  const ArrayExpression_50 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "elements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_180) {
        return this.getAttributes().some(a_181 => a_181.attrName === attr_180);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ArrayExpression_50);
  Expression_24._descendants.set("ArrayExpression", ArrayExpression_50);
  const ArrowExpression_51 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "params", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_182) {
        return this.getAttributes().some(a_183 => a_183.attrName === attr_182);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ArrowExpression_51);
  Expression_24._descendants.set("ArrowExpression", ArrowExpression_51);
  const AssignmentExpression_52 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_184) {
        return this.getAttributes().some(a_185 => a_185.attrName === attr_184);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(AssignmentExpression_52);
  Expression_24._descendants.set("AssignmentExpression", AssignmentExpression_52);
  const BinaryExpression_53 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "operator", attrType: { name: "any" } }, { attrName: "left", attrType: { name: "any" } }, { attrName: "right", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_186) {
        return this.getAttributes().some(a_187 => a_187.attrName === attr_186);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(BinaryExpression_53);
  Expression_24._descendants.set("BinaryExpression", BinaryExpression_53);
  const CallExpression_54 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "callee", attrType: { name: "any" } }, { attrName: "arguments", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_188) {
        return this.getAttributes().some(a_189 => a_189.attrName === attr_188);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(CallExpression_54);
  Expression_24._descendants.set("CallExpression", CallExpression_54);
  const ComputedAssignmentExpression_55 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "operator", attrType: { name: "any" } }, { attrName: "binding", attrType: { name: "any" } }, { attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_190) {
        return this.getAttributes().some(a_191 => a_191.attrName === attr_190);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ComputedAssignmentExpression_55);
  Expression_24._descendants.set("ComputedAssignmentExpression", ComputedAssignmentExpression_55);
  const ComputedMemberExpression_56 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "object", attrType: { name: "any" } }, { attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_192) {
        return this.getAttributes().some(a_193 => a_193.attrName === attr_192);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ComputedMemberExpression_56);
  Expression_24._descendants.set("ComputedMemberExpression", ComputedMemberExpression_56);
  const ConditionalExpression_57 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "test", attrType: { name: "any" } }, { attrName: "consequent", attrType: { name: "any" } }, { attrName: "alternate", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_194) {
        return this.getAttributes().some(a_195 => a_195.attrName === attr_194);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ConditionalExpression_57);
  Expression_24._descendants.set("ConditionalExpression", ConditionalExpression_57);
  const FunctionExpression_58 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "isGenerator", attrType: { name: "any" } }, { attrName: "params", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_196) {
        return this.getAttributes().some(a_197 => a_197.attrName === attr_196);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(FunctionExpression_58);
  Expression_24._descendants.set("FunctionExpression", FunctionExpression_58);
  const IdentifierExpression_59 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_198) {
        return this.getAttributes().some(a_199 => a_199.attrName === attr_198);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(IdentifierExpression_59);
  Expression_24._descendants.set("IdentifierExpression", IdentifierExpression_59);
  const NewExpression_60 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "callee", attrType: { name: "any" } }, { attrName: "arguments", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_200) {
        return this.getAttributes().some(a_201 => a_201.attrName === attr_200);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(NewExpression_60);
  Expression_24._descendants.set("NewExpression", NewExpression_60);
  const NewTargetExpression_61 = Object.create(Expression_24, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_202) {
        return this.getAttributes().some(a_203 => a_203.attrName === attr_202);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(NewTargetExpression_61);
  Expression_24._descendants.set("NewTargetExpression", NewTargetExpression_61);
  const ObjectExpression_62 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "properties", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_204) {
        return this.getAttributes().some(a_205 => a_205.attrName === attr_204);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ObjectExpression_62);
  Expression_24._descendants.set("ObjectExpression", ObjectExpression_62);
  const UnaryExpression_63 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "operator", attrType: { name: "any" } }, { attrName: "operand", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_206) {
        return this.getAttributes().some(a_207 => a_207.attrName === attr_206);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(UnaryExpression_63);
  Expression_24._descendants.set("UnaryExpression", UnaryExpression_63);
  const StaticMemberExpression_64 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "object", attrType: { name: "any" } }, { attrName: "property", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_208) {
        return this.getAttributes().some(a_209 => a_209.attrName === attr_208);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(StaticMemberExpression_64);
  Expression_24._descendants.set("StaticMemberExpression", StaticMemberExpression_64);
  const TemplateExpression_65 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "tag", attrType: { name: "any" } }, { attrName: "elements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_210) {
        return this.getAttributes().some(a_211 => a_211.attrName === attr_210);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(TemplateExpression_65);
  Expression_24._descendants.set("TemplateExpression", TemplateExpression_65);
  const ThisExpression_66 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "stx", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_212) {
        return this.getAttributes().some(a_213 => a_213.attrName === attr_212);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ThisExpression_66);
  Expression_24._descendants.set("ThisExpression", ThisExpression_66);
  const UpdateExpression_67 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "isPrefix", attrType: { name: "any" } }, { attrName: "operator", attrType: { name: "any" } }, { attrName: "operand", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_214) {
        return this.getAttributes().some(a_215 => a_215.attrName === attr_214);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(UpdateExpression_67);
  Expression_24._descendants.set("UpdateExpression", UpdateExpression_67);
  const YieldExpression_68 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_216) {
        return this.getAttributes().some(a_217 => a_217.attrName === attr_216);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(YieldExpression_68);
  Expression_24._descendants.set("YieldExpression", YieldExpression_68);
  const YieldGeneratorExpression_69 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_218) {
        return this.getAttributes().some(a_219 => a_219.attrName === attr_218);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(YieldGeneratorExpression_69);
  Expression_24._descendants.set("YieldGeneratorExpression", YieldGeneratorExpression_69);
  const ParenthesizedExpression_70 = Object.create(Expression_24, { _attributes: { value: [{ attrName: "inner", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Expression_24.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_220) {
        return this.getAttributes().some(a_221 => a_221.attrName === attr_220);
      }, writable: false, configurable: false, enumerable: true } });
  Expression_24._children.push(ParenthesizedExpression_70);
  Expression_24._descendants.set("ParenthesizedExpression", ParenthesizedExpression_70);
  const BlockStatement_71 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "block", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_222) {
        return this.getAttributes().some(a_223 => a_223.attrName === attr_222);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(BlockStatement_71);
  Statement_23._descendants.set("BlockStatement", BlockStatement_71);
  const BreakStatement_72 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "label", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_224) {
        return this.getAttributes().some(a_225 => a_225.attrName === attr_224);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(BreakStatement_72);
  Statement_23._descendants.set("BreakStatement", BreakStatement_72);
  const ContinueStatement_73 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "label", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_226) {
        return this.getAttributes().some(a_227 => a_227.attrName === attr_226);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ContinueStatement_73);
  Statement_23._descendants.set("ContinueStatement", ContinueStatement_73);
  const CompoundAssignmentExpression_74 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "operator", attrType: { name: "any" } }, { attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_228) {
        return this.getAttributes().some(a_229 => a_229.attrName === attr_228);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(CompoundAssignmentExpression_74);
  Statement_23._descendants.set("CompoundAssignmentExpression", CompoundAssignmentExpression_74);
  const DebuggerStatement_75 = Object.create(Statement_23, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_230) {
        return this.getAttributes().some(a_231 => a_231.attrName === attr_230);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(DebuggerStatement_75);
  Statement_23._descendants.set("DebuggerStatement", DebuggerStatement_75);
  const DoWhileStatement_76 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "test", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_232) {
        return this.getAttributes().some(a_233 => a_233.attrName === attr_232);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(DoWhileStatement_76);
  Statement_23._descendants.set("DoWhileStatement", DoWhileStatement_76);
  const EmptyStatement_77 = Object.create(Statement_23, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_234) {
        return this.getAttributes().some(a_235 => a_235.attrName === attr_234);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(EmptyStatement_77);
  Statement_23._descendants.set("EmptyStatement", EmptyStatement_77);
  const ExpressionStatement_78 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_236) {
        return this.getAttributes().some(a_237 => a_237.attrName === attr_236);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ExpressionStatement_78);
  Statement_23._descendants.set("ExpressionStatement", ExpressionStatement_78);
  const ForInStatement_79 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "left", attrType: { name: "any" } }, { attrName: "right", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_238) {
        return this.getAttributes().some(a_239 => a_239.attrName === attr_238);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ForInStatement_79);
  Statement_23._descendants.set("ForInStatement", ForInStatement_79);
  const ForOfStatement_80 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "left", attrType: { name: "any" } }, { attrName: "right", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_240) {
        return this.getAttributes().some(a_241 => a_241.attrName === attr_240);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ForOfStatement_80);
  Statement_23._descendants.set("ForOfStatement", ForOfStatement_80);
  const ForStatement_81 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "init", attrType: { name: "any" } }, { attrName: "test", attrType: { name: "any" } }, { attrName: "update", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_242) {
        return this.getAttributes().some(a_243 => a_243.attrName === attr_242);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ForStatement_81);
  Statement_23._descendants.set("ForStatement", ForStatement_81);
  const IfStatement_82 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "test", attrType: { name: "any" } }, { attrName: "consequent", attrType: { name: "any" } }, { attrName: "alternate", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_244) {
        return this.getAttributes().some(a_245 => a_245.attrName === attr_244);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(IfStatement_82);
  Statement_23._descendants.set("IfStatement", IfStatement_82);
  const LabeledStatement_83 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "label", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_246) {
        return this.getAttributes().some(a_247 => a_247.attrName === attr_246);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(LabeledStatement_83);
  Statement_23._descendants.set("LabeledStatement", LabeledStatement_83);
  const ReturnStatement_84 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_248) {
        return this.getAttributes().some(a_249 => a_249.attrName === attr_248);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ReturnStatement_84);
  Statement_23._descendants.set("ReturnStatement", ReturnStatement_84);
  const SwitchStatement_85 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "discriminant", attrType: { name: "any" } }, { attrName: "cases", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_250) {
        return this.getAttributes().some(a_251 => a_251.attrName === attr_250);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(SwitchStatement_85);
  Statement_23._descendants.set("SwitchStatement", SwitchStatement_85);
  const SwitchStatementWithDefault_86 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "discriminant", attrType: { name: "any" } }, { attrName: "preDefaultCases", attrType: { name: "any" } }, { attrName: "defaultCase", attrType: { name: "any" } }, { attrName: "postDefaultCases", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_252) {
        return this.getAttributes().some(a_253 => a_253.attrName === attr_252);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(SwitchStatementWithDefault_86);
  Statement_23._descendants.set("SwitchStatementWithDefault", SwitchStatementWithDefault_86);
  const ThrowStatement_87 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_254) {
        return this.getAttributes().some(a_255 => a_255.attrName === attr_254);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(ThrowStatement_87);
  Statement_23._descendants.set("ThrowStatement", ThrowStatement_87);
  const TryCatchStatement_88 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "body", attrType: { name: "any" } }, { attrName: "catchClause", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_256) {
        return this.getAttributes().some(a_257 => a_257.attrName === attr_256);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(TryCatchStatement_88);
  Statement_23._descendants.set("TryCatchStatement", TryCatchStatement_88);
  const TryFinallyStatement_89 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "body", attrType: { name: "any" } }, { attrName: "catchClause", attrType: { name: "any" } }, { attrName: "finalizer", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_258) {
        return this.getAttributes().some(a_259 => a_259.attrName === attr_258);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(TryFinallyStatement_89);
  Statement_23._descendants.set("TryFinallyStatement", TryFinallyStatement_89);
  const VariableDeclarationStatement_90 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "declaration", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_260) {
        return this.getAttributes().some(a_261 => a_261.attrName === attr_260);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(VariableDeclarationStatement_90);
  Statement_23._descendants.set("VariableDeclarationStatement", VariableDeclarationStatement_90);
  const WithStatement_91 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "object", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_262) {
        return this.getAttributes().some(a_263 => a_263.attrName === attr_262);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(WithStatement_91);
  Statement_23._descendants.set("WithStatement", WithStatement_91);
  const WhileStatement_92 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "test", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_264) {
        return this.getAttributes().some(a_265 => a_265.attrName === attr_264);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(WhileStatement_92);
  Statement_23._descendants.set("WhileStatement", WhileStatement_92);
  const Pragma_93 = Object.create(Term_16, { _attributes: { value: [{ attrName: "kind", attrType: { name: "any" } }, { attrName: "items", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_266) {
        return this.getAttributes().some(a_267 => a_267.attrName === attr_266);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Pragma_93);
  Term_16._descendants.set("Pragma", Pragma_93);
  const Block_94 = Object.create(Term_16, { _attributes: { value: [{ attrName: "statements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_268) {
        return this.getAttributes().some(a_269 => a_269.attrName === attr_268);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Block_94);
  Term_16._descendants.set("Block", Block_94);
  const CatchClause_95 = Object.create(Term_16, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_270) {
        return this.getAttributes().some(a_271 => a_271.attrName === attr_270);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(CatchClause_95);
  Term_16._descendants.set("CatchClause", CatchClause_95);
  const Directive_96 = Object.create(Term_16, { _attributes: { value: [{ attrName: "rawValue", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_272) {
        return this.getAttributes().some(a_273 => a_273.attrName === attr_272);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Directive_96);
  Term_16._descendants.set("Directive", Directive_96);
  const FormalParameters_97 = Object.create(Term_16, { _attributes: { value: [{ attrName: "items", attrType: { name: "any" } }, { attrName: "rest", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_274) {
        return this.getAttributes().some(a_275 => a_275.attrName === attr_274);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(FormalParameters_97);
  Term_16._descendants.set("FormalParameters", FormalParameters_97);
  const FunctionBody_98 = Object.create(Term_16, { _attributes: { value: [{ attrName: "directives", attrType: { name: "any" } }, { attrName: "statements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_276) {
        return this.getAttributes().some(a_277 => a_277.attrName === attr_276);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(FunctionBody_98);
  Term_16._descendants.set("FunctionBody", FunctionBody_98);
  const FunctionDeclaration_99 = Object.create(Statement_23, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "isGenerator", attrType: { name: "any" } }, { attrName: "params", attrType: { name: "any" } }, { attrName: "body", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Statement_23.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_278) {
        return this.getAttributes().some(a_279 => a_279.attrName === attr_278);
      }, writable: false, configurable: false, enumerable: true } });
  Statement_23._children.push(FunctionDeclaration_99);
  Statement_23._descendants.set("FunctionDeclaration", FunctionDeclaration_99);
  const Script_100 = Object.create(Term_16, { _attributes: { value: [{ attrName: "directives", attrType: { name: "any" } }, { attrName: "statements", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_280) {
        return this.getAttributes().some(a_281 => a_281.attrName === attr_280);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Script_100);
  Term_16._descendants.set("Script", Script_100);
  const SpreadElement_101 = Object.create(Term_16, { _attributes: { value: [{ attrName: "expression", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_282) {
        return this.getAttributes().some(a_283 => a_283.attrName === attr_282);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(SpreadElement_101);
  Term_16._descendants.set("SpreadElement", SpreadElement_101);
  const Super_102 = Object.create(Term_16, { _attributes: { value: [], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_284) {
        return this.getAttributes().some(a_285 => a_285.attrName === attr_284);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(Super_102);
  Term_16._descendants.set("Super", Super_102);
  const SwitchCase_103 = Object.create(Term_16, { _attributes: { value: [{ attrName: "test", attrType: { name: "any" } }, { attrName: "consequent", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_286) {
        return this.getAttributes().some(a_287 => a_287.attrName === attr_286);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(SwitchCase_103);
  Term_16._descendants.set("SwitchCase", SwitchCase_103);
  const SwitchDefault_104 = Object.create(Term_16, { _attributes: { value: [{ attrName: "consequent", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_288) {
        return this.getAttributes().some(a_289 => a_289.attrName === attr_288);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(SwitchDefault_104);
  Term_16._descendants.set("SwitchDefault", SwitchDefault_104);
  const TemplateElement_105 = Object.create(Term_16, { _attributes: { value: [{ attrName: "rawValue", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_290) {
        return this.getAttributes().some(a_291 => a_291.attrName === attr_290);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(TemplateElement_105);
  Term_16._descendants.set("TemplateElement", TemplateElement_105);
  const SyntaxTemplate_106 = Object.create(Term_16, { _attributes: { value: [{ attrName: "template", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_292) {
        return this.getAttributes().some(a_293 => a_293.attrName === attr_292);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(SyntaxTemplate_106);
  Term_16._descendants.set("SyntaxTemplate", SyntaxTemplate_106);
  const SyntaxQuote_107 = Object.create(Term_16, { _attributes: { value: [{ attrName: "name", attrType: { name: "any" } }, { attrName: "template", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_294) {
        return this.getAttributes().some(a_295 => a_295.attrName === attr_294);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(SyntaxQuote_107);
  Term_16._descendants.set("SyntaxQuote", SyntaxQuote_107);
  const VariableDeclaration_108 = Object.create(Term_16, { _attributes: { value: [{ attrName: "kind", attrType: { name: "any" } }, { attrName: "declarators", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_296) {
        return this.getAttributes().some(a_297 => a_297.attrName === attr_296);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(VariableDeclaration_108);
  Term_16._descendants.set("VariableDeclaration", VariableDeclaration_108);
  const VariableDeclarator_109 = Object.create(Term_16, { _attributes: { value: [{ attrName: "binding", attrType: { name: "any" } }, { attrName: "init", attrType: { name: "any" } }], writable: false, configurable: false, enumerable: false }, _children: { value: [], writable: false, configurable: false, enumerable: false }, getAttributes: { value: function () {
        return Term_16.getAttributes().concat(this._attributes);
      }, writable: false, configurable: false, enumerable: true }, hasAttribute: { value: function (attr_298) {
        return this.getAttributes().some(a_299 => a_299.attrName === attr_298);
      }, writable: false, configurable: false, enumerable: true } });
  Term_16._children.push(VariableDeclarator_109);
  Term_16._descendants.set("VariableDeclarator", VariableDeclarator_109);
  exports.default = Term_16;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/terms.js", ["immutable", "ramda", "sweet-spec", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.isImportDeclaration = exports.isCompiletimeStatement = exports.isCompiletimeDeclaration = exports.isSyntaxDeclarationStatement = exports.isExportSyntax = exports.isParenthesizedExpression = exports.isFunctionWithName = exports.isFunctionTerm = exports.isSyntaxrecDeclaration = exports.isSyntaxDeclaration = exports.isEOF = exports.isVariableDeclarator = exports.isVariableDeclaration = exports.isSyntaxTemplate = exports.isTemplateElement = exports.isSwitchDefault = exports.isSwitchCase = exports.isSuper = exports.isSpreadElement = exports.isScript = exports.isFunctionDeclaration = exports.isFunctionBody = exports.isFormalParameters = exports.isDirective = exports.isCatchClause = exports.isBlock = exports.isPragma = exports.isWithStatement = exports.isWhileStatement = exports.isVariableDeclarationStatement = exports.isTryFinallyStatement = exports.isTryCatchStatement = exports.isThrowStatement = exports.isSwitchStatementWithDefault = exports.isSwitchStatement = exports.isReturnStatement = exports.isLabeledStatement = exports.isIfStatement = exports.isForStatement = exports.isForOfStatement = exports.isForInStatement = exports.isExpressionStatement = exports.isEmptyStatement = exports.isDoWhileStatement = exports.isDebuggerStatement = exports.isCompoundAssignmentExpression = exports.isContinueStatement = exports.isBreakStatement = exports.isBlockStatement = exports.isYieldGeneratorExpression = exports.isYieldExpression = exports.isUpdateExpression = exports.isThisExpression = exports.isTemplateExpression = exports.isStaticMemberExpression = exports.isUnaryExpression = exports.isObjectExpression = exports.isNewTargetExpression = exports.isNewExpression = exports.isIdentifierExpression = exports.isFunctionExpression = exports.isConditionalExpression = exports.isComputedMemberExpression = exports.isComputedAssignmentExpression = exports.isCallExpression = exports.isBinaryExpression = exports.isAssignmentExpression = exports.isArrowExpression = exports.isArrayExpression = exports.isLiteralStringExpression = exports.isLiteralRegExpExpression = exports.isLiteralNumericExpression = exports.isLiteralNullExpression = exports.isLiteralInfinityExpression = exports.isLiteralBooleanExpression = exports.isStaticPropertyName = exports.isComputedPropertyName = exports.isShorthandProperty = exports.isDataProperty = exports.isSetter = exports.isGetter = exports.isMethod = exports.isExportSpecifier = exports.isExportDefault = exports.isExport = exports.isExportFrom = exports.isExportAllFrom = exports.isImportSpecifier = exports.isImportNamespace = exports.isImport = exports.isModule = exports.isClassElement = exports.isClassDeclaration = exports.isClassExpression = exports.isBindingPropertyProperty = exports.isBindingPropertyIdentifier = exports.isObjectBinding = exports.isArrayBinding = exports.isBindingIdentifier = exports.isBindingWithDefault = void 0;var _immutable = $__require("immutable"),
      _ramda = $__require("ramda"),
      R = _interopRequireWildcard(_ramda),
      _sweetSpec = $__require("sweet-spec"),
      _sweetSpec2 = _interopRequireDefault(_sweetSpec);function _interopRequireDefault(b) {
    return b && b.__esModule ? b : { default: b };
  }function _interopRequireWildcard(b) {
    if (b && b.__esModule) return b;var c = {};if (null != b) for (var d in b) Object.prototype.hasOwnProperty.call(b, d) && (c[d] = b[d]);return c.default = b, c;
  }const attrName = b => b.attrName;class Term {
    constructor(b, c) {
      let d = _sweetSpec2.default.getDescendant(b);if (null == d) throw new Error(`Unknown term: ${b}`);this.type = b, this.loc = null, this.spec = d;let e = Object.keys(c),
          g = d.getAttributes().map(attrName),
          h = R.symmetricDifference(e, g);if (0 !== h.length) throw new Error(`Unexpected properties for term ${b}: ${h}`);Object.assign(this, c);
    }extend(b) {
      let c = this.spec.getAttributes().map(attrName),
          d = R.pick(c, this),
          e = R.difference(Object.keys(b), c);if (0 < e.length) throw new Error(`Unexpected properties for term ${this.type}: ${e}`);return new Term(this.type, Object.assign(d, b));
    }gen() {
      let b = 0 >= arguments.length || arguments[0] === void 0 || arguments[0],
          c = {};for (let d of this.spec.getAttributes()) if (null == this[d.attrName]) c[d.attrName] = null;else if (this[d.attrName] instanceof Term) c[d.attrName] = this[d.attrName].gen(b);else if (_immutable.List.isList(this[d.attrName])) {
        let e = b ? R.complement(isCompiletimeStatement) : R.both(R.complement(isImportDeclaration), R.complement(isCompiletimeStatement));c[d.attrName] = this[d.attrName].filter(e).map(g => g instanceof Term ? g.gen(b) : g);
      } else c[d.attrName] = this[d.attrName];return new Term(this.type, c);
    }visit(b) {
      let c = {};for (let d of _sweetSpec2.default.getDescendant(this.type).getAttributes()) c[d.attrName] = null == this[d.attrName] ? null : _immutable.List.isList(this[d.attrName]) ? this[d.attrName].map(e => null == e ? null : b(e)) : b(this[d.attrName]);return this.extend(c);
    }addScope(b, c, d, e) {
      return this.visit(g => {
        return "function" == typeof g.addScope ? g.addScope(b, c, d, e) : g;
      });
    }removeScope(b, c) {
      return this.visit(d => {
        return "function" == typeof d.removeScope ? d.removeScope(b, c) : d;
      });
    }lineNumber() {
      for (let b of _sweetSpec2.default.getDescendant(this.type).getAttributes()) if (typeof this[b.attrName] && "function" === this[b.attrName].lineNumber) return this[b.attrName].lineNumber();
    }setLineNumber(b) {
      let c = {};for (let d of _sweetSpec2.default.getDescendant(this.type).getAttributes()) c[d.attrName] = null == this[d.attrName] ? null : "function" == typeof this[d.attrName].setLineNumber ? this[d.attrName].setLineNumber(b) : _immutable.List.isList(this[d.attrName]) ? this[d.attrName].map(e => e.setLineNumber(b)) : this[d.attrName];return new Term(this.type, c);
    }
  }exports.default = Term;const isBindingWithDefault = exports.isBindingWithDefault = R.whereEq({ type: "BindingWithDefault" }),
        isBindingIdentifier = exports.isBindingIdentifier = R.whereEq({ type: "BindingIdentifier" }),
        isArrayBinding = exports.isArrayBinding = R.whereEq({ type: "ArrayBinding" }),
        isObjectBinding = exports.isObjectBinding = R.whereEq({ type: "ObjectBinding" }),
        isBindingPropertyIdentifier = exports.isBindingPropertyIdentifier = R.whereEq({ type: "BindingPropertyIdentifier" }),
        isBindingPropertyProperty = exports.isBindingPropertyProperty = R.whereEq({ type: "BindingPropertyIdentifier" }),
        isClassExpression = exports.isClassExpression = R.whereEq({ type: "ClassExpression" }),
        isClassDeclaration = exports.isClassDeclaration = R.whereEq({ type: "ClassDeclaration" }),
        isClassElement = exports.isClassElement = R.whereEq({ type: "ClassElement" }),
        isModule = exports.isModule = R.whereEq({ type: "Module" }),
        isImport = exports.isImport = R.whereEq({ type: "Import" }),
        isImportNamespace = exports.isImportNamespace = R.whereEq({ type: "ImportNamespace" }),
        isImportSpecifier = exports.isImportSpecifier = R.whereEq({ type: "ImportSpecifier" }),
        isExportAllFrom = exports.isExportAllFrom = R.whereEq({ type: "ExportAllFrom" }),
        isExportFrom = exports.isExportFrom = R.whereEq({ type: "ExportFrom" }),
        isExport = exports.isExport = R.whereEq({ type: "Export" }),
        isExportDefault = exports.isExportDefault = R.whereEq({ type: "ExportDefault" }),
        isExportSpecifier = exports.isExportSpecifier = R.whereEq({ type: "ExportSpecifier" }),
        isMethod = exports.isMethod = R.whereEq({ type: "Method" }),
        isGetter = exports.isGetter = R.whereEq({ type: "Getter" }),
        isSetter = exports.isSetter = R.whereEq({ type: "Setter" }),
        isDataProperty = exports.isDataProperty = R.whereEq({ type: "DataProperty" }),
        isShorthandProperty = exports.isShorthandProperty = R.whereEq({ type: "ShorthandProperty" }),
        isComputedPropertyName = exports.isComputedPropertyName = R.whereEq({ type: "ComputedPropertyName" }),
        isStaticPropertyName = exports.isStaticPropertyName = R.whereEq({ type: "StaticPropertyName" }),
        isLiteralBooleanExpression = exports.isLiteralBooleanExpression = R.whereEq({ type: "LiteralBooleanExpression" }),
        isLiteralInfinityExpression = exports.isLiteralInfinityExpression = R.whereEq({ type: "LiteralInfinityExpression" }),
        isLiteralNullExpression = exports.isLiteralNullExpression = R.whereEq({ type: "LiteralNullExpression" }),
        isLiteralNumericExpression = exports.isLiteralNumericExpression = R.whereEq({ type: "LiteralNumericExpression" }),
        isLiteralRegExpExpression = exports.isLiteralRegExpExpression = R.whereEq({ type: "LiteralRegExpExpression" }),
        isLiteralStringExpression = exports.isLiteralStringExpression = R.whereEq({ type: "LiteralStringExpression" }),
        isArrayExpression = exports.isArrayExpression = R.whereEq({ type: "ArrayExpression" }),
        isArrowExpression = exports.isArrowExpression = R.whereEq({ type: "ArrowExpression" }),
        isAssignmentExpression = exports.isAssignmentExpression = R.whereEq({ type: "AssignmentExpression" }),
        isBinaryExpression = exports.isBinaryExpression = R.whereEq({ type: "BinaryExpression" }),
        isCallExpression = exports.isCallExpression = R.whereEq({ type: "CallExpression" }),
        isComputedAssignmentExpression = exports.isComputedAssignmentExpression = R.whereEq({ type: "ComputedAssignmentExpression" }),
        isComputedMemberExpression = exports.isComputedMemberExpression = R.whereEq({ type: "ComputedMemberExpression" }),
        isConditionalExpression = exports.isConditionalExpression = R.whereEq({ type: "ConditionalExpression" }),
        isFunctionExpression = exports.isFunctionExpression = R.whereEq({ type: "FunctionExpression" }),
        isIdentifierExpression = exports.isIdentifierExpression = R.whereEq({ type: "IdentifierExpression" }),
        isNewExpression = exports.isNewExpression = R.whereEq({ type: "NewExpression" }),
        isNewTargetExpression = exports.isNewTargetExpression = R.whereEq({ type: "NewTargetExpression" }),
        isObjectExpression = exports.isObjectExpression = R.whereEq({ type: "ObjectExpression" }),
        isUnaryExpression = exports.isUnaryExpression = R.whereEq({ type: "UnaryExpression" }),
        isStaticMemberExpression = exports.isStaticMemberExpression = R.whereEq({ type: "StaticMemberExpression" }),
        isTemplateExpression = exports.isTemplateExpression = R.whereEq({ type: "TemplateExpression" }),
        isThisExpression = exports.isThisExpression = R.whereEq({ type: "ThisExpression" }),
        isUpdateExpression = exports.isUpdateExpression = R.whereEq({ type: "UpdateExpression" }),
        isYieldExpression = exports.isYieldExpression = R.whereEq({ type: "YieldExpression" }),
        isYieldGeneratorExpression = exports.isYieldGeneratorExpression = R.whereEq({ type: "YieldGeneratorExpression" }),
        isBlockStatement = exports.isBlockStatement = R.whereEq({ type: "BlockStatement" }),
        isBreakStatement = exports.isBreakStatement = R.whereEq({ type: "BreakStatement" }),
        isContinueStatement = exports.isContinueStatement = R.whereEq({ type: "ContinueStatement" }),
        isCompoundAssignmentExpression = exports.isCompoundAssignmentExpression = R.whereEq({ type: "CompoundAssignmentExpression" }),
        isDebuggerStatement = exports.isDebuggerStatement = R.whereEq({ type: "DebuggerStatement" }),
        isDoWhileStatement = exports.isDoWhileStatement = R.whereEq({ type: "DoWhileStatement" }),
        isEmptyStatement = exports.isEmptyStatement = R.whereEq({ type: "EmptyStatement" }),
        isExpressionStatement = exports.isExpressionStatement = R.whereEq({ type: "ExpressionStatement" }),
        isForInStatement = exports.isForInStatement = R.whereEq({ type: "ForInStatement" }),
        isForOfStatement = exports.isForOfStatement = R.whereEq({ type: "ForOfStatement" }),
        isForStatement = exports.isForStatement = R.whereEq({ type: "ForStatement" }),
        isIfStatement = exports.isIfStatement = R.whereEq({ type: "IfStatement" }),
        isLabeledStatement = exports.isLabeledStatement = R.whereEq({ type: "LabeledStatement" }),
        isReturnStatement = exports.isReturnStatement = R.whereEq({ type: "ReturnStatement" }),
        isSwitchStatement = exports.isSwitchStatement = R.whereEq({ type: "SwitchStatement" }),
        isSwitchStatementWithDefault = exports.isSwitchStatementWithDefault = R.whereEq({ type: "SwitchStatementWithDefault" }),
        isThrowStatement = exports.isThrowStatement = R.whereEq({ type: "ThrowStatement" }),
        isTryCatchStatement = exports.isTryCatchStatement = R.whereEq({ type: "TryCatchStatement" }),
        isTryFinallyStatement = exports.isTryFinallyStatement = R.whereEq({ type: "TryFinallyStatement" }),
        isVariableDeclarationStatement = exports.isVariableDeclarationStatement = R.whereEq({ type: "VariableDeclarationStatement" }),
        isWhileStatement = exports.isWhileStatement = R.whereEq({ type: "WhileStatement" }),
        isWithStatement = exports.isWithStatement = R.whereEq({ type: "WithStatement" }),
        isPragma = exports.isPragma = R.whereEq({ type: "Pragma" }),
        isBlock = exports.isBlock = R.whereEq({ type: "Block" }),
        isCatchClause = exports.isCatchClause = R.whereEq({ type: "CatchClause" }),
        isDirective = exports.isDirective = R.whereEq({ type: "Directive" }),
        isFormalParameters = exports.isFormalParameters = R.whereEq({ type: "FormalParameters" }),
        isFunctionBody = exports.isFunctionBody = R.whereEq({ type: "FunctionBody" }),
        isFunctionDeclaration = exports.isFunctionDeclaration = R.whereEq({ type: "FunctionDeclaration" }),
        isScript = exports.isScript = R.whereEq({ type: "Script" }),
        isSpreadElement = exports.isSpreadElement = R.whereEq({ type: "SpreadElement" }),
        isSuper = exports.isSuper = R.whereEq({ type: "Super" }),
        isSwitchCase = exports.isSwitchCase = R.whereEq({ type: "SwitchCase" }),
        isSwitchDefault = exports.isSwitchDefault = R.whereEq({ type: "SwitchDefault" }),
        isTemplateElement = exports.isTemplateElement = R.whereEq({ type: "TemplateElement" }),
        isSyntaxTemplate = exports.isSyntaxTemplate = R.whereEq({ type: "SyntaxTemplate" }),
        isVariableDeclaration = exports.isVariableDeclaration = R.whereEq({ type: "VariableDeclaration" }),
        isVariableDeclarator = exports.isVariableDeclarator = R.whereEq({ type: "VariableDeclarator" }),
        isEOF = exports.isEOF = R.whereEq({ type: "EOF" }),
        isSyntaxDeclaration = exports.isSyntaxDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: "syntax" })),
        isSyntaxrecDeclaration = exports.isSyntaxrecDeclaration = R.both(isVariableDeclaration, R.whereEq({ kind: "syntaxrec" })),
        isFunctionTerm = exports.isFunctionTerm = R.either(isFunctionDeclaration, isFunctionExpression),
        isFunctionWithName = exports.isFunctionWithName = R.and(isFunctionTerm, R.complement(R.where({ name: R.isNil }))),
        isParenthesizedExpression = exports.isParenthesizedExpression = R.whereEq({ type: "ParenthesizedExpression" }),
        isExportSyntax = exports.isExportSyntax = R.both(isExport, b => R.or(isSyntaxDeclaration(b.declaration), isSyntaxrecDeclaration(b.declaration))),
        isSyntaxDeclarationStatement = exports.isSyntaxDeclarationStatement = R.both(isVariableDeclarationStatement, b => isCompiletimeDeclaration(b.declaration)),
        isCompiletimeDeclaration = exports.isCompiletimeDeclaration = R.either(isSyntaxDeclaration, isSyntaxrecDeclaration),
        isCompiletimeStatement = exports.isCompiletimeStatement = b => {
    return b instanceof Term && isVariableDeclarationStatement(b) && isCompiletimeDeclaration(b.declaration);
  },
        isImportDeclaration = exports.isImportDeclaration = R.either(isImport, isImportNamespace);
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/operators.js', ['process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.operatorLt = operatorLt, exports.getOperatorPrec = getOperatorPrec, exports.getOperatorAssoc = getOperatorAssoc, exports.isUnaryOperator = isUnaryOperator, exports.isOperator = isOperator;const unaryOperators = { '+': !0, '-': !0, '!': !0, '~': !0, '++': !0, '--': !0, 'typeof': !0, 'void': !0, 'delete': !0 },
        binaryOperatorPrecedence = { '*': 13, '/': 13, '%': 13, '+': 12, '-': 12, '>>': 11, '<<': 11, '>>>': 11, '<': 10, '<=': 10, '>': 10, '>=': 10, 'in': 10, 'instanceof': 10, '==': 9, '!=': 9, '===': 9, '!==': 9, '&': 8, '^': 7, '|': 6, '&&': 5, '||': 4 };var operatorAssoc = { '*': 'left', '/': 'left', '%': 'left', '+': 'left', '-': 'left', '>>': 'left', '<<': 'left', '>>>': 'left', '<': 'left', '<=': 'left', '>': 'left', '>=': 'left', 'in': 'left', 'instanceof': 'left', '==': 'left', '!=': 'left', '===': 'left', '!==': 'left', '&': 'left', '^': 'left', '|': 'left', '&&': 'left', '||': 'left' };function operatorLt(a, b, c) {
    return 'left' === c ? a < b : a <= b;
  }function getOperatorPrec(a) {
    return binaryOperatorPrecedence[a];
  }function getOperatorAssoc(a) {
    return operatorAssoc[a];
  }function isUnaryOperator(a) {
    return (a.match('punctuator') || a.match('identifier') || a.match('keyword')) && unaryOperators.hasOwnProperty(a.val());
  }function isOperator(a) {
    return (a.match('punctuator') || a.match('identifier') || a.match('keyword')) && (binaryOperatorPrecedence.hasOwnProperty(a) || unaryOperators.hasOwnProperty(a.val()));
  }
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/enforester.js", ["./terms", "ramda-fantasy", "./transforms", "immutable", "./errors", "./operators", "./syntax", "./scope", "./load-syntax", "./macro-context", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Enforester = void 0;var _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms),
      _ramdaFantasy = $__require("ramda-fantasy"),
      _transforms = $__require("./transforms"),
      _immutable = $__require("immutable"),
      _errors = $__require("./errors"),
      _operators = $__require("./operators"),
      _syntax = $__require("./syntax"),
      _syntax2 = _interopRequireDefault(_syntax),
      _scope = $__require("./scope"),
      _loadSyntax = $__require("./load-syntax"),
      _macroContext = $__require("./macro-context"),
      _macroContext2 = _interopRequireDefault(_macroContext);function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }const Just = _ramdaFantasy.Maybe.Just,
        Nothing = _ramdaFantasy.Maybe.Nothing,
        EXPR_LOOP_OPERATOR = {},
        EXPR_LOOP_NO_CHANGE = {},
        EXPR_LOOP_EXPANSION = {};class Enforester {
    constructor(e, r, i) {
      this.done = !1, (0, _errors.assert)(_immutable.List.isList(e), "expecting a list of terms to enforest"), (0, _errors.assert)(_immutable.List.isList(r), "expecting a list of terms to enforest"), (0, _errors.assert)(i, "expecting a context to enforest"), this.term = null, this.rest = e, this.prev = r, this.context = i;
    }peek() {
      let e = 0 >= arguments.length || arguments[0] === void 0 ? 0 : arguments[0];return this.rest.get(e);
    }advance() {
      let e = this.rest.first();return this.rest = this.rest.rest(), e;
    }enforest() {
      let e = 0 >= arguments.length || void 0 === arguments[0] ? "Module" : arguments[0];if (this.term = null, 0 === this.rest.size) return this.done = !0, this.term;if (this.isEOF(this.peek())) return this.term = new _terms2.default("EOF", {}), this.advance(), this.term;let r;return r = "expression" === e ? this.enforestExpressionLoop() : this.enforestModule(), 0 === this.rest.size && (this.done = !0), r;
    }enforestModule() {
      return this.enforestBody();
    }enforestBody() {
      return this.enforestModuleItem();
    }enforestModuleItem() {
      let e = this.peek();return this.isKeyword(e, "import") ? (this.advance(), this.enforestImportDeclaration()) : this.isKeyword(e, "export") ? (this.advance(), this.enforestExportDeclaration()) : this.isIdentifier(e, "#") ? this.enforestLanguagePragma() : this.enforestStatement();
    }enforestLanguagePragma() {
      this.matchIdentifier("#"), this.matchIdentifier("lang");let e = this.matchStringLiteral();return this.consumeSemicolon(), new _terms2.default("Pragma", { kind: "lang", items: _immutable.List.of(e) });
    }enforestExportDeclaration() {
      let e = this.peek();if (this.isPunctuator(e, "*")) {
        this.advance();let r = this.enforestFromClause();return new _terms2.default("ExportAllFrom", { moduleSpecifier: r });
      }if (this.isBraces(e)) {
        let r = this.enforestExportClause(),
            i = null;return this.isIdentifier(this.peek(), "from") && (i = this.enforestFromClause()), new _terms2.default("ExportFrom", { namedExports: r, moduleSpecifier: i });
      }if (this.isKeyword(e, "class")) return new _terms2.default("Export", { declaration: this.enforestClass({ isExpr: !1 }) });if (this.isFnDeclTransform(e)) return new _terms2.default("Export", { declaration: this.enforestFunction({ isExpr: !1, inDefault: !1 }) });if (this.isKeyword(e, "default")) {
        if (this.advance(), this.isFnDeclTransform(this.peek())) return new _terms2.default("ExportDefault", { body: this.enforestFunction({ isExpr: !1, inDefault: !0 }) });if (this.isKeyword(this.peek(), "class")) return new _terms2.default("ExportDefault", { body: this.enforestClass({ isExpr: !1, inDefault: !0 }) });let r = this.enforestExpressionLoop();return this.consumeSemicolon(), new _terms2.default("ExportDefault", { body: r });
      }if (this.isVarDeclTransform(e) || this.isLetDeclTransform(e) || this.isConstDeclTransform(e) || this.isSyntaxrecDeclTransform(e) || this.isSyntaxDeclTransform(e)) return new _terms2.default("Export", { declaration: this.enforestVariableDeclaration() });throw this.createError(e, "unexpected syntax");
    }enforestExportClause() {
      let e = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context),
          r = [];for (; 0 !== e.rest.size;) r.push(e.enforestExportSpecifier()), e.consumeComma();return (0, _immutable.List)(r);
    }enforestExportSpecifier() {
      let e = this.enforestIdentifier();if (this.isIdentifier(this.peek(), "as")) {
        this.advance();let r = this.enforestIdentifier();return new _terms2.default("ExportSpecifier", { name: e, exportedName: r });
      }return new _terms2.default("ExportSpecifier", { name: null, exportedName: e });
    }enforestImportDeclaration() {
      let e = this.peek(),
          r = null,
          i = (0, _immutable.List)(),
          o = !1;if (this.isStringLiteral(e)) {
        let d = this.advance();return this.consumeSemicolon(), new _terms2.default("Import", { defaultBinding: r, namedImports: i, moduleSpecifier: d, forSyntax: o });
      }if ((this.isIdentifier(e) || this.isKeyword(e)) && (r = this.enforestBindingIdentifier(), !this.isPunctuator(this.peek(), ","))) {
        let d = this.enforestFromClause();return this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax") && (this.advance(), this.advance(), o = !0), new _terms2.default("Import", { defaultBinding: r, moduleSpecifier: d, namedImports: (0, _immutable.List)(), forSyntax: o });
      }if (this.consumeComma(), e = this.peek(), this.isBraces(e)) {
        let d = this.enforestNamedImports(),
            f = this.enforestFromClause();return this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax") && (this.advance(), this.advance(), o = !0), new _terms2.default("Import", { defaultBinding: r, forSyntax: o, namedImports: d, moduleSpecifier: f });
      }if (this.isPunctuator(e, "*")) {
        let d = this.enforestNamespaceBinding(),
            f = this.enforestFromClause();return this.isKeyword(this.peek(), "for") && this.isIdentifier(this.peek(1), "syntax") && (this.advance(), this.advance(), o = !0), new _terms2.default("ImportNamespace", { defaultBinding: r, forSyntax: o, namespaceBinding: d, moduleSpecifier: f });
      }throw this.createError(e, "unexpected syntax");
    }enforestNamespaceBinding() {
      return this.matchPunctuator("*"), this.matchIdentifier("as"), this.enforestBindingIdentifier();
    }enforestNamedImports() {
      let e = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context),
          r = [];for (; 0 !== e.rest.size;) r.push(e.enforestImportSpecifiers()), e.consumeComma();return (0, _immutable.List)(r);
    }enforestImportSpecifiers() {
      let e = this.peek(),
          r;if (this.isIdentifier(e) || this.isKeyword(e)) {
        if (r = this.advance(), !this.isIdentifier(this.peek(), "as")) return new _terms2.default("ImportSpecifier", { name: null, binding: new _terms2.default("BindingIdentifier", { name: r }) });this.matchIdentifier("as");
      } else throw this.createError(e, "unexpected token in import specifier");return new _terms2.default("ImportSpecifier", { name: r, binding: this.enforestBindingIdentifier() });
    }enforestFromClause() {
      this.matchIdentifier("from");let e = this.matchStringLiteral();return this.consumeSemicolon(), e;
    }enforestStatementListItem() {
      let e = this.peek();return this.isFnDeclTransform(e) ? this.enforestFunctionDeclaration({ isExpr: !1 }) : this.isKeyword(e, "class") ? this.enforestClass({ isExpr: !1 }) : this.enforestStatement();
    }enforestStatement() {
      let e = this.peek();if (null === this.term && this.isCompiletimeTransform(e) && (this.expandMacro(), e = this.peek()), null === this.term && this.isTerm(e)) return this.advance();if (null === this.term && this.isBraces(e)) return this.enforestBlockStatement();if (null === this.term && this.isWhileTransform(e)) return this.enforestWhileStatement();if (null === this.term && this.isIfTransform(e)) return this.enforestIfStatement();if (null === this.term && this.isForTransform(e)) return this.enforestForStatement();if (null === this.term && this.isSwitchTransform(e)) return this.enforestSwitchStatement();if (null === this.term && this.isBreakTransform(e)) return this.enforestBreakStatement();if (null === this.term && this.isContinueTransform(e)) return this.enforestContinueStatement();if (null === this.term && this.isDoTransform(e)) return this.enforestDoStatement();if (null === this.term && this.isDebuggerTransform(e)) return this.enforestDebuggerStatement();if (null === this.term && this.isWithTransform(e)) return this.enforestWithStatement();if (null === this.term && this.isTryTransform(e)) return this.enforestTryStatement();if (null === this.term && this.isThrowTransform(e)) return this.enforestThrowStatement();if (null === this.term && this.isKeyword(e, "class")) return this.enforestClass({ isExpr: !1 });if (null === this.term && this.isFnDeclTransform(e)) return this.enforestFunctionDeclaration();if (null === this.term && this.isIdentifier(e) && this.isPunctuator(this.peek(1), ":")) return this.enforestLabeledStatement();if (null === this.term && (this.isVarDeclTransform(e) || this.isLetDeclTransform(e) || this.isConstDeclTransform(e) || this.isSyntaxrecDeclTransform(e) || this.isSyntaxDeclTransform(e))) {
        let r = new _terms2.default("VariableDeclarationStatement", { declaration: this.enforestVariableDeclaration() });return this.consumeSemicolon(), r;
      }return null === this.term && this.isReturnStmtTransform(e) ? this.enforestReturnStatement() : null === this.term && this.isPunctuator(e, ";") ? (this.advance(), new _terms2.default("EmptyStatement", {})) : this.enforestExpressionStatement();
    }enforestLabeledStatement() {
      let e = this.matchIdentifier();this.matchPunctuator(":");let r = this.enforestStatement();return new _terms2.default("LabeledStatement", { label: e, body: r });
    }enforestBreakStatement() {
      this.matchKeyword("break");let e = this.peek(),
          r = null;return 0 === this.rest.size || this.isPunctuator(e, ";") ? (this.consumeSemicolon(), new _terms2.default("BreakStatement", { label: r })) : ((this.isIdentifier(e) || this.isKeyword(e, "yield") || this.isKeyword(e, "let")) && (r = this.enforestIdentifier()), this.consumeSemicolon(), new _terms2.default("BreakStatement", { label: r }));
    }enforestTryStatement() {
      this.matchKeyword("try");let e = this.enforestBlock();if (this.isKeyword(this.peek(), "catch")) {
        let r = this.enforestCatchClause();if (this.isKeyword(this.peek(), "finally")) {
          this.advance();let i = this.enforestBlock();return new _terms2.default("TryFinallyStatement", { body: e, catchClause: r, finalizer: i });
        }return new _terms2.default("TryCatchStatement", { body: e, catchClause: r });
      }if (this.isKeyword(this.peek(), "finally")) {
        this.advance();let r = this.enforestBlock();return new _terms2.default("TryFinallyStatement", { body: e, catchClause: null, finalizer: r });
      }throw this.createError(this.peek(), "try with no catch or finally");
    }enforestCatchClause() {
      this.matchKeyword("catch");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = r.enforestBindingTarget(),
          o = this.enforestBlock();return new _terms2.default("CatchClause", { binding: i, body: o });
    }enforestThrowStatement() {
      this.matchKeyword("throw");let e = this.enforestExpression();return this.consumeSemicolon(), new _terms2.default("ThrowStatement", { expression: e });
    }enforestWithStatement() {
      this.matchKeyword("with");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = r.enforestExpression(),
          o = this.enforestStatement();return new _terms2.default("WithStatement", { object: i, body: o });
    }enforestDebuggerStatement() {
      return this.matchKeyword("debugger"), new _terms2.default("DebuggerStatement", {});
    }enforestDoStatement() {
      this.matchKeyword("do");let e = this.enforestStatement();this.matchKeyword("while");let r = this.matchParens(),
          i = new Enforester(r, (0, _immutable.List)(), this.context),
          o = i.enforestExpression();return this.consumeSemicolon(), new _terms2.default("DoWhileStatement", { body: e, test: o });
    }enforestContinueStatement() {
      let e = this.matchKeyword("continue"),
          r = this.peek(),
          i = null;return 0 === this.rest.size || this.isPunctuator(r, ";") ? (this.consumeSemicolon(), new _terms2.default("ContinueStatement", { label: i })) : (this.lineNumberEq(e, r) && (this.isIdentifier(r) || this.isKeyword(r, "yield") || this.isKeyword(r, "let")) && (i = this.enforestIdentifier()), this.consumeSemicolon(), new _terms2.default("ContinueStatement", { label: i }));
    }enforestSwitchStatement() {
      this.matchKeyword("switch");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = r.enforestExpression(),
          o = this.matchCurlies();if (0 === o.size) return new _terms2.default("SwitchStatement", { discriminant: i, cases: (0, _immutable.List)() });r = new Enforester(o, (0, _immutable.List)(), this.context);let d = r.enforestSwitchCases(),
          f = r.peek();if (r.isKeyword(f, "default")) {
        let c = r.enforestSwitchDefault(),
            m = r.enforestSwitchCases();return new _terms2.default("SwitchStatementWithDefault", { discriminant: i, preDefaultCases: d, defaultCase: c, postDefaultCases: m });
      }return new _terms2.default("SwitchStatement", { discriminant: i, cases: d });
    }enforestSwitchCases() {
      let e = [];for (; !(0 === this.rest.size || this.isKeyword(this.peek(), "default"));) e.push(this.enforestSwitchCase());return (0, _immutable.List)(e);
    }enforestSwitchCase() {
      return this.matchKeyword("case"), new _terms2.default("SwitchCase", { test: this.enforestExpression(), consequent: this.enforestSwitchCaseBody() });
    }enforestSwitchCaseBody() {
      return this.matchPunctuator(":"), this.enforestStatementListInSwitchCaseBody();
    }enforestStatementListInSwitchCaseBody() {
      let e = [];for (; !(0 === this.rest.size || this.isKeyword(this.peek(), "default") || this.isKeyword(this.peek(), "case"));) e.push(this.enforestStatementListItem());return (0, _immutable.List)(e);
    }enforestSwitchDefault() {
      return this.matchKeyword("default"), new _terms2.default("SwitchDefault", { consequent: this.enforestSwitchCaseBody() });
    }enforestForStatement() {
      this.matchKeyword("for");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i,
          o,
          d,
          f,
          c,
          m,
          u;if (r.isPunctuator(r.peek(), ";")) return r.advance(), r.isPunctuator(r.peek(), ";") || (o = r.enforestExpression()), r.matchPunctuator(";"), 0 !== r.rest.size && (f = r.enforestExpression()), new _terms2.default("ForStatement", { init: null, test: o, update: f, body: this.enforestStatement() });if (i = r.peek(), r.isVarDeclTransform(i) || r.isLetDeclTransform(i) || r.isConstDeclTransform(i)) {
        if (d = r.enforestVariableDeclaration(), i = r.peek(), this.isKeyword(i, "in") || this.isIdentifier(i, "of")) return this.isKeyword(i, "in") ? (r.advance(), f = r.enforestExpression(), c = "ForInStatement") : this.isIdentifier(i, "of") && (r.advance(), f = r.enforestExpression(), c = "ForOfStatement"), new _terms2.default(c, { left: d, right: f, body: this.enforestStatement() });r.matchPunctuator(";"), r.isPunctuator(r.peek(), ";") ? (r.advance(), o = null) : (o = r.enforestExpression(), r.matchPunctuator(";")), u = r.enforestExpression();
      } else {
        if (this.isKeyword(r.peek(1), "in") || this.isIdentifier(r.peek(1), "of")) {
          m = r.enforestBindingIdentifier();let l = r.advance();return c = this.isKeyword(l, "in") ? "ForInStatement" : "ForOfStatement", f = r.enforestExpression(), new _terms2.default(c, { left: m, right: f, body: this.enforestStatement() });
        }d = r.enforestExpression(), r.matchPunctuator(";"), r.isPunctuator(r.peek(), ";") ? (r.advance(), o = null) : (o = r.enforestExpression(), r.matchPunctuator(";")), u = r.enforestExpression();
      }return new _terms2.default("ForStatement", { init: d, test: o, update: u, body: this.enforestStatement() });
    }enforestIfStatement() {
      this.matchKeyword("if");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = r.peek(),
          o = r.enforestExpression();if (null === o) throw r.createError(i, "expecting an expression");let d = this.enforestStatement(),
          f = null;return this.isKeyword(this.peek(), "else") && (this.advance(), f = this.enforestStatement()), new _terms2.default("IfStatement", { test: o, consequent: d, alternate: f });
    }enforestWhileStatement() {
      this.matchKeyword("while");let e = this.matchParens(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = r.peek(),
          o = r.enforestExpression();if (null === o) throw r.createError(i, "expecting an expression");let d = this.enforestStatement();return new _terms2.default("WhileStatement", { test: o, body: d });
    }enforestBlockStatement() {
      return new _terms2.default("BlockStatement", { block: this.enforestBlock() });
    }enforestBlock() {
      return new _terms2.default("Block", { statements: this.matchCurlies() });
    }enforestClass(e) {
      let r = e.isExpr,
          i = e.inDefault,
          o = this.advance(),
          d = null,
          f = null,
          c = r ? "ClassExpression" : "ClassDeclaration";if (this.isIdentifier(this.peek())) d = this.enforestBindingIdentifier();else if (!r) if (i) d = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("_default", o) });else throw this.createError(this.peek(), "unexpected syntax");this.isKeyword(this.peek(), "extends") && (this.advance(), f = this.enforestExpressionLoop());let m = [],
          u = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context);for (; 0 !== u.rest.size;) {
        if (u.isPunctuator(u.peek(), ";")) {
          u.advance();continue;
        }let y = !1;var l = u.enforestMethodDefinition();let g = l.methodOrKey,
            E = l.kind;if ("identifier" === E && "static" === g.value.val()) {
          y = !0;var h = u.enforestMethodDefinition();g = h.methodOrKey, E = h.kind;
        }if ("method" === E) m.push(new _terms2.default("ClassElement", { isStatic: y, method: g }));else throw this.createError(u.peek(), "Only methods are allowed in classes");
      }return new _terms2.default(c, { name: d, super: f, elements: (0, _immutable.List)(m) });
    }enforestBindingTarget() {
      var e = 0 >= arguments.length || arguments[0] === void 0 ? {} : arguments[0];let r = e.allowPunctuator,
          i = this.peek();if (this.isIdentifier(i) || this.isKeyword(i) || r && this.isPunctuator(i)) return this.enforestBindingIdentifier({ allowPunctuator: r });return this.isBrackets(i) ? this.enforestArrayBinding() : this.isBraces(i) ? this.enforestObjectBinding() : void (0, _errors.assert)(!1, "not implemented yet");
    }enforestObjectBinding() {
      let e = new Enforester(this.matchCurlies(), (0, _immutable.List)(), this.context),
          r = [];for (; 0 !== e.rest.size;) r.push(e.enforestBindingProperty()), e.consumeComma();return new _terms2.default("ObjectBinding", { properties: (0, _immutable.List)(r) });
    }enforestBindingProperty() {
      let e = this.peek();var r = this.enforestPropertyName();let i = r.name,
          o = r.binding;if ((this.isIdentifier(e) || this.isKeyword(e, "let") || this.isKeyword(e, "yield")) && !this.isPunctuator(this.peek(), ":")) {
        let d = null;if (this.isAssign(this.peek())) {
          this.advance();let f = this.enforestExpressionLoop();d = f;
        }return new _terms2.default("BindingPropertyIdentifier", { binding: o, init: d });
      }return this.matchPunctuator(":"), o = this.enforestBindingElement(), new _terms2.default("BindingPropertyProperty", { name: i, binding: o });
    }enforestArrayBinding() {
      let e = this.matchSquares(),
          r = new Enforester(e, (0, _immutable.List)(), this.context),
          i = [],
          o = null;for (; 0 !== r.rest.size;) {
        let d;if (r.isPunctuator(r.peek(), ",")) r.consumeComma(), d = null;else {
          if (r.isPunctuator(r.peek(), "...")) {
            r.advance(), o = r.enforestBindingTarget();break;
          } else d = r.enforestBindingElement();r.consumeComma();
        }i.push(d);
      }return new _terms2.default("ArrayBinding", { elements: (0, _immutable.List)(i), restElement: o });
    }enforestBindingElement() {
      let e = this.enforestBindingTarget();if (this.isAssign(this.peek())) {
        this.advance();let r = this.enforestExpressionLoop();e = new _terms2.default("BindingWithDefault", { binding: e, init: r });
      }return e;
    }enforestBindingIdentifier() {
      var e = 0 >= arguments.length || void 0 === arguments[0] ? {} : arguments[0];let i,
          r = e.allowPunctuator;return i = r && this.isPunctuator(this.peek()) ? this.enforestPunctuator() : this.enforestIdentifier(), new _terms2.default("BindingIdentifier", { name: i });
    }enforestPunctuator() {
      let e = this.peek();if (this.isPunctuator(e)) return this.advance();throw this.createError(e, "expecting a punctuator");
    }enforestIdentifier() {
      let e = this.peek();if (this.isIdentifier(e) || this.isKeyword(e)) return this.advance();throw this.createError(e, "expecting an identifier");
    }enforestReturnStatement() {
      let e = this.advance(),
          r = this.peek();if (0 === this.rest.size || r && !this.lineNumberEq(e, r)) return new _terms2.default("ReturnStatement", { expression: null });let i = null;return this.isPunctuator(r, ";") || (i = this.enforestExpression(), (0, _errors.expect)(null != i, "Expecting an expression to follow return keyword", r, this.rest)), this.consumeSemicolon(), new _terms2.default("ReturnStatement", { expression: i });
    }enforestVariableDeclaration() {
      let e,
          r = this.advance(),
          i = r,
          o = this.context.phase;i && this.context.env.get(i.resolve(o)) === _transforms.VariableDeclTransform ? e = "var" : i && this.context.env.get(i.resolve(o)) === _transforms.LetDeclTransform ? e = "let" : i && this.context.env.get(i.resolve(o)) === _transforms.ConstDeclTransform ? e = "const" : i && this.context.env.get(i.resolve(o)) === _transforms.SyntaxDeclTransform ? e = "syntax" : i && this.context.env.get(i.resolve(o)) === _transforms.SyntaxrecDeclTransform && (e = "syntaxrec");let d = (0, _immutable.List)();for (;;) {
        let f = this.enforestVariableDeclarator({ isSyntax: "syntax" === e || "syntaxrec" === e }),
            c = this.peek();if (d = d.concat(f), this.isPunctuator(c, ",")) this.advance();else break;
      }return new _terms2.default("VariableDeclaration", { kind: e, declarators: d });
    }enforestVariableDeclarator(e) {
      let r = e.isSyntax,
          i = this.enforestBindingTarget({ allowPunctuator: r }),
          o = this.peek(),
          d;if (this.isPunctuator(o, "=")) {
        this.advance();let f = new Enforester(this.rest, (0, _immutable.List)(), this.context);d = f.enforest("expression"), this.rest = f.rest;
      } else d = null;return new _terms2.default("VariableDeclarator", { binding: i, init: d });
    }enforestExpressionStatement() {
      let e = this.rest.get(0),
          r = this.enforestExpression();if (null === r) throw this.createError(e, "not a valid expression");return this.consumeSemicolon(), new _terms2.default("ExpressionStatement", { expression: r });
    }enforestExpression() {
      let e = this.enforestExpressionLoop(),
          r = this.peek();if (this.isPunctuator(r, ",")) for (; 0 !== this.rest.size && !!this.isPunctuator(this.peek(), ",");) {
        let i = this.advance(),
            o = this.enforestExpressionLoop();e = new _terms2.default("BinaryExpression", { left: e, operator: i, right: o });
      }return this.term = null, e;
    }enforestExpressionLoop() {
      this.term = null, this.opCtx = { prec: 0, combine: r => r, stack: (0, _immutable.List)() };do {
        let r = this.enforestAssignmentExpression();if (r === EXPR_LOOP_NO_CHANGE && 0 < this.opCtx.stack.size) {
          this.term = this.opCtx.combine(this.term);var e = this.opCtx.stack.last();let i = e.prec,
              o = e.combine;this.opCtx.prec = i, this.opCtx.combine = o, this.opCtx.stack = this.opCtx.stack.pop();
        } else if (r === EXPR_LOOP_NO_CHANGE) break;else this.term = r === EXPR_LOOP_OPERATOR || r === EXPR_LOOP_EXPANSION ? null : r;
      } while (!0);return this.term;
    }enforestAssignmentExpression() {
      let e = this.peek();if (null === this.term && this.isCompiletimeTransform(e) && (this.expandMacro(), e = this.peek()), null === this.term && this.isTerm(e)) return this.advance();if (null === this.term && this.isKeyword(e, "yield")) return this.enforestYieldExpression();if (null === this.term && this.isKeyword(e, "class")) return this.enforestClass({ isExpr: !0 });if (null === this.term && (this.isIdentifier(e) || this.isParens(e)) && this.isPunctuator(this.peek(1), "=>") && this.lineNumberEq(e, this.peek(1))) return this.enforestArrowExpression();if (null === this.term && this.isSyntaxTemplate(e)) return this.enforestSyntaxTemplate();if (null === this.term && this.isSyntaxQuoteTransform(e)) return this.enforestSyntaxQuote();if (null === this.term && this.isParens(e)) return new _terms2.default("ParenthesizedExpression", { inner: this.advance().inner() });if (null === this.term && (this.isKeyword(e, "this") || this.isIdentifier(e) || this.isKeyword(e, "let") || this.isKeyword(e, "yield") || this.isNumericLiteral(e) || this.isStringLiteral(e) || this.isTemplate(e) || this.isBooleanLiteral(e) || this.isNullLiteral(e) || this.isRegularExpression(e) || this.isFnDeclTransform(e) || this.isBraces(e) || this.isBrackets(e))) return this.enforestPrimaryExpression();if (null === this.term && this.isOperator(e)) return this.enforestUnaryExpression();if (null === this.term && this.isVarBindingTransform(e)) {
        let r = this.getFromCompiletimeEnvironment(e).id;if (r !== e) return this.advance(), this.rest = _immutable.List.of(r).concat(this.rest), EXPR_LOOP_EXPANSION;
      }if (null === this.term && (this.isNewTransform(e) || this.isKeyword(e, "super")) || this.term && (this.isPunctuator(e, ".") && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1))) || this.isBrackets(e) || this.isParens(e))) return this.enforestLeftHandSideExpression({ allowCall: !0 });if (this.term && this.isTemplate(e)) return this.enforestTemplateLiteral();if (this.term && this.isUpdateOperator(e)) return this.enforestUpdateExpression();if (this.term && this.isOperator(e)) return this.enforestBinaryExpression();if (this.term && this.isAssign(e)) {
        let r = this.transformDestructuring(this.term),
            i = this.advance(),
            o = new Enforester(this.rest, (0, _immutable.List)(), this.context),
            d = o.enforest("expression");return this.rest = o.rest, "=" === i.val() ? new _terms2.default("AssignmentExpression", { binding: r, expression: d }) : new _terms2.default("CompoundAssignmentExpression", { binding: r, operator: i.val(), expression: d });
      }return this.term && this.isPunctuator(e, "?") ? this.enforestConditionalExpression() : EXPR_LOOP_NO_CHANGE;
    }enforestPrimaryExpression() {
      let e = this.peek();return null === this.term && this.isKeyword(e, "this") ? this.enforestThisExpression() : null === this.term && (this.isIdentifier(e) || this.isKeyword(e, "let") || this.isKeyword(e, "yield")) ? this.enforestIdentifierExpression() : null === this.term && this.isNumericLiteral(e) ? this.enforestNumericLiteral() : null === this.term && this.isStringLiteral(e) ? this.enforestStringLiteral() : null === this.term && this.isTemplate(e) ? this.enforestTemplateLiteral() : null === this.term && this.isBooleanLiteral(e) ? this.enforestBooleanLiteral() : null === this.term && this.isNullLiteral(e) ? this.enforestNullLiteral() : null === this.term && this.isRegularExpression(e) ? this.enforestRegularExpressionLiteral() : null === this.term && this.isFnDeclTransform(e) ? this.enforestFunctionExpression() : null === this.term && this.isBraces(e) ? this.enforestObjectExpression() : null === this.term && this.isBrackets(e) ? this.enforestArrayExpression() : void (0, _errors.assert)(!1, "Not a primary expression");
    }enforestLeftHandSideExpression(e) {
      let r = e.allowCall,
          i = this.peek();for (this.isKeyword(i, "super") ? (this.advance(), this.term = new _terms2.default("Super", {})) : this.isNewTransform(i) && (this.term = this.enforestNewExpression());;) if (i = this.peek(), this.isParens(i)) {
        if (!r) {
          if (this.term && ((0, _terms.isIdentifierExpression)(this.term) || (0, _terms.isStaticMemberExpression)(this.term) || (0, _terms.isComputedMemberExpression)(this.term))) return this.term;this.term = this.enforestExpressionLoop();
        } else this.term = this.enforestCallExpression();
      } else if (this.isBrackets(i)) this.term = this.term ? this.enforestComputedMemberExpression() : this.enforestPrimaryExpression();else if (this.isPunctuator(i, ".") && (this.isIdentifier(this.peek(1)) || this.isKeyword(this.peek(1)))) this.term = this.enforestStaticMemberExpression();else if (this.isTemplate(i)) this.term = this.enforestTemplateLiteral();else if (this.isBraces(i)) this.term = this.enforestPrimaryExpression();else if (this.isIdentifier(i)) this.term = new _terms2.default("IdentifierExpression", { name: this.enforestIdentifier() });else break;return this.term;
    }enforestBooleanLiteral() {
      return new _terms2.default("LiteralBooleanExpression", { value: this.advance() });
    }enforestTemplateLiteral() {
      return new _terms2.default("TemplateExpression", { tag: this.term, elements: this.enforestTemplateElements() });
    }enforestStringLiteral() {
      return new _terms2.default("LiteralStringExpression", { value: this.advance() });
    }enforestNumericLiteral() {
      let e = this.advance();return e.val() === 1 / 0 ? new _terms2.default("LiteralInfinityExpression", {}) : new _terms2.default("LiteralNumericExpression", { value: e });
    }enforestIdentifierExpression() {
      return new _terms2.default("IdentifierExpression", { name: this.advance() });
    }enforestRegularExpressionLiteral() {
      let e = this.advance(),
          r = e.token.value.lastIndexOf("/"),
          i = e.token.value.slice(1, r),
          o = e.token.value.slice(r + 1);return new _terms2.default("LiteralRegExpExpression", { pattern: i, flags: o });
    }enforestNullLiteral() {
      return this.advance(), new _terms2.default("LiteralNullExpression", {});
    }enforestThisExpression() {
      return new _terms2.default("ThisExpression", { stx: this.advance() });
    }enforestArgumentList() {
      let e = [];for (; 0 < this.rest.size;) {
        let r;this.isPunctuator(this.peek(), "...") ? (this.advance(), r = new _terms2.default("SpreadElement", { expression: this.enforestExpressionLoop() })) : r = this.enforestExpressionLoop(), 0 < this.rest.size && this.matchPunctuator(","), e.push(r);
      }return (0, _immutable.List)(e);
    }enforestNewExpression() {
      if (this.matchKeyword("new"), this.isPunctuator(this.peek(), ".") && this.isIdentifier(this.peek(1), "target")) return this.advance(), this.advance(), new _terms2.default("NewTargetExpression", {});let r,
          e = this.enforestLeftHandSideExpression({ allowCall: !1 });return r = this.isParens(this.peek()) ? this.matchParens() : (0, _immutable.List)(), new _terms2.default("NewExpression", { callee: e, arguments: r });
    }enforestComputedMemberExpression() {
      let e = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context);return new _terms2.default("ComputedMemberExpression", { object: this.term, expression: e.enforestExpression() });
    }transformDestructuring(e) {
      switch (e.type) {case "IdentifierExpression":
          return new _terms2.default("BindingIdentifier", { name: e.name });case "ParenthesizedExpression":
          return 1 === e.inner.size && this.isIdentifier(e.inner.get(0)) ? new _terms2.default("BindingIdentifier", { name: e.inner.get(0) }) : e;case "DataProperty":
          return new _terms2.default("BindingPropertyProperty", { name: e.name, binding: this.transformDestructuringWithDefault(e.expression) });case "ShorthandProperty":
          return new _terms2.default("BindingPropertyIdentifier", { binding: new _terms2.default("BindingIdentifier", { name: e.name }), init: null });case "ObjectExpression":
          return new _terms2.default("ObjectBinding", { properties: e.properties.map(r => this.transformDestructuring(r)) });case "ArrayExpression":
          {
            let r = e.elements.last();return null != r && "SpreadElement" === r.type ? new _terms2.default("ArrayBinding", { elements: e.elements.slice(0, -1).map(i => i && this.transformDestructuringWithDefault(i)), restElement: this.transformDestructuringWithDefault(r.expression) }) : new _terms2.default("ArrayBinding", { elements: e.elements.map(i => i && this.transformDestructuringWithDefault(i)), restElement: null });
          }case "StaticPropertyName":
          return new _terms2.default("BindingIdentifier", { name: e.value });case "ComputedMemberExpression":case "StaticMemberExpression":case "ArrayBinding":case "BindingIdentifier":case "BindingPropertyIdentifier":case "BindingPropertyProperty":case "BindingWithDefault":case "ObjectBinding":
          return e;}(0, _errors.assert)(!1, "not implemented yet for " + e.type);
    }transformDestructuringWithDefault(e) {
      switch (e.type) {case "AssignmentExpression":
          return new _terms2.default("BindingWithDefault", { binding: this.transformDestructuring(e.binding), init: e.expression });}return this.transformDestructuring(e);
    }enforestCallExpression() {
      let e = this.advance();return new _terms2.default("CallExpression", { callee: this.term, arguments: e.inner() });
    }enforestArrowExpression() {
      let e;if (this.isIdentifier(this.peek())) e = new Enforester(_immutable.List.of(this.advance()), (0, _immutable.List)(), this.context);else {
        let o = this.matchParens();e = new Enforester(o, (0, _immutable.List)(), this.context);
      }let r = e.enforestFormalParameters();this.matchPunctuator("=>");let i;return this.isBraces(this.peek()) ? i = this.matchCurlies() : (e = new Enforester(this.rest, (0, _immutable.List)(), this.context), i = e.enforestExpressionLoop(), this.rest = e.rest), new _terms2.default("ArrowExpression", { params: r, body: i });
    }enforestYieldExpression() {
      let e = this.matchKeyword("yield"),
          r = this.peek();if (0 === this.rest.size || r && !this.lineNumberEq(e, r)) return new _terms2.default("YieldExpression", { expression: null });let i = !1;this.isPunctuator(this.peek(), "*") && (i = !0, this.advance());let o = this.enforestExpression(),
          d = i ? "YieldGeneratorExpression" : "YieldExpression";return new _terms2.default(d, { expression: o });
    }enforestSyntaxTemplate() {
      return new _terms2.default("SyntaxTemplate", { template: this.advance() });
    }enforestSyntaxQuote() {
      let e = this.advance();return new _terms2.default("SyntaxQuote", { name: e, template: new _terms2.default("TemplateExpression", { tag: new _terms2.default("IdentifierExpression", { name: e }), elements: this.enforestTemplateElements() }) });
    }enforestStaticMemberExpression() {
      let e = this.term;this.advance();let r = this.advance();return new _terms2.default("StaticMemberExpression", { object: e, property: r });
    }enforestArrayExpression() {
      let e = this.advance(),
          r = [],
          i = new Enforester(e.inner(), (0, _immutable.List)(), this.context);for (; 0 < i.rest.size;) {
        let o = i.peek();if (i.isPunctuator(o, ",")) i.advance(), r.push(null);else if (i.isPunctuator(o, "...")) {
          i.advance();let d = i.enforestExpressionLoop();if (null == d) throw i.createError(o, "expecting expression");r.push(new _terms2.default("SpreadElement", { expression: d }));
        } else {
          let d = i.enforestExpressionLoop();if (null == d) throw i.createError(o, "expected expression");r.push(d), i.consumeComma();
        }
      }return new _terms2.default("ArrayExpression", { elements: (0, _immutable.List)(r) });
    }enforestObjectExpression() {
      let e = this.advance(),
          r = (0, _immutable.List)(),
          i = new Enforester(e.inner(), (0, _immutable.List)(), this.context),
          o = null;for (; 0 < i.rest.size;) {
        let d = i.enforestPropertyDefinition();if (i.consumeComma(), r = r.concat(d), o === d) throw i.createError(d, "invalid syntax in object");o = d;
      }return new _terms2.default("ObjectExpression", { properties: r });
    }enforestPropertyDefinition() {
      var e = this.enforestMethodDefinition();let r = e.methodOrKey,
          i = e.kind;switch (i) {case "method":
          return r;case "identifier":
          if (this.isAssign(this.peek())) {
            this.advance();let d = this.enforestExpressionLoop();return new _terms2.default("BindingPropertyIdentifier", { init: d, binding: this.transformDestructuring(r) });
          }if (!this.isPunctuator(this.peek(), ":")) return new _terms2.default("ShorthandProperty", { name: r.value });}this.matchPunctuator(":");let o = this.enforestExpressionLoop();return new _terms2.default("DataProperty", { name: r, expression: o });
    }enforestMethodDefinition() {
      let e = this.peek(),
          r = !1;if (this.isPunctuator(e, "*") && (r = !0, this.advance()), this.isIdentifier(e, "get") && this.isPropertyName(this.peek(1))) {
        this.advance();var i = this.enforestPropertyName();let c = i.name;this.matchParens();let m = this.matchCurlies();return { methodOrKey: new _terms2.default("Getter", { name: c, body: m }), kind: "method" };
      }if (this.isIdentifier(e, "set") && this.isPropertyName(this.peek(1))) {
        this.advance();var o = this.enforestPropertyName();let c = o.name,
            m = new Enforester(this.matchParens(), (0, _immutable.List)(), this.context),
            u = m.enforestBindingElement(),
            l = this.matchCurlies();return { methodOrKey: new _terms2.default("Setter", { name: c, param: u, body: l }), kind: "method" };
      }var d = this.enforestPropertyName();let f = d.name;if (this.isParens(this.peek())) {
        let c = this.matchParens(),
            m = new Enforester(c, (0, _immutable.List)(), this.context),
            u = m.enforestFormalParameters(),
            l = this.matchCurlies();return { methodOrKey: new _terms2.default("Method", { isGenerator: r, name: f, params: u, body: l }), kind: "method" };
      }return { methodOrKey: f, kind: this.isIdentifier(e) || this.isKeyword(e) ? "identifier" : "property" };
    }enforestPropertyName() {
      let e = this.peek();if (this.isStringLiteral(e) || this.isNumericLiteral(e)) return { name: new _terms2.default("StaticPropertyName", { value: this.advance() }), binding: null };if (this.isBrackets(e)) {
        let i = new Enforester(this.matchSquares(), (0, _immutable.List)(), this.context),
            o = i.enforestExpressionLoop();return { name: new _terms2.default("ComputedPropertyName", { expression: o }), binding: null };
      }let r = this.advance();return { name: new _terms2.default("StaticPropertyName", { value: r }), binding: new _terms2.default("BindingIdentifier", { name: r }) };
    }enforestFunction(e) {
      let r = e.isExpr,
          i = e.inDefault,
          o = null,
          d,
          f,
          c = !1,
          m = this.advance(),
          u = this.peek(),
          l = r ? "FunctionExpression" : "FunctionDeclaration";this.isPunctuator(u, "*") && (c = !0, this.advance(), u = this.peek()), this.isParens(u) ? i && (o = new _terms2.default("BindingIdentifier", { name: _syntax2.default.fromIdentifier("*default*", m) })) : o = this.enforestBindingIdentifier(), d = this.matchParens(), f = this.matchCurlies();let h = new Enforester(d, (0, _immutable.List)(), this.context),
          y = h.enforestFormalParameters();return new _terms2.default(l, { name: o, isGenerator: c, params: y, body: f });
    }enforestFunctionExpression() {
      let r,
          i,
          e = null,
          o = !1;this.advance();let d = this.peek();this.isPunctuator(d, "*") && (o = !0, this.advance(), d = this.peek()), this.isParens(d) || (e = this.enforestBindingIdentifier()), r = this.matchParens(), i = this.matchCurlies();let f = new Enforester(r, (0, _immutable.List)(), this.context),
          c = f.enforestFormalParameters();return new _terms2.default("FunctionExpression", { name: e, isGenerator: o, params: c, body: i });
    }enforestFunctionDeclaration() {
      let e,
          r,
          i,
          o = !1;this.advance();let d = this.peek();this.isPunctuator(d, "*") && (o = !0, this.advance()), e = this.enforestBindingIdentifier(), r = this.matchParens(), i = this.matchCurlies();let f = new Enforester(r, (0, _immutable.List)(), this.context),
          c = f.enforestFormalParameters();return new _terms2.default("FunctionDeclaration", { name: e, isGenerator: o, params: c, body: i });
    }enforestFormalParameters() {
      let e = [],
          r = null;for (; 0 !== this.rest.size;) {
        let i = this.peek();if (this.isPunctuator(i, "...")) {
          this.matchPunctuator("..."), r = this.enforestBindingIdentifier();break;
        }e.push(this.enforestParam()), this.consumeComma();
      }return new _terms2.default("FormalParameters", { items: (0, _immutable.List)(e), rest: r });
    }enforestParam() {
      return this.enforestBindingElement();
    }enforestUpdateExpression() {
      let e = this.matchUnaryOperator();return new _terms2.default("UpdateExpression", { isPrefix: !1, operator: e.val(), operand: this.transformDestructuring(this.term) });
    }enforestUnaryExpression() {
      let e = this.matchUnaryOperator();return this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine }), this.opCtx.prec = 14, this.opCtx.combine = r => {
        return "++" === e.val() || "--" === e.val() ? new _terms2.default("UpdateExpression", { operator: e.val(), operand: this.transformDestructuring(r), isPrefix: !0 }) : new _terms2.default("UnaryExpression", { operator: e.val(), operand: r });
      }, EXPR_LOOP_OPERATOR;
    }enforestConditionalExpression() {
      let e = this.opCtx.combine(this.term);if (0 < this.opCtx.stack.size) {
        var r = this.opCtx.stack.last();let f = r.prec,
            c = r.combine;this.opCtx.stack = this.opCtx.stack.pop(), this.opCtx.prec = f, this.opCtx.combine = c;
      }this.matchPunctuator("?");let i = new Enforester(this.rest, (0, _immutable.List)(), this.context),
          o = i.enforestExpressionLoop();i.matchPunctuator(":"), i = new Enforester(i.rest, (0, _immutable.List)(), this.context);let d = i.enforestExpressionLoop();return this.rest = i.rest, new _terms2.default("ConditionalExpression", { test: e, consequent: o, alternate: d });
    }enforestBinaryExpression() {
      let e = this.term,
          r = this.peek(),
          i = r.val(),
          o = (0, _operators.getOperatorPrec)(i),
          d = (0, _operators.getOperatorAssoc)(i);if ((0, _operators.operatorLt)(this.opCtx.prec, o, d)) return this.opCtx.stack = this.opCtx.stack.push({ prec: this.opCtx.prec, combine: this.opCtx.combine }), this.opCtx.prec = o, this.opCtx.combine = c => {
        return new _terms2.default("BinaryExpression", { left: e, operator: r, right: c });
      }, this.advance(), EXPR_LOOP_OPERATOR;let c = this.opCtx.combine(e);var f = this.opCtx.stack.last();let m = f.prec,
          u = f.combine;return this.opCtx.stack = this.opCtx.stack.pop(), this.opCtx.prec = m, this.opCtx.combine = u, c;
    }enforestTemplateElements() {
      let e = this.matchTemplate(),
          r = e.token.items.map(i => {
        if (this.isDelimiter(i)) {
          let o = new Enforester(i.inner(), (0, _immutable.List)(), this.context);return o.enforest("expression");
        }return new _terms2.default("TemplateElement", { rawValue: i.slice.text });
      });return r;
    }expandMacro() {
      for (let e = this.peek(); this.isCompiletimeTransform(e);) {
        let r = this.advance(),
            i = this.getFromCompiletimeEnvironment(r);if (null == i || "function" != typeof i.value) throw this.createError(r, "the macro name was not bound to a value that could be invoked");let o = (0, _scope.freshScope)("u"),
            d = (0, _scope.freshScope)("i");this.context.useScope = o;let f = new _macroContext2.default(this, r, this.context, o, d),
            c = (0, _loadSyntax.sanitizeReplacementValues)(i.value.call(null, f));if (!_immutable.List.isList(c)) throw this.createError(r, "macro must return a list but got: " + c);c = c.map(m => {
          if (!(m && "function" == typeof m.addScope)) throw this.createError(r, "macro must return syntax objects or terms but got: " + m);return m.addScope(d, this.context.bindings, _syntax.ALL_PHASES, { flip: !0 });
        }), this.rest = c.concat(f._rest(this)), e = this.peek();
      }
    }consumeSemicolon() {
      let e = this.peek();e && this.isPunctuator(e, ";") && this.advance();
    }consumeComma() {
      let e = this.peek();e && this.isPunctuator(e, ",") && this.advance();
    }safeCheck(e, r) {
      let i = 2 >= arguments.length || arguments[2] === void 0 ? null : arguments[2];return e && !("function" != typeof e.match) && e.match(r, i);
    }isTerm(e) {
      return e && e instanceof _terms2.default;
    }isEOF(e) {
      return this.safeCheck(e, "eof");
    }isIdentifier(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "identifier", r);
    }isPropertyName(e) {
      return this.isIdentifier(e) || this.isKeyword(e) || this.isNumericLiteral(e) || this.isStringLiteral(e) || this.isBrackets(e);
    }isNumericLiteral(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "number", r);
    }isStringLiteral(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "string", r);
    }isTemplate(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "template", r);
    }isSyntaxTemplate(e) {
      return this.safeCheck(e, "syntaxTemplate");
    }isBooleanLiteral(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "boolean", r);
    }isNullLiteral(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "null", r);
    }isRegularExpression(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "regularExpression", r);
    }isDelimiter(e) {
      return this.safeCheck(e, "delimiter");
    }isParens(e) {
      return this.safeCheck(e, "parens");
    }isBraces(e) {
      return this.safeCheck(e, "braces");
    }isBrackets(e) {
      return this.safeCheck(e, "brackets");
    }isAssign(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "assign", r);
    }isKeyword(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "keyword", r);
    }isPunctuator(e) {
      let r = 1 >= arguments.length || arguments[1] === void 0 ? null : arguments[1];return this.safeCheck(e, "punctuator", r);
    }isOperator(e) {
      return (this.safeCheck(e, "punctuator") || this.safeCheck(e, "identifier") || this.safeCheck(e, "keyword")) && (0, _operators.isOperator)(e);
    }isUpdateOperator(e) {
      return this.safeCheck(e, "punctuator", "++") || this.safeCheck(e, "punctuator", "--");
    }safeResolve(e, r) {
      return e && "function" == typeof e.resolve ? Just(e.resolve(r)) : Nothing();
    }isTransform(e, r) {
      return this.safeResolve(e, this.context.phase).map(i => this.context.env.get(i) === r || this.context.store.get(i) === r).getOrElse(!1);
    }isTransformInstance(e, r) {
      return this.safeResolve(e, this.context.phase).map(i => this.context.env.get(i) instanceof r || this.context.store.get(i) instanceof r).getOrElse(!1);
    }isFnDeclTransform(e) {
      return this.isTransform(e, _transforms.FunctionDeclTransform);
    }isVarDeclTransform(e) {
      return this.isTransform(e, _transforms.VariableDeclTransform);
    }isLetDeclTransform(e) {
      return this.isTransform(e, _transforms.LetDeclTransform);
    }isConstDeclTransform(e) {
      return this.isTransform(e, _transforms.ConstDeclTransform);
    }isSyntaxDeclTransform(e) {
      return this.isTransform(e, _transforms.SyntaxDeclTransform);
    }isSyntaxrecDeclTransform(e) {
      return this.isTransform(e, _transforms.SyntaxrecDeclTransform);
    }isSyntaxQuoteTransform(e) {
      return this.isTransform(e, _transforms.SyntaxQuoteTransform);
    }isReturnStmtTransform(e) {
      return this.isTransform(e, _transforms.ReturnStatementTransform);
    }isWhileTransform(e) {
      return this.isTransform(e, _transforms.WhileTransform);
    }isForTransform(e) {
      return this.isTransform(e, _transforms.ForTransform);
    }isSwitchTransform(e) {
      return this.isTransform(e, _transforms.SwitchTransform);
    }isBreakTransform(e) {
      return this.isTransform(e, _transforms.BreakTransform);
    }isContinueTransform(e) {
      return this.isTransform(e, _transforms.ContinueTransform);
    }isDoTransform(e) {
      return this.isTransform(e, _transforms.DoTransform);
    }isDebuggerTransform(e) {
      return this.isTransform(e, _transforms.DebuggerTransform);
    }isWithTransform(e) {
      return this.isTransform(e, _transforms.WithTransform);
    }isTryTransform(e) {
      return this.isTransform(e, _transforms.TryTransform);
    }isThrowTransform(e) {
      return this.isTransform(e, _transforms.ThrowTransform);
    }isIfTransform(e) {
      return this.isTransform(e, _transforms.IfTransform);
    }isNewTransform(e) {
      return this.isTransform(e, _transforms.NewTransform);
    }isCompiletimeTransform(e) {
      return this.isTransformInstance(e, _transforms.CompiletimeTransform);
    }isVarBindingTransform(e) {
      return this.isTransformInstance(e, _transforms.VarBindingTransform);
    }getFromCompiletimeEnvironment(e) {
      return this.context.env.has(e.resolve(this.context.phase)) ? this.context.env.get(e.resolve(this.context.phase)) : this.context.store.get(e.resolve(this.context.phase));
    }lineNumberEq(e, r) {
      return e && r && e.lineNumber() === r.lineNumber();
    }matchIdentifier(e) {
      let r = this.advance();if (this.isIdentifier(r, e)) return r;throw this.createError(r, "expecting an identifier");
    }matchKeyword(e) {
      let r = this.advance();if (this.isKeyword(r, e)) return r;throw this.createError(r, "expecting " + e);
    }matchLiteral() {
      let e = this.advance();if (this.isNumericLiteral(e) || this.isStringLiteral(e) || this.isBooleanLiteral(e) || this.isNullLiteral(e) || this.isTemplate(e) || this.isRegularExpression(e)) return e;throw this.createError(e, "expecting a literal");
    }matchStringLiteral() {
      let e = this.advance();if (this.isStringLiteral(e)) return e;throw this.createError(e, "expecting a string literal");
    }matchTemplate() {
      let e = this.advance();if (this.isTemplate(e)) return e;throw this.createError(e, "expecting a template literal");
    }matchParens() {
      let e = this.advance();if (this.isParens(e)) return e.inner();throw this.createError(e, "expecting parens");
    }matchCurlies() {
      let e = this.advance();if (this.isBraces(e)) return e.inner();throw this.createError(e, "expecting curly braces");
    }matchSquares() {
      let e = this.advance();if (this.isBrackets(e)) return e.inner();throw this.createError(e, "expecting sqaure braces");
    }matchUnaryOperator() {
      let e = this.advance();if ((0, _operators.isUnaryOperator)(e)) return e;throw this.createError(e, "expecting a unary operator");
    }matchPunctuator(e) {
      let r = this.advance();if (this.isPunctuator(r)) {
        if ("undefined" != typeof e) {
          if (r.val() === e) return r;throw this.createError(r, "expecting a " + e + " punctuator");
        }return r;
      }throw this.createError(r, "expecting a punctuator");
    }createError(e, r) {
      let i = "",
          o = e;return i = 0 < this.rest.size ? this.rest.slice(0, 20).map(d => {
        return this.isDelimiter(d) ? d.inner() : _immutable.List.of(d);
      }).flatten().map(d => {
        return d === o ? "__" + d.val() + "__" : d.val();
      }).join(" ") : o.toString(), new Error(r + "\n" + i);
    }
  }exports.Enforester = Enforester;
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/macro-context.js', ['./errors', 'immutable', './enforester', './syntax', 'ramda', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.SyntaxOrTermWrapper = void 0, exports.unwrap = unwrap;var _errors = $__require('./errors'),
      _immutable = $__require('immutable'),
      _enforester = $__require('./enforester'),
      _syntax = $__require('./syntax'),
      _ramda = $__require('ramda'),
      _ = _interopRequireWildcard(_ramda);function _interopRequireWildcard(a) {
    if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b.default = a, b;
  }const symWrap = Symbol('wrapper'),
        privateData = new WeakMap(),
        getVal = a => {
    return a.match('delimiter') ? null : 'function' == typeof a.val ? a.val() : null;
  };class SyntaxOrTermWrapper {
    constructor(a) {
      let b = 1 >= arguments.length || arguments[1] === void 0 ? {} : arguments[1];this[symWrap] = a, this.context = b;
    }from(a, b) {
      let c = this[symWrap];if ('function' == typeof c.from) return c.from(a, b);
    }fromNull() {
      return this.from('null', null);
    }fromNumber(a) {
      return this.from('number', a);
    }fromString(a) {
      return this.from('string', a);
    }fromPunctuator(a) {
      return this.from('punctuator', a);
    }fromKeyword(a) {
      return this.from('keyword', a);
    }fromIdentifier(a) {
      return this.from('identifier', a);
    }fromRegularExpression(a) {
      return this.from('regularExpression', a);
    }fromBraces(a) {
      return this.from('braces', a);
    }fromBrackets(a) {
      return this.from('brackets', a);
    }fromParens(a) {
      return this.from('parens', a);
    }match(a, b) {
      let c = this[symWrap];if ('function' == typeof c.match) return c.match(a, b);
    }isIdentifier(a) {
      return this.match('identifier', a);
    }isAssign(a) {
      return this.match('assign', a);
    }isBooleanLiteral(a) {
      return this.match('boolean', a);
    }isKeyword(a) {
      return this.match('keyword', a);
    }isNullLiteral(a) {
      return this.match('null', a);
    }isNumericLiteral(a) {
      return this.match('number', a);
    }isPunctuator(a) {
      return this.match('punctuator', a);
    }isStringLiteral(a) {
      return this.match('string', a);
    }isRegularExpression(a) {
      return this.match('regularExpression', a);
    }isTemplate(a) {
      return this.match('template', a);
    }isDelimiter(a) {
      return this.match('delimiter', a);
    }isParens(a) {
      return this.match('parens', a);
    }isBraces(a) {
      return this.match('braces', a);
    }isBrackets(a) {
      return this.match('brackets', a);
    }isSyntaxTemplate(a) {
      return this.match('syntaxTemplate', a);
    }isEOF(a) {
      return this.match('eof', a);
    }lineNumber() {
      return this[symWrap].lineNumber();
    }val() {
      return getVal(this[symWrap]);
    }inner() {
      let a = this[symWrap];if (!a.match('delimiter')) throw new Error('Can only get inner syntax on a delimiter');let b = new _enforester.Enforester(a.inner(), (0, _immutable.List)(), this.context);return new MacroContext(b, 'inner', this.context);
    }
  }exports.SyntaxOrTermWrapper = SyntaxOrTermWrapper;function unwrap(a) {
    return a instanceof SyntaxOrTermWrapper ? a[symWrap] : a;
  }function cloneEnforester(a) {
    const b = a.rest,
          c = a.prev,
          d = a.context;return new _enforester.Enforester(b, c, d);
  }function Marker() {}class MacroContext {
    constructor(a, b, c, d, e) {
      const f = new Marker(),
            g = cloneEnforester(a),
            h = { name: b, context: c, enf: g, startMarker: f, markers: new Map([[f, a]]) };d && e ? (h.noScopes = !1, h.useScope = d, h.introducedScope = e) : h.noScopes = !0, privateData.set(this, h), this.reset(), this[Symbol.iterator] = () => this;
    }name() {
      var a = privateData.get(this);const b = a.name,
            c = a.context;return new SyntaxOrTermWrapper(b, c);
    }expand(a) {
      var b = privateData.get(this);const c = b.enf,
            d = b.context;if (0 === c.rest.size) return { done: !0, value: null };c.expandMacro();let e = c.rest,
          f;switch (a) {case 'AssignmentExpression':case 'expr':
          f = c.enforestExpressionLoop();break;case 'Expression':
          f = c.enforestExpression();break;case 'Statement':case 'stmt':
          f = c.enforestStatement();break;case 'BlockStatement':case 'WhileStatement':case 'IfStatement':case 'ForStatement':case 'SwitchStatement':case 'BreakStatement':case 'ContinueStatement':case 'DebuggerStatement':case 'WithStatement':case 'TryStatement':case 'ThrowStatement':case 'ClassDeclaration':case 'FunctionDeclaration':case 'LabeledStatement':case 'VariableDeclarationStatement':case 'ReturnStatement':case 'ExpressionStatement':
          f = c.enforestStatement(), (0, _errors.expect)(_.whereEq({ type: a }, f), `Expecting a ${a}`, f, e);break;case 'YieldExpression':
          f = c.enforestYieldExpression();break;case 'ClassExpression':
          f = c.enforestClass({ isExpr: !0 });break;case 'ArrowExpression':
          f = c.enforestArrowExpression();break;case 'NewExpression':
          f = c.enforestNewExpression();break;case 'ThisExpression':case 'FunctionExpression':case 'IdentifierExpression':case 'LiteralNumericExpression':case 'LiteralInfinityExpression':case 'LiteralStringExpression':case 'TemplateExpression':case 'LiteralBooleanExpression':case 'LiteralNullExpression':case 'LiteralRegExpExpression':case 'ObjectExpression':case 'ArrayExpression':
          f = c.enforestPrimaryExpression();break;case 'UnaryExpression':case 'UpdateExpression':case 'BinaryExpression':case 'StaticMemberExpression':case 'ComputedMemberExpression':case 'CompoundAssignmentExpression':case 'ConditionalExpression':
          f = c.enforestExpressionLoop(), (0, _errors.expect)(_.whereEq({ type: a }, f), `Expecting a ${a}`, f, e);break;default:
          throw new Error('Unknown term type: ' + a);}return { done: !1, value: new SyntaxOrTermWrapper(f, d) };
    }_rest(a) {
      const b = privateData.get(this);if (b.markers.get(b.startMarker) === a) return b.enf.rest;throw Error('Unauthorized access!');
    }reset(a) {
      const b = privateData.get(this);let c;if (null == a) c = b.markers.get(b.startMarker);else if (!(a && a instanceof Marker)) throw new Error('marker must be an instance of Marker');else if (b.markers.has(a)) c = b.markers.get(a);else throw new Error('marker must originate from this context');b.enf = cloneEnforester(c);
    }mark() {
      const a = privateData.get(this);let b;return a.enf.rest === a.markers.get(a.startMarker).rest ? b = a.startMarker : a.enf.rest.isEmpty() ? (!a.endMarker && (a.endMarker = new Marker()), b = a.endMarker) : b = new Marker(), a.markers.has(b) || a.markers.set(b, cloneEnforester(a.enf)), b;
    }next() {
      var a = privateData.get(this);const b = a.enf,
            c = a.noScopes,
            d = a.useScope,
            e = a.introducedScope,
            f = a.context;if (0 === b.rest.size) return { done: !0, value: null };let g = b.advance();return c || (g = g.addScope(d, f.bindings, _syntax.ALL_PHASES).addScope(e, f.bindings, _syntax.ALL_PHASES, { flip: !0 })), { done: !1, value: new SyntaxOrTermWrapper(g, f) };
    }
  }exports.default = MacroContext;
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/template-processor.js', ['immutable', 'ramda', './syntax', './errors', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.processTemplate = processTemplate, exports.replaceTemplate = replaceTemplate;var _immutable = $__require('immutable'),
      _ramda = $__require('ramda'),
      _ramda2 = _interopRequireDefault(_ramda),
      _syntax = $__require('./syntax'),
      _syntax2 = _interopRequireDefault(_syntax),
      _errors = $__require('./errors');function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }const isDolar = a => a && 'function' == typeof a.match && a.match('identifier') && '$' === a.val(),
        isDelimiter = a => a && 'function' == typeof a.match && a.match('delimiter'),
        isBraces = a => a && 'function' == typeof a.match && a.match('braces'),
        isParens = a => a && 'function' == typeof a.match && a.match('parens'),
        isBrackets = a => a && 'function' == typeof a.match && a.match('brackets'),
        insertIntoDelimiter = _ramda2.default.cond([[isBraces, (a, b) => _syntax2.default.from('braces', b, a)], [isParens, (a, b) => _syntax2.default.from('parens', b, a)], [isBrackets, (a, b) => _syntax2.default.from('brackets', b, a)]]),
        process2 = (a, b) => {
    if (isBraces(b) && isDolar(a.template.last())) return { template: a.template.push(_syntax2.default.from('braces', _immutable.List.of(_syntax2.default.from('number', a.interp.size)), b)), interp: a.interp.push(b.inner()) };if (isDelimiter(b)) {
      let c = processTemplate(b.inner(), a.interp);return { template: a.template.push(insertIntoDelimiter(b, c.template)), interp: c.interp };
    }return { template: a.template.push(b), interp: a.interp };
  };function cloneLineNumber(a, b) {
    if (b && a) {
      if ('function' == typeof a.setLineNumber) return a.setLineNumber(b.lineNumber());if (_immutable.List.isList(a)) return a.map(c => cloneLineNumber(c, b));
    }return a;
  }const replace = (a, b) => {
    let c = a.template.get(-1),
        d = a.template.get(-2);if (isBraces(b) && isDolar(c)) {
      let e = b.inner().first().val();(0, _errors.assert)(a.rep.size > e, 'unknown replacement value');let f = cloneLineNumber(a.rep.get(e), d);return { template: a.template.pop().concat(f), rep: a.rep };
    }if (isDelimiter(b)) {
      let e = replaceTemplate(b.inner(), a.rep);return { template: a.template.push(insertIntoDelimiter(b, e)), rep: a.rep };
    }return { template: a.template.push(b), rep: a.rep };
  };function processTemplate(a) {
    let b = 1 >= arguments.length || arguments[1] === void 0 ? (0, _immutable.List)() : arguments[1];return a.reduce(process2, { template: (0, _immutable.List)(), interp: b });
  }function replaceTemplate(a, b) {
    return a.reduce(replace, { template: (0, _immutable.List)(), rep: b }).template;
  }
});
System.registerDynamic("npm:jspm-nodelibs-vm@0.2.0.json", [], true, function() {
  return {
    "main": "./vm.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-vm@0.2.0/vm.js', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /*
     * Fork of https://github.com/substack/vm-browserify
     */

    var hasIndexOf = [].indexOf;

    function indexOf(arr, obj) {
        if (hasIndexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i] === obj) return i;
        }
        return -1;
    }

    var Object_keys = function (obj) {
        if (Object.keys) return Object.keys(obj);else {
            var res = [];
            for (var key in obj) res.push(key);
            return res;
        }
    };

    var forEach = function (xs, fn) {
        if (xs.forEach) return xs.forEach(fn);else for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
    };

    var defineProp = function () {
        try {
            Object.defineProperty({}, '_', {});
            return function (obj, name, value) {
                Object.defineProperty(obj, name, {
                    writable: true,
                    enumerable: false,
                    configurable: true,
                    value: value
                });
            };
        } catch (e) {
            return function (obj, name, value) {
                obj[name] = value;
            };
        }
    }();

    var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

    function Context() {}
    Context.prototype = {};

    var Script = exports.Script = function NodeScript(code) {
        if (!(this instanceof Script)) return new Script(code);
        this.code = code;
    };

    Script.prototype.runInContext = function (context) {
        if (!(context instanceof Context)) {
            throw new TypeError("needs a 'context' argument.");
        }

        var iframe = document.createElement('iframe');
        if (!iframe.style) iframe.style = {};
        iframe.style.display = 'none';

        document.body.appendChild(iframe);

        var win = iframe.contentWindow;
        var wEval = win.eval,
            wExecScript = win.execScript;

        if (!wEval && wExecScript) {
            // win.eval() magically appears when this is called in IE:
            wExecScript.call(win, 'null');
            wEval = win.eval;
        }

        forEach(Object_keys(context), function (key) {
            win[key] = context[key];
        });
        forEach(globals, function (key) {
            if (context[key]) {
                win[key] = context[key];
            }
        });

        var winKeys = Object_keys(win);

        var res = wEval.call(win, this.code);

        forEach(Object_keys(win), function (key) {
            // Avoid copying circular objects like `top` and `window` by only
            // updating existing context properties or new properties in the `win`
            // that was only introduced after the eval.
            if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
            }
        });

        forEach(globals, function (key) {
            if (!(key in context)) {
                defineProp(context, key, win[key]);
            }
        });

        document.body.removeChild(iframe);

        return res;
    };

    Script.prototype.runInThisContext = function () {
        return eval(this.code); // maybe...
    };

    Script.prototype.runInNewContext = function (context) {
        var ctx = Script.createContext(context);
        var res = this.runInContext(ctx);

        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });

        return res;
    };

    forEach(Object_keys(Script.prototype), function (name) {
        exports[name] = Script[name] = function (code) {
            var s = Script(code);
            return s[name].apply(s, [].slice.call(arguments, 1));
        };
    });

    exports.createScript = function (code) {
        return exports.Script(code);
    };

    exports.createContext = Script.createContext = function (context) {
        var copy = new Context();
        if (typeof context === 'object') {
            forEach(Object_keys(context), function (key) {
                copy[key] = context[key];
            });
        }
        return copy;
    };
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/load-syntax.js', ['ramda', 'immutable', './parse-reducer.js', 'shift-reducer', './serializer', './syntax', 'shift-codegen', './terms', './shift-reader', './macro-context', './template-processor', 'vm', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.sanitizeReplacementValues = sanitizeReplacementValues, exports.evalRuntimeValues = evalRuntimeValues, exports.evalCompiletimeValue = evalCompiletimeValue;var _ramda = $__require('ramda'),
      _ = _interopRequireWildcard(_ramda),
      _immutable = $__require('immutable'),
      _parseReducer = $__require('./parse-reducer.js'),
      _parseReducer2 = _interopRequireDefault(_parseReducer),
      _shiftReducer = $__require('shift-reducer'),
      _shiftReducer2 = _interopRequireDefault(_shiftReducer),
      _serializer = $__require('./serializer'),
      _syntax = $__require('./syntax'),
      _syntax2 = _interopRequireDefault(_syntax),
      _shiftCodegen = $__require('shift-codegen'),
      _shiftCodegen2 = _interopRequireDefault(_shiftCodegen),
      _terms = $__require('./terms'),
      _terms2 = _interopRequireDefault(_terms),
      _shiftReader = $__require('./shift-reader'),
      _shiftReader2 = _interopRequireDefault(_shiftReader),
      _macroContext = $__require('./macro-context'),
      _templateProcessor = $__require('./template-processor'),
      _vm = $__require('vm'),
      _vm2 = _interopRequireDefault(_vm);function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }function _interopRequireWildcard(a) {
    if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b.default = a, b;
  }function sanitizeReplacementValues(a) {
    if (Array.isArray(a)) return sanitizeReplacementValues((0, _immutable.List)(a));if (_immutable.List.isList(a)) return a.map(sanitizeReplacementValues);if (null == a) throw new Error('replacement values for syntax template must not be null or undefined');else if ('function' == typeof a.next) return sanitizeReplacementValues((0, _immutable.List)(a));return (0, _macroContext.unwrap)(a);
  }function evalRuntimeValues(a, b) {
    let c = a.reduce((h, i) => {
      if ((0, _terms.isExport)(i)) {
        if ((0, _terms.isVariableDeclaration)(i.declaration)) return h.concat(new _terms2.default('VariableDeclarationStatement', { declaration: i.declaration })).concat(i.declaration.declarators.map(j => {
          return new _terms2.default('ExpressionStatement', { expression: new _terms2.default('AssignmentExpression', { binding: new _terms2.default('StaticMemberExpression', { object: new _terms2.default('IdentifierExpression', { name: _syntax2.default.fromIdentifier('exports') }), property: j.binding.name }), expression: new _terms2.default('IdentifierExpression', { name: j.binding.name }) }) });
        }));
      } else if ((0, _terms.isImport)(i)) return h;return h.concat(i);
    }, (0, _immutable.List)()),
        d = (0, _shiftReducer2.default)(new _parseReducer2.default(b, !1), new _terms2.default('Module', { directives: (0, _immutable.List)(), items: c }).gen(!1)),
        e = (0, _shiftCodegen2.default)(d, new _shiftCodegen.FormattedCodeGen()),
        f = b.transform(e, { babelrc: !0, filename: b.filename }),
        g = {};return b.store.set('exports', g), _vm2.default.runInContext(f.code, b.store.getNodeContext()), g;
  }function evalCompiletimeValue(a, b) {
    let c = (0, _serializer.makeDeserializer)(b.bindings),
        d = { syntaxQuote: function (m) {
        for (var n = arguments.length, o = Array(1 < n ? n - 1 : 0), p = 1; p < n; p++) o[p - 1] = arguments[p];let q = c.read(_.last(o)),
            r = new _shiftReader2.default(m, q, _.take(o.length - 1, o));return r.read();
      }, syntaxTemplate: function (m) {
        for (var n = arguments.length, o = Array(1 < n ? n - 1 : 0), p = 1; p < n; p++) o[p - 1] = arguments[p];return (0, _templateProcessor.replaceTemplate)(c.read(m), sanitizeReplacementValues(o));
      } },
        e = (0, _immutable.List)(Object.keys(d)),
        f = e.map(l => d[l]).toArray(),
        g = (0, _shiftReducer2.default)(new _parseReducer2.default(b), new _terms2.default('Module', { directives: (0, _immutable.List)(), items: _immutable.List.of(new _terms2.default('ExpressionStatement', { expression: new _terms2.default('FunctionExpression', { isGenerator: !1, name: null, params: new _terms2.default('FormalParameters', { items: e.map(l => {
              return new _terms2.default('BindingIdentifier', { name: _syntax2.default.from('identifier', l) });
            }), rest: null }), body: new _terms2.default('FunctionBody', { directives: _immutable.List.of(new _terms2.default('Directive', { rawValue: 'use strict' })), statements: _immutable.List.of(new _terms2.default('ReturnStatement', { expression: a })) }) }) })) })),
        h = (0, _shiftCodegen2.default)(g, new _shiftCodegen.FormattedCodeGen()),
        i = b.transform(h, { babelrc: !0, filename: b.filename }),
        j = _vm2.default.runInContext(i.code, b.store.getNodeContext());return j.apply(void 0, f);
  }
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/token-expander.js", ["immutable", "./enforester", "./term-expander.js", "./env", "ramda", "./terms", "./symbol", "./transforms", "./errors", "./load-syntax", "./scope", "./syntax", "./ast-dispatcher", "./hygiene-utils", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _immutable = $__require("immutable"),
      _enforester = $__require("./enforester"),
      _termExpander = $__require("./term-expander.js"),
      _termExpander2 = _interopRequireDefault(_termExpander),
      _env = $__require("./env"),
      _env2 = _interopRequireDefault(_env),
      _ramda = $__require("ramda"),
      _ = _interopRequireWildcard(_ramda),
      _terms = $__require("./terms"),
      T = _interopRequireWildcard(_terms),
      _symbol = $__require("./symbol"),
      _transforms = $__require("./transforms"),
      _errors = $__require("./errors"),
      _loadSyntax = $__require("./load-syntax"),
      _scope = $__require("./scope"),
      _syntax = $__require("./syntax"),
      _astDispatcher = $__require("./ast-dispatcher"),
      _astDispatcher2 = _interopRequireDefault(_astDispatcher),
      _hygieneUtils = $__require("./hygiene-utils");function _interopRequireWildcard(a) {
    if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b.default = a, b;
  }function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }function bindImports(a, b, c) {
    let d = [],
        f = a.forSyntax ? c.phase + 1 : c.phase;return a.namedImports.forEach(g => {
      let h = g.binding.name,
          i = findNameInExports(h, b.exportEntries);if (null != i) {
        let j = (0, _symbol.gensym)(h.val());c.store.set(j.toString(), new _transforms.VarBindingTransform(h)), c.bindings.addForward(h, i, j, f), d.push(h);
      }
    }), (0, _immutable.List)(d);
  }function findNameInExports(a, b) {
    let c = b.reduce((d, f) => {
      return T.isExportFrom(f) ? d.concat(f.namedExports.reduce((g, h) => {
        return h.exportedName.val() === a.val() ? g.concat(h.exportedName) : g;
      }, (0, _immutable.List)())) : T.isExport(f) ? d.concat(f.declaration.declarators.reduce((g, h) => {
        return h.binding.name.val() === a.val() ? g.concat(h.binding.name) : g;
      }, (0, _immutable.List)())) : d;
    }, (0, _immutable.List)());return (0, _errors.assert)(1 >= c.size, "expecting no more than 1 matching name in exports"), c.get(0);
  }function removeNames(a, b) {
    let c = a.namedImports.filter(d => !b.contains(d.binding.name));return a.extend({ namedImports: c });
  }class TokenExpander extends _astDispatcher2.default {
    constructor(a) {
      super("expand", !1), this.context = a;
    }expand(a) {
      let b = [];if (0 === a.size) return (0, _immutable.List)(b);let c = (0, _immutable.List)(),
          d = new _enforester.Enforester(a, c, this.context);for (; !d.done;) b.push(this.dispatch(d.enforest()));return (0, _immutable.List)(b);
    }expandVariableDeclarationStatement(a) {
      return a.extend({ declaration: this.registerVariableDeclaration(a.declaration) });
    }expandFunctionDeclaration(a) {
      let b = this.registerFunctionOrClass(a),
          c = b.name.name;return this.context.env.set(c.resolve(this.context.phase), new _transforms.VarBindingTransform(c)), b;
    }expandImport(a) {
      let b = a.moduleSpecifier.val(),
          c;a.forSyntax ? (c = this.context.modules.getAtPhase(b, this.context.phase + 1, this.context.cwd), this.context.store = this.context.modules.visit(c, this.context.phase + 1, this.context.store), this.context.store = this.context.modules.invoke(c, this.context.phase + 1, this.context.store)) : (c = this.context.modules.getAtPhase(b, this.context.phase, this.context.cwd), this.context.store = this.context.modules.visit(c, this.context.phase, this.context.store));let d = bindImports(a, c, this.context);return removeNames(a, d);
    }expandExport(a) {
      if (T.isFunctionDeclaration(a.declaration) || T.isClassDeclaration(a.declaration)) return a.extend({ declaration: this.registerFunctionOrClass(a.declaration) });return T.isVariableDeclaration(a.declaration) ? a.extend({ declaration: this.registerVariableDeclaration(a.declaration) }) : a;
    }registerFunctionOrClass(a) {
      let b = a.name.removeScope(this.context.useScope, this.context.phase);return (0, _hygieneUtils.collectBindings)(a.name).forEach(c => {
        let d = (0, _symbol.gensym)(c.val());this.context.bindings.add(c, { binding: d, phase: this.context.phase, skipDup: !1 }), this.context.env.set(d.toString(), new _transforms.VarBindingTransform(c));
      }), a.extend({ name: b });
    }registerVariableDeclaration(a) {
      return T.isSyntaxDeclaration(a) || T.isSyntaxrecDeclaration(a) ? this.registerSyntaxDeclaration(a) : a.extend({ declarators: a.declarators.map(b => {
          let c = b.binding.removeScope(this.context.useScope, this.context.phase);return (0, _hygieneUtils.collectBindings)(c).forEach(d => {
            let f = (0, _symbol.gensym)(d.val());this.context.bindings.add(d, { binding: f, phase: this.context.phase, skipDup: "var" === a.kind }), this.context.env.set(f.toString(), new _transforms.VarBindingTransform(d));
          }), b.extend({ binding: c });
        }) });
    }registerSyntaxDeclaration(a) {
      if (T.isSyntaxDeclaration(a)) {
        let b = (0, _scope.freshScope)("nonrec");a = a.extend({ declarators: a.declarators.map(c => {
            let d = c.binding.name,
                f = d.addScope(b, this.context.bindings, _syntax.ALL_PHASES),
                g = d.removeScope(this.context.currentScope[this.context.currentScope.length - 1], this.context.phase),
                h = (0, _symbol.gensym)(d.val());return this.context.bindings.addForward(f, g, h, this.context.phase), c.extend({ init: c.init.addScope(b, this.context.bindings, _syntax.ALL_PHASES) });
          }) });
      }return a.extend({ declarators: a.declarators.map(b => {
          let c = b.binding.removeScope(this.context.useScope, this.context.phase),
              d = new _termExpander2.default(_.merge(this.context, { phase: this.context.phase + 1, env: new _env2.default(), store: this.context.store })),
              f = d.expand(b.init),
              g = (0, _loadSyntax.evalCompiletimeValue)(f.gen(), _.merge(this.context, { phase: this.context.phase + 1 }));return (0, _hygieneUtils.collectBindings)(c).forEach(h => {
            let i = (0, _symbol.gensym)(h.val());this.context.bindings.add(h, { binding: i, phase: this.context.phase, skipDup: !1 });let j = h.resolve(this.context.phase);this.context.env.set(j, new _transforms.CompiletimeTransform(g));
          }), b.extend({ binding: c, init: f });
        }) });
    }
  }exports.default = TokenExpander;
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/compiler.js', ['./term-expander.js', './token-expander', 'ramda', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 });var _termExpander = $__require('./term-expander.js'),
      _termExpander2 = _interopRequireDefault(_termExpander),
      _tokenExpander = $__require('./token-expander'),
      _tokenExpander2 = _interopRequireDefault(_tokenExpander),
      _ramda = $__require('ramda'),
      _ = _interopRequireWildcard(_ramda);function _interopRequireWildcard(a) {
    if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b.default = a, b;
  }function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class Compiler {
    constructor(a, b, c, d) {
      this.phase = a, this.env = b, this.store = c, this.context = d;
    }compile(a) {
      let b = new _tokenExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store })),
          c = new _termExpander2.default(_.merge(this.context, { phase: this.phase, env: this.env, store: this.store }));return _.pipe(_.bind(b.expand, b), _.map(d => c.expand(d)))(a);
    }
  }exports.default = Compiler;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/transforms.js", ["process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });class FunctionDeclTransform {}exports.FunctionDeclTransform = FunctionDeclTransform;class VariableDeclTransform {}exports.VariableDeclTransform = VariableDeclTransform;class NewTransform {}exports.NewTransform = NewTransform;class ThrowTransform {}exports.ThrowTransform = ThrowTransform;class LetDeclTransform {}exports.LetDeclTransform = LetDeclTransform;class ConstDeclTransform {}exports.ConstDeclTransform = ConstDeclTransform;class TryTransform {}exports.TryTransform = TryTransform;class WhileTransform {}exports.WhileTransform = WhileTransform;class IfTransform {}exports.IfTransform = IfTransform;class ForTransform {}exports.ForTransform = ForTransform;class SwitchTransform {}exports.SwitchTransform = SwitchTransform;class BreakTransform {}exports.BreakTransform = BreakTransform;class ContinueTransform {}exports.ContinueTransform = ContinueTransform;class DoTransform {}exports.DoTransform = DoTransform;class WithTransform {}exports.WithTransform = WithTransform;class DebuggerTransform {}exports.DebuggerTransform = DebuggerTransform;class SyntaxrecDeclTransform {}exports.SyntaxrecDeclTransform = SyntaxrecDeclTransform;class SyntaxDeclTransform {}exports.SyntaxDeclTransform = SyntaxDeclTransform;class SyntaxQuoteTransform {}exports.SyntaxQuoteTransform = SyntaxQuoteTransform;class ReturnStatementTransform {}exports.ReturnStatementTransform = ReturnStatementTransform;class VarBindingTransform {
    constructor(a) {
      this.id = a;
    }
  }exports.VarBindingTransform = VarBindingTransform;class CompiletimeTransform {
    constructor(a) {
      this.value = a;
    }
  }exports.CompiletimeTransform = CompiletimeTransform;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/symbol.js", ["process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.gensym = gensym;let internedMap = new Map(),
      counter = 0;function gensym(a) {
    let b = null == a ? "s_" : a + "_",
        c = new Symbol(b + counter);return counter++, c;
  }function Symbol(a) {
    this.name = a;
  }Symbol.prototype.toString = function () {
    return this.name;
  };function makeSymbol(a) {
    if (internedMap.has(a)) return internedMap.get(a);let b = new Symbol(a);return internedMap.set(a, b), b;
  }exports.Symbol = makeSymbol, exports.SymbolClass = Symbol;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/scope.js", ["./symbol", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.freshScope = freshScope, exports.Scope = Scope;var _symbol = $__require("./symbol");let scopeIndex = 0;function freshScope() {
    let a = 0 >= arguments.length || void 0 === arguments[0] ? "scope" : arguments[0];return scopeIndex++, (0, _symbol.Symbol)(a + "_" + scopeIndex);
  }function Scope(a) {
    return (0, _symbol.Symbol)(a);
  }
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/ast-dispatcher.js', ['process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 });class ASTDispatcher {
    constructor(a, b) {
      this.errorIfMissing = b, this.prefix = a;
    }dispatch(a) {
      let b = this.prefix + a.type;if ('function' == typeof this[b]) return this[b](a);if (!this.errorIfMissing) return a;throw new Error(`Missing implementation for: ${b}`);
    }
  }exports.default = ASTDispatcher;
});
System.registerDynamic('npm:sweetjs-min@2.2.3/dist/hygiene-utils.js', ['immutable', './ast-dispatcher', 'process'], true, function ($__require, exports, module) {
  'use strict';
  var process = $__require('process');
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, '__esModule', { value: !0 }), exports.CollectBindingSyntax = void 0, exports.collectBindings = collectBindings;var _immutable = $__require('immutable'),
      _astDispatcher = $__require('./ast-dispatcher'),
      _astDispatcher2 = _interopRequireDefault(_astDispatcher);function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class CollectBindingSyntax extends _astDispatcher2.default {
    constructor() {
      super('collect', !0), this.names = (0, _immutable.List)();
    }collect(a) {
      return this.dispatch(a);
    }collectBindingIdentifier(a) {
      return this.names.concat(a.name);
    }collectBindingPropertyIdentifier(a) {
      return this.collect(a.binding);
    }collectBindingPropertyProperty(a) {
      return this.collect(a.binding);
    }collectArrayBinding(a) {
      let b = null;return null != a.restElement && (b = this.collect(a.restElement)), this.names.concat(b).concat(a.elements.filter(c => null != c).flatMap(c => this.collect(c)));
    }collectObjectBinding() {
      return (0, _immutable.List)();
    }
  }exports.CollectBindingSyntax = CollectBindingSyntax;function collectBindings(a) {
    return new CollectBindingSyntax().collect(a);
  }
});
System.registerDynamic("npm:immutable@3.8.1.json", [], true, function() {
  return {
    "main": "dist/immutable.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./contrib/cursor": "./contrib/cursor/index.js"
    }
  };
});

System.registerDynamic('npm:immutable@3.8.1/dist/immutable.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   *  Copyright (c) 2014-2015, Facebook, Inc.
   *  All rights reserved.
   *
   *  This source code is licensed under the BSD-style license found in the
   *  LICENSE file in the root directory of this source tree. An additional grant
   *  of patent rights can be found in the PATENTS file in the same directory.
   */

  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof undefined === 'function' && define.amd ? define(factory) : global.Immutable = factory();
  })(exports, function () {
    'use strict';
    var SLICE$0 = Array.prototype.slice;

    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }

    function Iterable(value) {
      return isIterable(value) ? value : Seq(value);
    }

    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed(value) ? value : KeyedSeq(value);
    }

    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed(value) ? value : IndexedSeq(value);
    }

    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
    }

    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }

    function isKeyed(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }

    function isIndexed(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }

    function isAssociative(maybeAssociative) {
      return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
    }

    function isOrdered(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }

    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed;
    Iterable.isIndexed = isIndexed;
    Iterable.isAssociative = isAssociative;
    Iterable.isOrdered = isOrdered;

    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;

    var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    // Used for setting prototype methods that IE8 chokes on.
    var DELETE = 'delete';

    // Constants describing the size of trie nodes.
    var SHIFT = 5; // Resulted in best performance after ______?
    var SIZE = 1 << SHIFT;
    var MASK = SIZE - 1;

    // A consistent shared value representing "not set" which equals nothing other
    // than itself, and nothing that could be provided externally.
    var NOT_SET = {};

    // Boolean references, Rough equivalent of `bool &`.
    var CHANGE_LENGTH = { value: false };
    var DID_ALTER = { value: false };

    function MakeRef(ref) {
      ref.value = false;
      return ref;
    }

    function SetRef(ref) {
      ref && (ref.value = true);
    }

    // A function which returns a value representing an "owner" for transient writes
    // to tries. The return value will only ever equal itself, and will not equal
    // the return of any subsequent call of this function.
    function OwnerID() {}

    // http://jsperf.com/copy-array-inline
    function arrCopy(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }

    function ensureSize(iter) {
      if (iter.size === undefined) {
        iter.size = iter.__iterate(returnTrue);
      }
      return iter.size;
    }

    function wrapIndex(iter, index) {
      // This implements "is array index" which the ECMAString spec defines as:
      //
      //     A String property name P is an array index if and only if
      //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
      //     to 2^32−1.
      //
      // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
      if (typeof index !== 'number') {
        var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
        if ('' + uint32Index !== index || uint32Index === 4294967295) {
          return NaN;
        }
        index = uint32Index;
      }
      return index < 0 ? ensureSize(iter) + index : index;
    }

    function returnTrue() {
      return true;
    }

    function wholeSlice(begin, end, size) {
      return (begin === 0 || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);
    }

    function resolveBegin(begin, size) {
      return resolveIndex(begin, size, 0);
    }

    function resolveEnd(end, size) {
      return resolveIndex(end, size, size);
    }

    function resolveIndex(index, size, defaultIndex) {
      return index === undefined ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === undefined ? index : Math.min(size, index);
    }

    /* global Symbol */

    var ITERATE_KEYS = 0;
    var ITERATE_VALUES = 1;
    var ITERATE_ENTRIES = 2;

    var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

    function Iterator(next) {
      this.next = next;
    }

    Iterator.prototype.toString = function () {
      return '[Iterator]';
    };

    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;

    Iterator.prototype.inspect = Iterator.prototype.toSource = function () {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function () {
      return this;
    };

    function iteratorValue(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value: value, done: false
      };
      return iteratorResult;
    }

    function iteratorDone() {
      return { value: undefined, done: true };
    }

    function hasIterator(maybeIterable) {
      return !!getIteratorFn(maybeIterable);
    }

    function isIterator(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === 'function';
    }

    function getIterator(iterable) {
      var iteratorFn = getIteratorFn(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }

    function getIteratorFn(iterable) {
      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    function isArrayLike(value) {
      return value && typeof value.length === 'number';
    }

    createClass(Seq, Iterable);
    function Seq(value) {
      return value === null || value === undefined ? emptySequence() : isIterable(value) ? value.toSeq() : seqFromValue(value);
    }

    Seq.of = function () /*...values*/{
      return Seq(arguments);
    };

    Seq.prototype.toSeq = function () {
      return this;
    };

    Seq.prototype.toString = function () {
      return this.__toString('Seq {', '}');
    };

    Seq.prototype.cacheResult = function () {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };

    // abstract __iterateUncached(fn, reverse)

    Seq.prototype.__iterate = function (fn, reverse) {
      return seqIterate(this, fn, reverse, true);
    };

    // abstract __iteratorUncached(type, reverse)

    Seq.prototype.__iterator = function (type, reverse) {
      return seqIterator(this, type, reverse, true);
    };

    createClass(KeyedSeq, Seq);
    function KeyedSeq(value) {
      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isIterable(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
    }

    KeyedSeq.prototype.toKeyedSeq = function () {
      return this;
    };

    createClass(IndexedSeq, Seq);
    function IndexedSeq(value) {
      return value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
    }

    IndexedSeq.of = function () /*...values*/{
      return IndexedSeq(arguments);
    };

    IndexedSeq.prototype.toIndexedSeq = function () {
      return this;
    };

    IndexedSeq.prototype.toString = function () {
      return this.__toString('Seq [', ']');
    };

    IndexedSeq.prototype.__iterate = function (fn, reverse) {
      return seqIterate(this, fn, reverse, false);
    };

    IndexedSeq.prototype.__iterator = function (type, reverse) {
      return seqIterator(this, type, reverse, false);
    };

    createClass(SetSeq, Seq);
    function SetSeq(value) {
      return (value === null || value === undefined ? emptySequence() : !isIterable(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
    }

    SetSeq.of = function () /*...values*/{
      return SetSeq(arguments);
    };

    SetSeq.prototype.toSetSeq = function () {
      return this;
    };

    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;

    var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

    Seq.prototype[IS_SEQ_SENTINEL] = true;

    createClass(ArraySeq, IndexedSeq);
    function ArraySeq(array) {
      this._array = array;
      this.size = array.length;
    }

    ArraySeq.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
    };

    ArraySeq.prototype.__iterate = function (fn, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ArraySeq.prototype.__iterator = function (type, reverse) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator(function () {
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++]);
      });
    };

    createClass(ObjectSeq, KeyedSeq);
    function ObjectSeq(object) {
      var keys = Object.keys(object);
      this._object = object;
      this._keys = keys;
      this.size = keys.length;
    }

    ObjectSeq.prototype.get = function (key, notSetValue) {
      if (notSetValue !== undefined && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };

    ObjectSeq.prototype.has = function (key) {
      return this._object.hasOwnProperty(key);
    };

    ObjectSeq.prototype.__iterate = function (fn, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys[reverse ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    ObjectSeq.prototype.__iterator = function (type, reverse) {
      var object = this._object;
      var keys = this._keys;
      var maxIndex = keys.length - 1;
      var ii = 0;
      return new Iterator(function () {
        var key = keys[reverse ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, key, object[key]);
      });
    };

    ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;

    createClass(IterableSeq, IndexedSeq);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }

    IterableSeq.prototype.__iterateUncached = function (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      var iterations = 0;
      if (isIterator(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };

    IterableSeq.prototype.__iteratorUncached = function (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterable = this._iterable;
      var iterator = getIterator(iterable);
      if (!isIterator(iterator)) {
        return new Iterator(iteratorDone);
      }
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value);
      });
    };

    createClass(IteratorSeq, IndexedSeq);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }

    IteratorSeq.prototype.__iterateUncached = function (fn, reverse) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };

    IteratorSeq.prototype.__iteratorUncached = function (type, reverse) {
      if (reverse) {
        return this.cacheResult().__iterator(type, reverse);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator(function () {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue(type, iterations, cache[iterations++]);
      });
    };

    // # pragma Helper functions

    function isSeq(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }

    var EMPTY_SEQ;

    function emptySequence() {
      return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
    }

    function keyedSeqFromValue(value) {
      var seq = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === 'object' ? new ObjectSeq(value) : undefined;
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of [k, v] entries, ' + 'or keyed object: ' + value);
      }
      return seq;
    }

    function indexedSeqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value);
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values: ' + value);
      }
      return seq;
    }

    function seqFromValue(value) {
      var seq = maybeIndexedSeqFromValue(value) || typeof value === 'object' && new ObjectSeq(value);
      if (!seq) {
        throw new TypeError('Expected Array or iterable object of values, or keyed object: ' + value);
      }
      return seq;
    }

    function maybeIndexedSeqFromValue(value) {
      return isArrayLike(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : undefined;
    }

    function seqIterate(seq, fn, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse);
    }

    function seqIterator(seq, type, reverse, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator(function () {
          var entry = cache[reverse ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse);
    }

    function fromJS(json, converter) {
      return converter ? fromJSWith(converter, json, '', { '': json }) : fromJSDefault(json);
    }

    function fromJSWith(converter, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter.call(parentJSON, key, IndexedSeq(json).map(function (v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter.call(parentJSON, key, KeyedSeq(json).map(function (v, k) {
          return fromJSWith(converter, v, k, json);
        }));
      }
      return json;
    }

    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq(json).map(fromJSDefault).toMap();
      }
      return json;
    }

    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === undefined);
    }

    /**
     * An extension of the "same-value" algorithm as [described for use by ES6 Map
     * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
     *
     * NaN is considered the same as NaN, however -0 and 0 are considered the same
     * value, which is different from the algorithm described by
     * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
     *
     * This is extended further to allow Objects to describe the values they
     * represent, by way of `valueOf` or `equals` (and `hashCode`).
     *
     * Note: because of this extension, the key equality of Immutable.Map and the
     * value equality of Immutable.Set will differ from ES6 Map and Set.
     *
     * ### Defining custom values
     *
     * The easiest way to describe the value an object represents is by implementing
     * `valueOf`. For example, `Date` represents a value by returning a unix
     * timestamp for `valueOf`:
     *
     *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
     *     var date2 = new Date(1234567890000);
     *     date1.valueOf(); // 1234567890000
     *     assert( date1 !== date2 );
     *     assert( Immutable.is( date1, date2 ) );
     *
     * Note: overriding `valueOf` may have other implications if you use this object
     * where JavaScript expects a primitive, such as implicit string coercion.
     *
     * For more complex types, especially collections, implementing `valueOf` may
     * not be performant. An alternative is to implement `equals` and `hashCode`.
     *
     * `equals` takes another object, presumably of similar type, and returns true
     * if the it is equal. Equality is symmetrical, so the same result should be
     * returned if this and the argument are flipped.
     *
     *     assert( a.equals(b) === b.equals(a) );
     *
     * `hashCode` returns a 32bit integer number representing the object which will
     * be used to determine how to store the value object in a Map or Set. You must
     * provide both or neither methods, one must not exist without the other.
     *
     * Also, an important relationship between these methods must be upheld: if two
     * values are equal, they *must* return the same hashCode. If the values are not
     * equal, they might have the same hashCode; this is called a hash collision,
     * and while undesirable for performance reasons, it is acceptable.
     *
     *     if (a.equals(b)) {
     *       assert( a.hashCode() === b.hashCode() );
     *     }
     *
     * All Immutable collections implement `equals` and `hashCode`.
     *
     */
    function is(valueA, valueB) {
      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === 'function' && typeof valueB.equals === 'function' && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }

    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }

      if (!isIterable(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
        return false;
      }

      if (a.size === 0 && b.size === 0) {
        return true;
      }

      var notAssociative = !isAssociative(a);

      if (isOrdered(a)) {
        var entries = a.entries();
        return b.every(function (v, k) {
          var entry = entries.next().value;
          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
        }) && entries.next().done;
      }

      var flipped = false;

      if (a.size === undefined) {
        if (b.size === undefined) {
          if (typeof a.cacheResult === 'function') {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }

      var allEqual = true;
      var bSize = b.__iterate(function (v, k) {
        if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
          allEqual = false;
          return false;
        }
      });

      return allEqual && a.size === bSize;
    }

    createClass(Repeat, IndexedSeq);

    function Repeat(value, times) {
      if (!(this instanceof Repeat)) {
        return new Repeat(value, times);
      }
      this._value = value;
      this.size = times === undefined ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }

    Repeat.prototype.toString = function () {
      if (this.size === 0) {
        return 'Repeat []';
      }
      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
    };

    Repeat.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };

    Repeat.prototype.includes = function (searchValue) {
      return is(this._value, searchValue);
    };

    Repeat.prototype.slice = function (begin, end) {
      var size = this.size;
      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
    };

    Repeat.prototype.reverse = function () {
      return this;
    };

    Repeat.prototype.indexOf = function (searchValue) {
      if (is(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };

    Repeat.prototype.lastIndexOf = function (searchValue) {
      if (is(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };

    Repeat.prototype.__iterate = function (fn, reverse) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };

    Repeat.prototype.__iterator = function (type, reverse) {
      var this$0 = this;
      var ii = 0;
      return new Iterator(function () {
        return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone();
      });
    };

    Repeat.prototype.equals = function (other) {
      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);
    };

    var EMPTY_REPEAT;

    function invariant(condition, error) {
      if (!condition) throw new Error(error);
    }

    createClass(Range, IndexedSeq);

    function Range(start, end, step) {
      if (!(this instanceof Range)) {
        return new Range(start, end, step);
      }
      invariant(step !== 0, 'Cannot step a Range by 0');
      start = start || 0;
      if (end === undefined) {
        end = Infinity;
      }
      step = step === undefined ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE) {
          return EMPTY_RANGE;
        }
        EMPTY_RANGE = this;
      }
    }

    Range.prototype.toString = function () {
      if (this.size === 0) {
        return 'Range []';
      }
      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';
    };

    Range.prototype.get = function (index, notSetValue) {
      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
    };

    Range.prototype.includes = function (searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };

    Range.prototype.slice = function (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin(begin, this.size);
      end = resolveEnd(end, this.size);
      if (end <= begin) {
        return new Range(0, 0);
      }
      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
    };

    Range.prototype.indexOf = function (searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };

    Range.prototype.lastIndexOf = function (searchValue) {
      return this.indexOf(searchValue);
    };

    Range.prototype.__iterate = function (fn, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse ? -step : step;
      }
      return ii;
    };

    Range.prototype.__iterator = function (type, reverse) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator(function () {
        var v = value;
        value += reverse ? -step : step;
        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
      });
    };

    Range.prototype.equals = function (other) {
      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
    };

    var EMPTY_RANGE;

    createClass(Collection, Iterable);
    function Collection() {
      throw TypeError('Abstract');
    }

    createClass(KeyedCollection, Collection);function KeyedCollection() {}

    createClass(IndexedCollection, Collection);function IndexedCollection() {}

    createClass(SetCollection, Collection);function SetCollection() {}

    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;

    var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {
      a = a | 0; // int
      b = b | 0; // int
      var c = a & 0xffff;
      var d = b & 0xffff;
      // Shift by 0 fixes the sign on the high part.
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int
    };

    // v8 has an optimization for storing 31-bit signed numbers.
    // Values which have either 00 or 11 as the high order bits qualify.
    // This function drops the highest order bit in a signed number, maintaining
    // the sign bit.
    function smi(i32) {
      return i32 >>> 1 & 0x40000000 | i32 & 0xBFFFFFFF;
    }

    function hash(o) {
      if (o === false || o === null || o === undefined) {
        return 0;
      }
      if (typeof o.valueOf === 'function') {
        o = o.valueOf();
        if (o === false || o === null || o === undefined) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = typeof o;
      if (type === 'number') {
        if (o !== o || o === Infinity) {
          return 0;
        }
        var h = o | 0;
        if (h !== o) {
          h ^= o * 0xFFFFFFFF;
        }
        while (o > 0xFFFFFFFF) {
          o /= 0xFFFFFFFF;
          h ^= o;
        }
        return smi(h);
      }
      if (type === 'string') {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
      }
      if (typeof o.hashCode === 'function') {
        return o.hashCode();
      }
      if (type === 'object') {
        return hashJSObj(o);
      }
      if (typeof o.toString === 'function') {
        return hashString(o.toString());
      }
      throw new Error('Value type ' + type + ' cannot be hashed.');
    }

    function cachedHashString(string) {
      var hash = stringHashCache[string];
      if (hash === undefined) {
        hash = hashString(string);
        if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
          STRING_HASH_CACHE_SIZE = 0;
          stringHashCache = {};
        }
        STRING_HASH_CACHE_SIZE++;
        stringHashCache[string] = hash;
      }
      return hash;
    }

    // http://jsperf.com/hashing-strings
    function hashString(string) {
      // This is the hash from JVM
      // The hash code for a string is computed as
      // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
      // where s[i] is the ith character of the string and n is the length of
      // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
      // (exclusive) by dropping high bits.
      var hash = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash = 31 * hash + string.charCodeAt(ii) | 0;
      }
      return smi(hash);
    }

    function hashJSObj(obj) {
      var hash;
      if (usingWeakMap) {
        hash = weakMap.get(obj);
        if (hash !== undefined) {
          return hash;
        }
      }

      hash = obj[UID_HASH_KEY];
      if (hash !== undefined) {
        return hash;
      }

      if (!canDefineProperty) {
        hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
        if (hash !== undefined) {
          return hash;
        }

        hash = getIENodeHash(obj);
        if (hash !== undefined) {
          return hash;
        }
      }

      hash = ++objHashUID;
      if (objHashUID & 0x40000000) {
        objHashUID = 0;
      }

      if (usingWeakMap) {
        weakMap.set(obj, hash);
      } else if (isExtensible !== undefined && isExtensible(obj) === false) {
        throw new Error('Non-extensible objects are not allowed as keys.');
      } else if (canDefineProperty) {
        Object.defineProperty(obj, UID_HASH_KEY, {
          'enumerable': false,
          'configurable': false,
          'writable': false,
          'value': hash
        });
      } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        // Since we can't define a non-enumerable property on the object
        // we'll hijack one of the less-used non-enumerable properties to
        // save our hash on it. Since this is a function it will not show up in
        // `JSON.stringify` which is what we want.
        obj.propertyIsEnumerable = function () {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
      } else if (obj.nodeType !== undefined) {
        // At this point we couldn't get the IE `uniqueID` to use as a hash
        // and we couldn't use a non-enumerable property to exploit the
        // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
        // itself.
        obj[UID_HASH_KEY] = hash;
      } else {
        throw new Error('Unable to set a non-enumerable property on object.');
      }

      return hash;
    }

    // Get references to ES5 object methods.
    var isExtensible = Object.isExtensible;

    // True if Object.defineProperty works as expected. IE8 fails this test.
    var canDefineProperty = function () {
      try {
        Object.defineProperty({}, '@', {});
        return true;
      } catch (e) {
        return false;
      }
    }();

    // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
    // and avoid memory leaks from the IE cloneNode bug.
    function getIENodeHash(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            // Element
            return node.uniqueID;
          case 9:
            // Document
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }

    // If possible, use a WeakMap.
    var usingWeakMap = typeof WeakMap === 'function';
    var weakMap;
    if (usingWeakMap) {
      weakMap = new WeakMap();
    }

    var objHashUID = 0;

    var UID_HASH_KEY = '__immutablehash__';
    if (typeof Symbol === 'function') {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }

    var STRING_HASH_CACHE_MIN_STRLEN = 16;
    var STRING_HASH_CACHE_MAX_SIZE = 255;
    var STRING_HASH_CACHE_SIZE = 0;
    var stringHashCache = {};

    function assertNotInfinite(size) {
      invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');
    }

    createClass(Map, KeyedCollection);

    // @pragma Construction

    function Map(value) {
      return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v, k) {
          return map.set(k, v);
        });
      });
    }

    Map.of = function () {
      var keyValues = SLICE$0.call(arguments, 0);
      return emptyMap().withMutations(function (map) {
        for (var i = 0; i < keyValues.length; i += 2) {
          if (i + 1 >= keyValues.length) {
            throw new Error('Missing value for key: ' + keyValues[i]);
          }
          map.set(keyValues[i], keyValues[i + 1]);
        }
      });
    };

    Map.prototype.toString = function () {
      return this.__toString('Map {', '}');
    };

    // @pragma Access

    Map.prototype.get = function (k, notSetValue) {
      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;
    };

    // @pragma Modification

    Map.prototype.set = function (k, v) {
      return updateMap(this, k, v);
    };

    Map.prototype.setIn = function (keyPath, v) {
      return this.updateIn(keyPath, NOT_SET, function () {
        return v;
      });
    };

    Map.prototype.remove = function (k) {
      return updateMap(this, k, NOT_SET);
    };

    Map.prototype.deleteIn = function (keyPath) {
      return this.updateIn(keyPath, function () {
        return NOT_SET;
      });
    };

    Map.prototype.update = function (k, notSetValue, updater) {
      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
    };

    Map.prototype.updateIn = function (keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = undefined;
      }
      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
      return updatedValue === NOT_SET ? undefined : updatedValue;
    };

    Map.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyMap();
    };

    // @pragma Composition

    Map.prototype.merge = function () /*...iters*/{
      return mergeIntoMapWith(this, undefined, arguments);
    };

    Map.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };

    Map.prototype.mergeIn = function (keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function (m) {
        return typeof m.merge === 'function' ? m.merge.apply(m, iters) : iters[iters.length - 1];
      });
    };

    Map.prototype.mergeDeep = function () /*...iters*/{
      return mergeIntoMapWith(this, deepMerger, arguments);
    };

    Map.prototype.mergeDeepWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
    };

    Map.prototype.mergeDeepIn = function (keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap(), function (m) {
        return typeof m.mergeDeep === 'function' ? m.mergeDeep.apply(m, iters) : iters[iters.length - 1];
      });
    };

    Map.prototype.sort = function (comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator));
    };

    Map.prototype.sortBy = function (mapper, comparator) {
      // Late binding
      return OrderedMap(sortFactory(this, comparator, mapper));
    };

    // @pragma Mutability

    Map.prototype.withMutations = function (fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };

    Map.prototype.asMutable = function () {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
    };

    Map.prototype.asImmutable = function () {
      return this.__ensureOwner();
    };

    Map.prototype.wasAltered = function () {
      return this.__altered;
    };

    Map.prototype.__iterator = function (type, reverse) {
      return new MapIterator(this, type, reverse);
    };

    Map.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function (entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse);
      return iterations;
    };

    Map.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap(this.size, this._root, ownerID, this.__hash);
    };

    function isMap(maybeMap) {
      return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
    }

    Map.isMap = isMap;

    var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

    var MapPrototype = Map.prototype;
    MapPrototype[IS_MAP_SENTINEL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeIn = MapPrototype.deleteIn;

    // #pragma Trie Nodes


    function ArrayMapNode(ownerID, entries) {
      this.ownerID = ownerID;
      this.entries = entries;
    }

    ArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    ArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && entries.length === 1) {
        return; // undefined
      }

      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries, key, value);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new ArrayMapNode(ownerID, newEntries);
    };

    function BitmapIndexedNode(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }

    BitmapIndexedNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
    };

    BitmapIndexedNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;

      if (!exists && value === NOT_SET) {
        return this;
      }

      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : undefined;
      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

      if (newNode === node) {
        return this;
      }

      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }

      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }

      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }

      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };

    function HashArrayMapNode(ownerID, count, nodes) {
      this.ownerID = ownerID;
      this.count = count;
      this.nodes = nodes;
    }

    HashArrayMapNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };

    HashArrayMapNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];

      if (removed && !node) {
        return this;
      }

      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }

      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn(nodes, idx, newNode, isEditable);

      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }

      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };

    function HashCollisionNode(ownerID, keyHash, entries) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries;
    }

    HashCollisionNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      var entries = this.entries;
      for (var ii = 0, len = entries.length; ii < len; ii++) {
        if (is(key, entries[ii][0])) {
          return entries[ii][1];
        }
      }
      return notSetValue;
    };

    HashCollisionNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === undefined) {
        keyHash = hash(key);
      }

      var removed = value === NOT_SET;

      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
      }

      var entries = this.entries;
      var idx = 0;
      for (var len = entries.length; idx < len; idx++) {
        if (is(key, entries[idx][0])) {
          break;
        }
      }
      var exists = idx < len;

      if (exists ? entries[idx][1] === value : removed) {
        return this;
      }

      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);

      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
      }

      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries : arrCopy(entries);

      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }

      if (isEditable) {
        this.entries = newEntries;
        return this;
      }

      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };

    function ValueNode(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }

    ValueNode.prototype.get = function (shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };

    ValueNode.prototype.update = function (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }

      SetRef(didAlter);

      if (removed) {
        SetRef(didChangeSize);
        return; // undefined
      }

      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value]);
      }

      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
    };

    // #pragma Iterators

    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {
      var entries = this.entries;
      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };

    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse) === false) {
          return false;
        }
      }
    };

    ValueNode.prototype.iterate = function (fn, reverse) {
      return fn(this.entry);
    };

    createClass(MapIterator, Iterator);

    function MapIterator(map, type, reverse) {
      this._type = type;
      this._reverse = reverse;
      this._stack = map._root && mapIteratorFrame(map._root);
    }

    MapIterator.prototype.next = function () {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone();
    };

    function mapIteratorValue(type, entry) {
      return iteratorValue(type, entry[0], entry[1]);
    }

    function mapIteratorFrame(node, prev) {
      return {
        node: node,
        index: 0,
        __prev: prev
      };
    }

    function makeMap(size, root, ownerID, hash) {
      var map = Object.create(MapPrototype);
      map.size = size;
      map._root = root;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }

    var EMPTY_MAP;
    function emptyMap() {
      return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
    }

    function updateMap(map, k, v) {
      var newRoot;
      var newSize;
      if (!map._root) {
        if (v === NOT_SET) {
          return map;
        }
        newSize = 1;
        newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef(CHANGE_LENGTH);
        var didAlter = MakeRef(DID_ALTER);
        newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map;
        }
        newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
      }
      if (map.__ownerID) {
        map.size = newSize;
        map._root = newRoot;
        map.__hash = undefined;
        map.__altered = true;
        return map;
      }
      return newRoot ? makeMap(newSize, newRoot) : emptyMap();
    }

    function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET) {
          return node;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return new ValueNode(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }

    function isLeafNode(node) {
      return node.constructor === ValueNode || node.constructor === HashCollisionNode;
    }

    function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
      }

      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);

      return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }

    function createNodes(ownerID, entries, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID();
      }
      var node = new ValueNode(ownerID, hash(key), [key, value]);
      for (var ii = 0; ii < entries.length; ii++) {
        var entry = entries[ii];
        node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
      }
      return node;
    }

    function packNodes(ownerID, nodes, count, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== undefined && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
    }

    function expandNodes(ownerID, nodes, bitmap, including, node) {
      var count = 0;
      var expandedNodes = new Array(SIZE);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
    }

    function mergeIntoMapWith(map, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function (v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map, merger, iters);
    }

    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is(existing, value) ? existing : value;
    }

    function deepMergerWith(merger) {
      return function (existing, value, key) {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is(existing, nextValue) ? existing : nextValue;
      };
    }

    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function (x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function (collection) {
        var mergeIntoMap = merger ? function (value, key) {
          collection.update(key, NOT_SET, function (existing) {
            return existing === NOT_SET ? value : merger(existing, value, key);
          });
        } : function (value, key) {
          collection.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }

    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant(isNotSet || existing && existing.set, 'invalid keyPath');
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? existing.remove(key) : (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
    }

    function popCount(x) {
      x = x - (x >> 1 & 0x55555555);
      x = (x & 0x33333333) + (x >> 2 & 0x33333333);
      x = x + (x >> 4) & 0x0f0f0f0f;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 0x7f;
    }

    function setIn(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy(array);
      newArray[idx] = val;
      return newArray;
    }

    function spliceIn(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }

    function spliceOut(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }

    var MAX_ARRAY_MAP_SIZE = SIZE / 4;
    var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

    createClass(List, IndexedCollection);

    // @pragma Construction

    function List(value) {
      var empty = emptyList();
      if (value === null || value === undefined) {
        return empty;
      }
      if (isList(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite(size);
      if (size > 0 && size < SIZE) {
        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
      }
      return empty.withMutations(function (list) {
        list.setSize(size);
        iter.forEach(function (v, i) {
          return list.set(i, v);
        });
      });
    }

    List.of = function () /*...values*/{
      return this(arguments);
    };

    List.prototype.toString = function () {
      return this.__toString('List [', ']');
    };

    // @pragma Access

    List.prototype.get = function (index, notSetValue) {
      index = wrapIndex(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor(this, index);
        return node && node.array[index & MASK];
      }
      return notSetValue;
    };

    // @pragma Modification

    List.prototype.set = function (index, value) {
      return updateList(this, index, value);
    };

    List.prototype.remove = function (index) {
      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
    };

    List.prototype.insert = function (index, value) {
      return this.splice(index, 0, value);
    };

    List.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT;
        this._root = this._tail = null;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyList();
    };

    List.prototype.push = function () /*...values*/{
      var values = arguments;
      var oldSize = this.size;
      return this.withMutations(function (list) {
        setListBounds(list, 0, oldSize + values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(oldSize + ii, values[ii]);
        }
      });
    };

    List.prototype.pop = function () {
      return setListBounds(this, 0, -1);
    };

    List.prototype.unshift = function () /*...values*/{
      var values = arguments;
      return this.withMutations(function (list) {
        setListBounds(list, -values.length);
        for (var ii = 0; ii < values.length; ii++) {
          list.set(ii, values[ii]);
        }
      });
    };

    List.prototype.shift = function () {
      return setListBounds(this, 1);
    };

    // @pragma Composition

    List.prototype.merge = function () /*...iters*/{
      return mergeIntoListWith(this, undefined, arguments);
    };

    List.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };

    List.prototype.mergeDeep = function () /*...iters*/{
      return mergeIntoListWith(this, deepMerger, arguments);
    };

    List.prototype.mergeDeepWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith(merger), iters);
    };

    List.prototype.setSize = function (size) {
      return setListBounds(this, 0, size);
    };

    // @pragma Iteration

    List.prototype.slice = function (begin, end) {
      var size = this.size;
      if (wholeSlice(begin, end, size)) {
        return this;
      }
      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
    };

    List.prototype.__iterator = function (type, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      return new Iterator(function () {
        var value = values();
        return value === DONE ? iteratorDone() : iteratorValue(type, index++, value);
      });
    };

    List.prototype.__iterate = function (fn, reverse) {
      var index = 0;
      var values = iterateList(this, reverse);
      var value;
      while ((value = values()) !== DONE) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };

    List.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };

    function isList(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }

    List.isList = isList;

    var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

    var ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SENTINEL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.setIn = MapPrototype.setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
    ListPrototype.update = MapPrototype.update;
    ListPrototype.updateIn = MapPrototype.updateIn;
    ListPrototype.mergeIn = MapPrototype.mergeIn;
    ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    ListPrototype.withMutations = MapPrototype.withMutations;
    ListPrototype.asMutable = MapPrototype.asMutable;
    ListPrototype.asImmutable = MapPrototype.asImmutable;
    ListPrototype.wasAltered = MapPrototype.wasAltered;

    function VNode(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }

    // TODO: seems like these methods are very similar

    VNode.prototype.removeBefore = function (ownerID, level, index) {
      if (index === level ? 1 << level : 0 || this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = undefined;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };

    VNode.prototype.removeAfter = function (ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }

      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }

      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };

    var DONE = {};

    function iterateList(list, reverse) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset(right);
      var tail = list._tail;

      return iterateNodeOrLeaf(list._root, list._level, 0);

      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
      }

      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE) {
          to = SIZE;
        }
        return function () {
          if (from === to) {
            return DONE;
          }
          var idx = reverse ? --to : from++;
          return array && array[idx];
        };
      }

      function iterateNode(node, level, offset) {
        var values;
        var array = node && node.array;
        var from = offset > left ? 0 : left - offset >> level;
        var to = (right - offset >> level) + 1;
        if (to > SIZE) {
          to = SIZE;
        }
        return function () {
          do {
            if (values) {
              var value = values();
              if (value !== DONE) {
                return value;
              }
              values = null;
            }
            if (from === to) {
              return DONE;
            }
            var idx = reverse ? --to : from++;
            values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
          } while (true);
        };
      }
    }

    function makeList(origin, capacity, level, root, tail, ownerID, hash) {
      var list = Object.create(ListPrototype);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash;
      list.__altered = false;
      return list;
    }

    var EMPTY_LIST;
    function emptyList() {
      return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
    }

    function updateList(list, index, value) {
      index = wrapIndex(list, index);

      if (index !== index) {
        return list;
      }

      if (index >= list.size || index < 0) {
        return list.withMutations(function (list) {
          index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);
        });
      }

      index += list._origin;

      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef(DID_ALTER);
      if (index >= getTailOffset(list._capacity)) {
        newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }

      if (!didAlter.value) {
        return list;
      }

      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
    }

    function updateVNode(node, ownerID, level, index, value, didAlter) {
      var idx = index >>> level & MASK;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === undefined) {
        return node;
      }

      var newNode;

      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }

      if (nodeHas && node.array[idx] === value) {
        return node;
      }

      SetRef(didAlter);

      newNode = editableVNode(node, ownerID);
      if (value === undefined && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }

    function editableVNode(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode(node ? node.array.slice() : [], ownerID);
    }

    function listNodeFor(list, rawIndex) {
      if (rawIndex >= getTailOffset(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << list._level + SHIFT) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[rawIndex >>> level & MASK];
          level -= SHIFT;
        }
        return node;
      }
    }

    function setListBounds(list, begin, end) {
      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        end = end | 0;
      }
      var owner = list.__ownerID || new OwnerID();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }

      // If it's going to end after it starts, it's empty.
      if (newOrigin >= newCapacity) {
        return list.clear();
      }

      var newLevel = list._level;
      var newRoot = list._root;

      // New origin might need creating a higher root.
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
        newLevel += SHIFT;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }

      var oldTailOffset = getTailOffset(oldCapacity);
      var newTailOffset = getTailOffset(newCapacity);

      // New size might need creating a higher root.
      while (newTailOffset >= 1 << newLevel + SHIFT) {
        newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT;
      }

      // Locate or create the new tail.
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

      // Merge Tail into tree.
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT; level -= SHIFT) {
          var idx = oldTailOffset >>> level & MASK;
          node = node.array[idx] = editableVNode(node.array[idx], owner);
        }
        node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
      }

      // If the size has been reduced, there's a chance the tail needs to be trimmed.
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }

      // If the new origin is within the tail, then we do not need a root.
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

        // Otherwise, if the root has been trimmed, garbage collect.
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;

        // Identify the new top root node of the subtree of the old root.
        while (newRoot) {
          var beginIndex = newOrigin >>> newLevel & MASK;
          if (beginIndex !== newTailOffset >>> newLevel & MASK) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT;
          newRoot = newRoot.array[beginIndex];
        }

        // Trim the new sides of the new root.
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }

      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = undefined;
        list.__altered = true;
        return list;
      }
      return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }

    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function (v) {
            return fromJS(v);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }

    function getTailOffset(size) {
      return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
    }

    createClass(OrderedMap, Map);

    // @pragma Construction

    function OrderedMap(value) {
      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {
        var iter = KeyedIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v, k) {
          return map.set(k, v);
        });
      });
    }

    OrderedMap.of = function () /*...values*/{
      return this(arguments);
    };

    OrderedMap.prototype.toString = function () {
      return this.__toString('OrderedMap {', '}');
    };

    // @pragma Access

    OrderedMap.prototype.get = function (k, notSetValue) {
      var index = this._map.get(k);
      return index !== undefined ? this._list.get(index)[1] : notSetValue;
    };

    // @pragma Modification

    OrderedMap.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap();
    };

    OrderedMap.prototype.set = function (k, v) {
      return updateOrderedMap(this, k, v);
    };

    OrderedMap.prototype.remove = function (k) {
      return updateOrderedMap(this, k, NOT_SET);
    };

    OrderedMap.prototype.wasAltered = function () {
      return this._map.wasAltered() || this._list.wasAltered();
    };

    OrderedMap.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._list.__iterate(function (entry) {
        return entry && fn(entry[1], entry[0], this$0);
      }, reverse);
    };

    OrderedMap.prototype.__iterator = function (type, reverse) {
      return this._list.fromEntrySeq().__iterator(type, reverse);
    };

    OrderedMap.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
    };

    function isOrderedMap(maybeOrderedMap) {
      return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
    }

    OrderedMap.isOrderedMap = isOrderedMap;

    OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

    function makeOrderedMap(map, list, ownerID, hash) {
      var omap = Object.create(OrderedMap.prototype);
      omap.size = map ? map.size : 0;
      omap._map = map;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash;
      return omap;
    }

    var EMPTY_ORDERED_MAP;
    function emptyOrderedMap() {
      return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
    }

    function updateOrderedMap(omap, k, v) {
      var map = omap._map;
      var list = omap._list;
      var i = map.get(k);
      var has = i !== undefined;
      var newMap;
      var newList;
      if (v === NOT_SET) {
        // removed
        if (!has) {
          return omap;
        }
        if (list.size >= SIZE && list.size >= map.size * 2) {
          newList = list.filter(function (entry, idx) {
            return entry !== undefined && i !== idx;
          });
          newMap = newList.toKeyedSeq().map(function (entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
        }
      } else {
        if (has) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = undefined;
        return omap;
      }
      return makeOrderedMap(newMap, newList);
    }

    createClass(ToKeyedSequence, KeyedSeq);
    function ToKeyedSequence(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }

    ToKeyedSequence.prototype.get = function (key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };

    ToKeyedSequence.prototype.has = function (key) {
      return this._iter.has(key);
    };

    ToKeyedSequence.prototype.valueSeq = function () {
      return this._iter.valueSeq();
    };

    ToKeyedSequence.prototype.reverse = function () {
      var this$0 = this;
      var reversedSequence = reverseFactory(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function () {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };

    ToKeyedSequence.prototype.map = function (mapper, context) {
      var this$0 = this;
      var mappedSequence = mapFactory(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function () {
          return this$0._iter.toSeq().map(mapper, context);
        };
      }
      return mappedSequence;
    };

    ToKeyedSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(this._useKeys ? function (v, k) {
        return fn(v, k, this$0);
      } : (ii = reverse ? resolveSize(this) : 0, function (v) {
        return fn(v, reverse ? --ii : ii++, this$0);
      }), reverse);
    };

    ToKeyedSequence.prototype.__iterator = function (type, reverse) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var ii = reverse ? resolveSize(this) : 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, reverse ? --ii : ii++, step.value, step);
      });
    };

    ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;

    createClass(ToIndexedSequence, IndexedSeq);
    function ToIndexedSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToIndexedSequence.prototype.includes = function (value) {
      return this._iter.includes(value);
    };

    ToIndexedSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function (v) {
        return fn(v, iterations++, this$0);
      }, reverse);
    };

    ToIndexedSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      var iterations = 0;
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, iterations++, step.value, step);
      });
    };

    createClass(ToSetSequence, SetSeq);
    function ToSetSequence(iter) {
      this._iter = iter;
      this.size = iter.size;
    }

    ToSetSequence.prototype.has = function (key) {
      return this._iter.includes(key);
    };

    ToSetSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function (v) {
        return fn(v, v, this$0);
      }, reverse);
    };

    ToSetSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        return step.done ? step : iteratorValue(type, step.value, step.value, step);
      });
    };

    createClass(FromEntriesSequence, KeyedSeq);
    function FromEntriesSequence(entries) {
      this._iter = entries;
      this.size = entries.size;
    }

    FromEntriesSequence.prototype.entrySeq = function () {
      return this._iter.toSeq();
    };

    FromEntriesSequence.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._iter.__iterate(function (entry) {
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedIterable = isIterable(entry);
          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
        }
      }, reverse);
    };

    FromEntriesSequence.prototype.__iterator = function (type, reverse) {
      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
      return new Iterator(function () {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          // Check if entry exists first so array access doesn't throw for holes
          // in the parent iteration.
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
          }
        }
      });
    };

    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

    function flipFactory(iterable) {
      var flipSequence = makeSequence(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function () {
        return iterable;
      };
      flipSequence.reverse = function () {
        var reversedSequence = iterable.reverse.apply(this); // super.reverse()
        reversedSequence.flip = function () {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function (key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function (key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough;
      flipSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k) {
          return fn(k, v, this$0) !== false;
        }, reverse);
      };
      flipSequence.__iteratorUncached = function (type, reverse) {
        if (type === ITERATE_ENTRIES) {
          var iterator = iterable.__iterator(type, reverse);
          return new Iterator(function () {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);
      };
      return flipSequence;
    }

    function mapFactory(iterable, mapper, context) {
      var mappedSequence = makeSequence(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function (key) {
        return iterable.has(key);
      };
      mappedSequence.get = function (key, notSetValue) {
        var v = iterable.get(key, NOT_SET);
        return v === NOT_SET ? notSetValue : mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k, c) {
          return fn(mapper.call(context, v, k, c), k, this$0) !== false;
        }, reverse);
      };
      mappedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        return new Iterator(function () {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue(type, key, mapper.call(context, entry[1], key, iterable), step);
        });
      };
      return mappedSequence;
    }

    function reverseFactory(iterable, useKeys) {
      var reversedSequence = makeSequence(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function () {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function () {
          var flipSequence = flipFactory(iterable);
          flipSequence.reverse = function () {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function (key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function (key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function (value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough;
      reversedSequence.__iterate = function (fn, reverse) {
        var this$0 = this;
        return iterable.__iterate(function (v, k) {
          return fn(v, k, this$0);
        }, !reverse);
      };
      reversedSequence.__iterator = function (type, reverse) {
        return iterable.__iterator(type, !reverse);
      };
      return reversedSequence;
    }

    function filterFactory(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence(iterable);
      if (useKeys) {
        filterSequence.has = function (key) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function (key, notSetValue) {
          var v = iterable.get(key, NOT_SET);
          return v !== NOT_SET && predicate.call(context, v, key, iterable) ? v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse);
        return iterations;
      };
      filterSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterations = 0;
        return new Iterator(function () {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }

    function countByFactory(iterable, grouper, context) {
      var groups = Map().asMutable();
      iterable.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, iterable), 0, function (a) {
          return a + 1;
        });
      });
      return groups.asImmutable();
    }

    function groupByFactory(iterable, grouper, context) {
      var isKeyedIter = isKeyed(iterable);
      var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
      iterable.__iterate(function (v, k) {
        groups.update(grouper.call(context, v, k, iterable), function (a) {
          return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
        });
      });
      var coerce = iterableClass(iterable);
      return groups.map(function (arr) {
        return reify(iterable, coerce(arr));
      });
    }

    function sliceFactory(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;

      // Sanitize begin & end using this shorthand for ToInt32(argument)
      // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
      if (begin !== undefined) {
        begin = begin | 0;
      }
      if (end !== undefined) {
        if (end === Infinity) {
          end = originalSize;
        } else {
          end = end | 0;
        }
      }

      if (wholeSlice(begin, end, originalSize)) {
        return iterable;
      }

      var resolvedBegin = resolveBegin(begin, originalSize);
      var resolvedEnd = resolveEnd(end, originalSize);

      // begin or end will be NaN if they were provided as negative numbers and
      // this iterable's size is unknown. In that case, cache first so there is
      // a known size and these do not resolve to NaN.
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }

      // Note: resolvedEnd is undefined when the original sequence's length is
      // unknown and this slice did not supply an end and should contain all
      // elements after resolvedBegin.
      // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }

      var sliceSeq = makeSequence(iterable);

      // If iterable.size is undefined, the size of the realized sliceSeq is
      // unknown at this point unless the number of items to slice is 0
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

      if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
        sliceSeq.get = function (index, notSetValue) {
          index = wrapIndex(this, index);
          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
        };
      }

      sliceSeq.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function (v, k) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };

      sliceSeq.__iteratorUncached = function (type, reverse) {
        if (sliceSize !== 0 && reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        // Don't bother instantiating parent iterator if taking 0.
        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
        var skipped = 0;
        var iterations = 0;
        return new Iterator(function () {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          } else if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations - 1, undefined, step);
          } else {
            return iteratorValue(type, iterations - 1, step.value[1], step);
          }
        });
      };

      return sliceSeq;
    }

    function takeWhileFactory(iterable, predicate, context) {
      var takeSequence = makeSequence(iterable);
      takeSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
        });
        return iterations;
      };
      takeSequence.__iteratorUncached = function (type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var iterating = true;
        return new Iterator(function () {
          if (!iterating) {
            return iteratorDone();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone();
          }
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return takeSequence;
    }

    function skipWhileFactory(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence(iterable);
      skipSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterate(fn, reverse);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function (v, k, c) {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function (type, reverse) {
        var this$0 = this;
        if (reverse) {
          return this.cacheResult().__iterator(type, reverse);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
        var skipping = true;
        var iterations = 0;
        return new Iterator(function () {
          var step, k, v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES) {
                return step;
              } else if (type === ITERATE_KEYS) {
                return iteratorValue(type, iterations++, undefined, step);
              } else {
                return iteratorValue(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
        });
      };
      return skipSequence;
    }

    function concatFactory(iterable, values) {
      var isKeyedIterable = isKeyed(iterable);
      var iters = [iterable].concat(values).map(function (v) {
        if (!isIterable(v)) {
          v = isKeyedIterable ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function (v) {
        return v.size !== 0;
      });

      if (iters.length === 0) {
        return iterable;
      }

      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed(iterable) && isIndexed(singleton)) {
          return singleton;
        }
      }

      var concatSeq = new ArraySeq(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(function (sum, seq) {
        if (sum !== undefined) {
          var size = seq.size;
          if (size !== undefined) {
            return sum + size;
          }
        }
      }, 0);
      return concatSeq;
    }

    function flattenFactory(iterable, depth, useKeys) {
      var flatSequence = makeSequence(iterable);
      flatSequence.__iterateUncached = function (fn, reverse) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function (v, k) {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(type, reverse);
        var stack = [];
        var iterations = 0;
        return new Iterator(function () {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse);
            } else {
              return useKeys ? step : iteratorValue(type, iterations++, v, step);
            }
          }
          return iteratorDone();
        });
      };
      return flatSequence;
    }

    function flatMapFactory(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(function (v, k) {
        return coerce(mapper.call(context, v, k, iterable));
      }).flatten(true);
    }

    function interposeFactory(iterable, separator) {
      var interposedSequence = makeSequence(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function (fn, reverse) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function (v, k) {
          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
        }, reverse);
        return iterations;
      };
      interposedSequence.__iteratorUncached = function (type, reverse) {
        var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
        var iterations = 0;
        var step;
        return new Iterator(function () {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }

    function sortFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      var isKeyedIterable = isKeyed(iterable);
      var index = 0;
      var entries = iterable.toSeq().map(function (v, k) {
        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
      }).toArray();
      entries.sort(function (a, b) {
        return comparator(a[3], b[3]) || a[2] - b[2];
      }).forEach(isKeyedIterable ? function (v, i) {
        entries[i].length = 2;
      } : function (v, i) {
        entries[i] = v[1];
      });
      return isKeyedIterable ? KeyedSeq(entries) : isIndexed(iterable) ? IndexedSeq(entries) : SetSeq(entries);
    }

    function maxFactory(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function (v, k) {
          return [v, mapper(v, k, iterable)];
        }).reduce(function (a, b) {
          return maxCompare(comparator, a[1], b[1]) ? b : a;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function (a, b) {
          return maxCompare(comparator, a, b) ? b : a;
        });
      }
    }

    function maxCompare(comparator, a, b) {
      var comp = comparator(b, a);
      // b is considered the new max if the comparator declares them equal, but
      // they are not equal and b is in fact a nullish value.
      return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;
    }

    function zipWithFactory(keyIter, zipper, iters) {
      var zipSequence = makeSequence(keyIter);
      zipSequence.size = new ArraySeq(iters).map(function (i) {
        return i.size;
      }).min();
      // Note: this a generic base implementation of __iterate in terms of
      // __iterator which may be more generically useful in the future.
      zipSequence.__iterate = function (fn, reverse) {
        /* generic:
        var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          iterations++;
          if (fn(step.value[1], step.value[0], this) === false) {
            break;
          }
        }
        return iterations;
        */
        // indexed:
        var iterator = this.__iterator(ITERATE_VALUES, reverse);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function (type, reverse) {
        var iterators = iters.map(function (i) {
          return i = Iterable(i), getIterator(reverse ? i.reverse() : i);
        });
        var iterations = 0;
        var isDone = false;
        return new Iterator(function () {
          var steps;
          if (!isDone) {
            steps = iterators.map(function (i) {
              return i.next();
            });
            isDone = steps.some(function (s) {
              return s.done;
            });
          }
          if (isDone) {
            return iteratorDone();
          }
          return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {
            return s.value;
          })));
        });
      };
      return zipSequence;
    }

    // #pragma Helper Functions

    function reify(iter, seq) {
      return isSeq(iter) ? seq : iter.constructor(seq);
    }

    function validateEntry(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError('Expected [K, V] tuple: ' + entry);
      }
    }

    function resolveSize(iter) {
      assertNotInfinite(iter.size);
      return ensureSize(iter);
    }

    function iterableClass(iterable) {
      return isKeyed(iterable) ? KeyedIterable : isIndexed(iterable) ? IndexedIterable : SetIterable;
    }

    function makeSequence(iterable) {
      return Object.create((isKeyed(iterable) ? KeyedSeq : isIndexed(iterable) ? IndexedSeq : SetSeq).prototype);
    }

    function cacheResultThrough() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq.prototype.cacheResult.call(this);
      }
    }

    function defaultComparator(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }

    function forceIterator(keyPath) {
      var iter = getIterator(keyPath);
      if (!iter) {
        // Array might not be iterable in this environment, so we need a fallback
        // to our wrapped type.
        if (!isArrayLike(keyPath)) {
          throw new TypeError('Expected iterable or array-like: ' + keyPath);
        }
        iter = getIterator(Iterable(keyPath));
      }
      return iter;
    }

    createClass(Record, KeyedCollection);

    function Record(defaultValues, name) {
      var hasInitialized;

      var RecordType = function Record(values) {
        if (values instanceof RecordType) {
          return values;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys);
          RecordTypePrototype.size = keys.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map(values);
      };

      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;

      return RecordType;
    }

    Record.prototype.toString = function () {
      return this.__toString(recordName(this) + ' {', '}');
    };

    // @pragma Access

    Record.prototype.has = function (k) {
      return this._defaultValues.hasOwnProperty(k);
    };

    Record.prototype.get = function (k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };

    // @pragma Modification

    Record.prototype.clear = function () {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
    };

    Record.prototype.set = function (k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      if (this._map && !this._map.has(k)) {
        var defaultVal = this._defaultValues[k];
        if (v === defaultVal) {
          return this;
        }
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.remove = function (k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };

    Record.prototype.wasAltered = function () {
      return this._map.wasAltered();
    };

    Record.prototype.__iterator = function (type, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function (_, k) {
        return this$0.get(k);
      }).__iterator(type, reverse);
    };

    Record.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function (_, k) {
        return this$0.get(k);
      }).__iterate(fn, reverse);
    };

    Record.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };

    var RecordPrototype = Record.prototype;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
    RecordPrototype.merge = MapPrototype.merge;
    RecordPrototype.mergeWith = MapPrototype.mergeWith;
    RecordPrototype.mergeIn = MapPrototype.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype.setIn;
    RecordPrototype.update = MapPrototype.update;
    RecordPrototype.updateIn = MapPrototype.updateIn;
    RecordPrototype.withMutations = MapPrototype.withMutations;
    RecordPrototype.asMutable = MapPrototype.asMutable;
    RecordPrototype.asImmutable = MapPrototype.asImmutable;

    function makeRecord(likeRecord, map, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map;
      record.__ownerID = ownerID;
      return record;
    }

    function recordName(record) {
      return record._name || record.constructor.name || 'Record';
    }

    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(undefined, prototype));
      } catch (error) {
        // Object.defineProperty failed. Probably IE8.
      }
    }

    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function () {
          return this.get(name);
        },
        set: function (value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(name, value);
        }
      });
    }

    createClass(Set, SetCollection);

    // @pragma Construction

    function Set(value) {
      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v) {
          return set.add(v);
        });
      });
    }

    Set.of = function () /*...values*/{
      return this(arguments);
    };

    Set.fromKeys = function (value) {
      return this(KeyedIterable(value).keySeq());
    };

    Set.prototype.toString = function () {
      return this.__toString('Set {', '}');
    };

    // @pragma Access

    Set.prototype.has = function (value) {
      return this._map.has(value);
    };

    // @pragma Modification

    Set.prototype.add = function (value) {
      return updateSet(this, this._map.set(value, true));
    };

    Set.prototype.remove = function (value) {
      return updateSet(this, this._map.remove(value));
    };

    Set.prototype.clear = function () {
      return updateSet(this, this._map.clear());
    };

    // @pragma Composition

    Set.prototype.union = function () {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function (x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function (set) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function (value) {
            return set.add(value);
          });
        }
      });
    };

    Set.prototype.intersect = function () {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function (set) {
        originalSet.forEach(function (value) {
          if (!iters.every(function (iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.subtract = function () {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function (iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function (set) {
        originalSet.forEach(function (value) {
          if (iters.some(function (iter) {
            return iter.includes(value);
          })) {
            set.remove(value);
          }
        });
      });
    };

    Set.prototype.merge = function () {
      return this.union.apply(this, arguments);
    };

    Set.prototype.mergeWith = function (merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };

    Set.prototype.sort = function (comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator));
    };

    Set.prototype.sortBy = function (mapper, comparator) {
      // Late binding
      return OrderedSet(sortFactory(this, comparator, mapper));
    };

    Set.prototype.wasAltered = function () {
      return this._map.wasAltered();
    };

    Set.prototype.__iterate = function (fn, reverse) {
      var this$0 = this;
      return this._map.__iterate(function (_, k) {
        return fn(k, k, this$0);
      }, reverse);
    };

    Set.prototype.__iterator = function (type, reverse) {
      return this._map.map(function (_, k) {
        return k;
      }).__iterator(type, reverse);
    };

    Set.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };

    function isSet(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }

    Set.isSet = isSet;

    var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

    var SetPrototype = Set.prototype;
    SetPrototype[IS_SET_SENTINEL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.mergeDeep = SetPrototype.merge;
    SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
    SetPrototype.withMutations = MapPrototype.withMutations;
    SetPrototype.asMutable = MapPrototype.asMutable;
    SetPrototype.asImmutable = MapPrototype.asImmutable;

    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;

    function updateSet(set, newMap) {
      if (set.__ownerID) {
        set.size = newMap.size;
        set._map = newMap;
        return set;
      }
      return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);
    }

    function makeSet(map, ownerID) {
      var set = Object.create(SetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }

    var EMPTY_SET;
    function emptySet() {
      return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
    }

    createClass(OrderedSet, Set);

    // @pragma Construction

    function OrderedSet(value) {
      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {
        var iter = SetIterable(value);
        assertNotInfinite(iter.size);
        iter.forEach(function (v) {
          return set.add(v);
        });
      });
    }

    OrderedSet.of = function () /*...values*/{
      return this(arguments);
    };

    OrderedSet.fromKeys = function (value) {
      return this(KeyedIterable(value).keySeq());
    };

    OrderedSet.prototype.toString = function () {
      return this.__toString('OrderedSet {', '}');
    };

    function isOrderedSet(maybeOrderedSet) {
      return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
    }

    OrderedSet.isOrderedSet = isOrderedSet;

    var OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;

    function makeOrderedSet(map, ownerID) {
      var set = Object.create(OrderedSetPrototype);
      set.size = map ? map.size : 0;
      set._map = map;
      set.__ownerID = ownerID;
      return set;
    }

    var EMPTY_ORDERED_SET;
    function emptyOrderedSet() {
      return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
    }

    createClass(Stack, IndexedCollection);

    // @pragma Construction

    function Stack(value) {
      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
    }

    Stack.of = function () /*...values*/{
      return this(arguments);
    };

    Stack.prototype.toString = function () {
      return this.__toString('Stack [', ']');
    };

    // @pragma Access

    Stack.prototype.get = function (index, notSetValue) {
      var head = this._head;
      index = wrapIndex(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };

    Stack.prototype.peek = function () {
      return this._head && this._head.value;
    };

    // @pragma Modification

    Stack.prototype.push = function () /*...values*/{
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pushAll = function (iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function (value) {
        newSize++;
        head = {
          value: value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    Stack.prototype.pop = function () {
      return this.slice(1);
    };

    Stack.prototype.unshift = function () /*...values*/{
      return this.push.apply(this, arguments);
    };

    Stack.prototype.unshiftAll = function (iter) {
      return this.pushAll(iter);
    };

    Stack.prototype.shift = function () {
      return this.pop.apply(this, arguments);
    };

    Stack.prototype.clear = function () {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = undefined;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return emptyStack();
    };

    Stack.prototype.slice = function (begin, end) {
      if (wholeSlice(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin(begin, this.size);
      var resolvedEnd = resolveEnd(end, this.size);
      if (resolvedEnd !== this.size) {
        // super.slice(begin, end);
        return IndexedCollection.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = undefined;
        this.__altered = true;
        return this;
      }
      return makeStack(newSize, head);
    };

    // @pragma Mutability

    Stack.prototype.__ensureOwner = function (ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack(this.size, this._head, ownerID, this.__hash);
    };

    // @pragma Iteration

    Stack.prototype.__iterate = function (fn, reverse) {
      if (reverse) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };

    Stack.prototype.__iterator = function (type, reverse) {
      if (reverse) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator(function () {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue(type, iterations++, value);
        }
        return iteratorDone();
      });
    };

    function isStack(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }

    Stack.isStack = isStack;

    var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

    var StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SENTINEL] = true;
    StackPrototype.withMutations = MapPrototype.withMutations;
    StackPrototype.asMutable = MapPrototype.asMutable;
    StackPrototype.asImmutable = MapPrototype.asImmutable;
    StackPrototype.wasAltered = MapPrototype.wasAltered;

    function makeStack(size, head, ownerID, hash) {
      var map = Object.create(StackPrototype);
      map.size = size;
      map._head = head;
      map.__ownerID = ownerID;
      map.__hash = hash;
      map.__altered = false;
      return map;
    }

    var EMPTY_STACK;
    function emptyStack() {
      return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
    }

    /**
     * Contributes additional methods to a constructor
     */
    function mixin(ctor, methods) {
      var keyCopier = function (key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }

    Iterable.Iterator = Iterator;

    mixin(Iterable, {

      // ### Conversion to other types

      toArray: function () {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function (v, i) {
          array[i] = v;
        });
        return array;
      },

      toIndexedSeq: function () {
        return new ToIndexedSequence(this);
      },

      toJS: function () {
        return this.toSeq().map(function (value) {
          return value && typeof value.toJS === 'function' ? value.toJS() : value;
        }).__toJS();
      },

      toJSON: function () {
        return this.toSeq().map(function (value) {
          return value && typeof value.toJSON === 'function' ? value.toJSON() : value;
        }).__toJS();
      },

      toKeyedSeq: function () {
        return new ToKeyedSequence(this, true);
      },

      toMap: function () {
        // Use Late Binding here to solve the circular dependency.
        return Map(this.toKeyedSeq());
      },

      toObject: function () {
        assertNotInfinite(this.size);
        var object = {};
        this.__iterate(function (v, k) {
          object[k] = v;
        });
        return object;
      },

      toOrderedMap: function () {
        // Use Late Binding here to solve the circular dependency.
        return OrderedMap(this.toKeyedSeq());
      },

      toOrderedSet: function () {
        // Use Late Binding here to solve the circular dependency.
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },

      toSet: function () {
        // Use Late Binding here to solve the circular dependency.
        return Set(isKeyed(this) ? this.valueSeq() : this);
      },

      toSetSeq: function () {
        return new ToSetSequence(this);
      },

      toSeq: function () {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },

      toStack: function () {
        // Use Late Binding here to solve the circular dependency.
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },

      toList: function () {
        // Use Late Binding here to solve the circular dependency.
        return List(isKeyed(this) ? this.valueSeq() : this);
      },

      // ### Common JavaScript methods and properties

      toString: function () {
        return '[Iterable]';
      },

      __toString: function (head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
      },

      // ### ES6 Collection methods (ES6 Array and Map)

      concat: function () {
        var values = SLICE$0.call(arguments, 0);
        return reify(this, concatFactory(this, values));
      },

      includes: function (searchValue) {
        return this.some(function (value) {
          return is(value, searchValue);
        });
      },

      entries: function () {
        return this.__iterator(ITERATE_ENTRIES);
      },

      every: function (predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function (v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },

      filter: function (predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },

      find: function (predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },

      forEach: function (sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },

      join: function (separator) {
        assertNotInfinite(this.size);
        separator = separator !== undefined ? '' + separator : ',';
        var joined = '';
        var isFirst = true;
        this.__iterate(function (v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== undefined ? v.toString() : '';
        });
        return joined;
      },

      keys: function () {
        return this.__iterator(ITERATE_KEYS);
      },

      map: function (mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },

      reduce: function (reducer, initialReduction, context) {
        assertNotInfinite(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function (v, k, c) {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },

      reduceRight: function (reducer, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },

      reverse: function () {
        return reify(this, reverseFactory(this, true));
      },

      slice: function (begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },

      some: function (predicate, context) {
        return !this.every(not(predicate), context);
      },

      sort: function (comparator) {
        return reify(this, sortFactory(this, comparator));
      },

      values: function () {
        return this.__iterator(ITERATE_VALUES);
      },

      // ### More sequential methods

      butLast: function () {
        return this.slice(0, -1);
      },

      isEmpty: function () {
        return this.size !== undefined ? this.size === 0 : !this.some(function () {
          return true;
        });
      },

      count: function (predicate, context) {
        return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
      },

      countBy: function (grouper, context) {
        return countByFactory(this, grouper, context);
      },

      equals: function (other) {
        return deepEqual(this, other);
      },

      entrySeq: function () {
        var iterable = this;
        if (iterable._cache) {
          // We cache as an entries array, so we can just return the cache!
          return new ArraySeq(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function () {
          return iterable.toSeq();
        };
        return entriesSequence;
      },

      filterNot: function (predicate, context) {
        return this.filter(not(predicate), context);
      },

      findEntry: function (predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function (v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },

      findKey: function (predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },

      findLast: function (predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },

      findLastEntry: function (predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
      },

      findLastKey: function (predicate, context) {
        return this.toKeyedSeq().reverse().findKey(predicate, context);
      },

      first: function () {
        return this.find(returnTrue);
      },

      flatMap: function (mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },

      flatten: function (depth) {
        return reify(this, flattenFactory(this, depth, true));
      },

      fromEntrySeq: function () {
        return new FromEntriesSequence(this);
      },

      get: function (searchKey, notSetValue) {
        return this.find(function (_, key) {
          return is(key, searchKey);
        }, undefined, notSetValue);
      },

      getIn: function (searchKeyPath, notSetValue) {
        var nested = this;
        // Note: in an ES6 environment, we would prefer:
        // for (var key of searchKeyPath) {
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
          if (nested === NOT_SET) {
            return notSetValue;
          }
        }
        return nested;
      },

      groupBy: function (grouper, context) {
        return groupByFactory(this, grouper, context);
      },

      has: function (searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },

      hasIn: function (searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
      },

      isSubset: function (iter) {
        iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
        return this.every(function (value) {
          return iter.includes(value);
        });
      },

      isSuperset: function (iter) {
        iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
        return iter.isSubset(this);
      },

      keyOf: function (searchValue) {
        return this.findKey(function (value) {
          return is(value, searchValue);
        });
      },

      keySeq: function () {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },

      last: function () {
        return this.toSeq().reverse().first();
      },

      lastKeyOf: function (searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },

      max: function (comparator) {
        return maxFactory(this, comparator);
      },

      maxBy: function (mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },

      min: function (comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
      },

      minBy: function (mapper, comparator) {
        return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
      },

      rest: function () {
        return this.slice(1);
      },

      skip: function (amount) {
        return this.slice(Math.max(0, amount));
      },

      skipLast: function (amount) {
        return reify(this, this.toSeq().reverse().skip(amount).reverse());
      },

      skipWhile: function (predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },

      skipUntil: function (predicate, context) {
        return this.skipWhile(not(predicate), context);
      },

      sortBy: function (mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },

      take: function (amount) {
        return this.slice(0, Math.max(0, amount));
      },

      takeLast: function (amount) {
        return reify(this, this.toSeq().reverse().take(amount).reverse());
      },

      takeWhile: function (predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },

      takeUntil: function (predicate, context) {
        return this.takeWhile(not(predicate), context);
      },

      valueSeq: function () {
        return this.toIndexedSeq();
      },

      // ### Hashable Object

      hashCode: function () {
        return this.__hash || (this.__hash = hashIterable(this));
      }

      // ### Internal

      // abstract __iterate(fn, reverse)

      // abstract __iterator(type, reverse)
    });

    // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
    // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
    // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
    // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString;
    IterablePrototype.inspect = IterablePrototype.toSource = function () {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;

    mixin(KeyedIterable, {

      // ### More sequential methods

      flip: function () {
        return reify(this, flipFactory(this));
      },

      mapEntries: function (mapper, context) {
        var this$0 = this;
        var iterations = 0;
        return reify(this, this.toSeq().map(function (v, k) {
          return mapper.call(context, [k, v], iterations++, this$0);
        }).fromEntrySeq());
      },

      mapKeys: function (mapper, context) {
        var this$0 = this;
        return reify(this, this.toSeq().flip().map(function (k, v) {
          return mapper.call(context, k, v, this$0);
        }).flip());
      }

    });

    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function (v, k) {
      return JSON.stringify(k) + ': ' + quoteString(v);
    };

    mixin(IndexedIterable, {

      // ### Conversion to other types

      toKeyedSeq: function () {
        return new ToKeyedSequence(this, false);
      },

      // ### ES6 Collection methods (ES6 Array and Map)

      filter: function (predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },

      findIndex: function (predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },

      indexOf: function (searchValue) {
        var key = this.keyOf(searchValue);
        return key === undefined ? -1 : key;
      },

      lastIndexOf: function (searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === undefined ? -1 : key;
      },

      reverse: function () {
        return reify(this, reverseFactory(this, false));
      },

      slice: function (begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },

      splice: function (index, removeNum /*, ...values*/) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        // If index is negative, it should resolve relative to the size of the
        // collection. However size may be expensive to compute if not cached, so
        // only call count() if the number is in fact negative.
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
      },

      // ### More collection methods

      findLastIndex: function (predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
      },

      first: function () {
        return this.get(0);
      },

      flatten: function (depth) {
        return reify(this, flattenFactory(this, depth, false));
      },

      get: function (index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {
          return key === index;
        }, undefined, notSetValue);
      },

      has: function (index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },

      interpose: function (separator) {
        return reify(this, interposeFactory(this, separator));
      },

      interleave: function () /*...iterables*/{
        var iterables = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify(this, interleaved);
      },

      keySeq: function () {
        return Range(0, this.size);
      },

      last: function () {
        return this.get(-1);
      },

      skipWhile: function (predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },

      zip: function () /*, ...iterables */{
        var iterables = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, iterables));
      },

      zipWith: function (zipper /*, ...iterables */) {
        var iterables = arrCopy(arguments);
        iterables[0] = this;
        return reify(this, zipWithFactory(this, zipper, iterables));
      }

    });

    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;

    mixin(SetIterable, {

      // ### ES6 Collection methods (ES6 Array and Map)

      get: function (value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },

      includes: function (value) {
        return this.has(value);
      },

      // ### More sequential methods

      keySeq: function () {
        return this.valueSeq();
      }

    });

    SetIterable.prototype.has = IterablePrototype.includes;
    SetIterable.prototype.contains = SetIterable.prototype.includes;

    // Mixin subclasses

    mixin(KeyedSeq, KeyedIterable.prototype);
    mixin(IndexedSeq, IndexedIterable.prototype);
    mixin(SetSeq, SetIterable.prototype);

    mixin(KeyedCollection, KeyedIterable.prototype);
    mixin(IndexedCollection, IndexedIterable.prototype);
    mixin(SetCollection, SetIterable.prototype);

    // #pragma Helper functions

    function keyMapper(v, k) {
      return k;
    }

    function entryMapper(v, k) {
      return [k, v];
    }

    function not(predicate) {
      return function () {
        return !predicate.apply(this, arguments);
      };
    }

    function neg(predicate) {
      return function () {
        return -predicate.apply(this, arguments);
      };
    }

    function quoteString(value) {
      return typeof value === 'string' ? JSON.stringify(value) : String(value);
    }

    function defaultZipper() {
      return arrCopy(arguments);
    }

    function defaultNegComparator(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }

    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered(iterable);
      var keyed = isKeyed(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(keyed ? ordered ? function (v, k) {
        h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
      } : function (v, k) {
        h = h + hashMerge(hash(v), hash(k)) | 0;
      } : ordered ? function (v) {
        h = 31 * h + hash(v) | 0;
      } : function (v) {
        h = h + hash(v) | 0;
      });
      return murmurHashOfSize(size, h);
    }

    function murmurHashOfSize(size, h) {
      h = imul(h, 0xCC9E2D51);
      h = imul(h << 15 | h >>> -15, 0x1B873593);
      h = imul(h << 13 | h >>> -13, 5);
      h = (h + 0xE6546B64 | 0) ^ size;
      h = imul(h ^ h >>> 16, 0x85EBCA6B);
      h = imul(h ^ h >>> 13, 0xC2B2AE35);
      h = smi(h ^ h >>> 16);
      return h;
    }

    function hashMerge(a, b) {
      return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
    }

    var Immutable = {

      Iterable: Iterable,

      Seq: Seq,
      Collection: Collection,
      Map: Map,
      OrderedMap: OrderedMap,
      List: List,
      Stack: Stack,
      Set: Set,
      OrderedSet: OrderedSet,

      Record: Record,
      Range: Range,
      Repeat: Repeat,

      is: is,
      fromJS: fromJS

    };

    return Immutable;
  });
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/errors.js", ["process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.expect = expect, exports.assert = assert;function expect(a, b, c, d) {
    if (!a) {
      let e = "";throw d && (e = d.slice(0, 20).map(f => {
        let g = f.isDelimiter() ? "( ... )" : f.val();return f === c ? "__" + g + "__" : g;
      }).join(" ")), new Error("[error]: " + b + "\n" + e);
    }
  }function assert(a, b) {
    if (!a) throw new Error("[assertion error]: " + b);
  }
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/binding-map.js", ["immutable", "./errors", "ramda-fantasy", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 });var _immutable = $__require("immutable"),
      _errors = $__require("./errors"),
      _ramdaFantasy = $__require("ramda-fantasy");class BindingMap {
    constructor() {
      this._map = new Map();
    }add(a, b) {
      let c = b.binding,
          d = b.phase;var e = b.skipDup;let g = a.val(),
          h = a.scopesets.all,
          i = a.scopesets.phase.has(d) ? a.scopesets.phase.get(d) : (0, _immutable.List)();if (i = h.concat(i), (0, _errors.assert)(null != d, "must provide a phase for binding add"), this._map.has(g)) {
        let j = this._map.get(g);if (void 0 !== e && e && j.some(k => k.scopes.equals(i))) return;this._map.set(g, j.push({ scopes: i, binding: c, alias: _ramdaFantasy.Maybe.Nothing() }));
      } else this._map.set(g, _immutable.List.of({ scopes: i, binding: c, alias: _ramdaFantasy.Maybe.Nothing() }));
    }addForward(a, b, c, d) {
      let e = a.token.value,
          f = a.scopesets.all,
          g = a.scopesets.phase.has(d) ? a.scopesets.phase.get(d) : (0, _immutable.List)();if (g = f.concat(g), (0, _errors.assert)(null != d, "must provide a phase for binding add"), this._map.has(e)) {
        let h = this._map.get(e);this._map.set(e, h.push({ scopes: g, binding: c, alias: _ramdaFantasy.Maybe.of(b) }));
      } else this._map.set(e, _immutable.List.of({ scopes: g, binding: c, alias: _ramdaFantasy.Maybe.of(b) }));
    }get(a) {
      return this._map.get(a.token.value);
    }
  }exports.default = BindingMap;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Either.js', ['ramda/src/curry', 'ramda/src/toString', './internal/util'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var curry = $__require('ramda/src/curry');
  var toString = $__require('ramda/src/toString');

  var util = $__require('./internal/util');

  function Either(left, right) {
    switch (arguments.length) {
      case 0:
        throw new TypeError('no arguments to Either');
      case 1:
        return function (right) {
          return right == null ? Either.Left(left) : Either.Right(right);
        };
      default:
        return right == null ? Either.Left(left) : Either.Right(right);
    }
  }

  Either.prototype['@@type'] = 'ramda-fantasy/Either';

  Either.prototype.map = util.returnThis;

  Either.of = Either.prototype.of = function (value) {
    return Either.Right(value);
  };

  Either.prototype.chain = util.returnThis; // throw?


  Either.equals = Either.prototype.equals = util.getEquals(Either);

  Either.either = curry(function either(leftFn, rightFn, e) {
    if (e instanceof _Left) {
      return leftFn(e.value);
    } else if (e instanceof _Right) {
      return rightFn(e.value);
    } else {
      throw new TypeError('invalid type given to Either.either');
    }
  });

  Either.isLeft = function (x) {
    return x.isLeft;
  };

  Either.isRight = function (x) {
    return x.isRight;
  };

  // Right
  function _Right(x) {
    this.value = x;
  }
  util.extend(_Right, Either);

  _Right.prototype.isRight = true;
  _Right.prototype.isLeft = false;

  _Right.prototype.map = function (fn) {
    return new _Right(fn(this.value));
  };

  _Right.prototype.ap = function (that) {
    return that.map(this.value);
  };

  _Right.prototype.chain = function (f) {
    return f(this.value);
  };

  //chainRec
  Either.chainRec = Either.prototype.chainRec = function (f, i) {
    var res,
        state = util.chainRecNext(i);
    while (state.isNext) {
      res = f(util.chainRecNext, util.chainRecDone, state.value);
      if (Either.isLeft(res)) {
        return res;
      }
      state = res.value;
    }
    return Either.Right(state.value);
  };

  _Right.prototype.bimap = function (_, f) {
    return new _Right(f(this.value));
  };

  _Right.prototype.extend = function (f) {
    return new _Right(f(this));
  };

  _Right.prototype.toString = function () {
    return 'Either.Right(' + toString(this.value) + ')';
  };

  Either.Right = function (value) {
    return new _Right(value);
  };

  // Left
  function _Left(x) {
    this.value = x;
  }
  util.extend(_Left, Either);

  _Left.prototype.isLeft = true;
  _Left.prototype.isRight = false;

  _Left.prototype.ap = util.returnThis;

  _Left.prototype.bimap = function (f) {
    return new _Left(f(this.value));
  };

  _Left.prototype.extend = util.returnThis;

  _Left.prototype.toString = function () {
    return 'Either.Left(' + toString(this.value) + ')';
  };

  Either.Left = function (value) {
    return new _Left(value);
  };

  module.exports = Either;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Future.js', ['ramda/src/once', 'ramda/src/forEach', 'ramda/src/toString', 'ramda/src/curry', './internal/util'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var once = $__require('ramda/src/once');
  var forEach = $__require('ramda/src/forEach');
  var toString = $__require('ramda/src/toString');
  var curry = $__require('ramda/src/curry');

  var util = $__require('./internal/util');

  function jail(handler, f) {
    return function (a) {
      try {
        return f(a);
      } catch (err) {
        handler(err);
      }
    };
  }

  // `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)
  function Future(f) {
    if (!(this instanceof Future)) {
      return new Future(f);
    }
    this._fork = f;
  }

  Future.prototype['@@type'] = 'ramda-fantasy/Future';

  Future.prototype.fork = function (reject, resolve) {
    this._fork(reject, jail(reject, resolve));
  };

  // functor
  Future.prototype.map = function (f) {
    return this.chain(function (a) {
      return Future.of(f(a));
    });
  };

  // apply
  Future.prototype.ap = function (m) {
    var self = this;

    return new Future(function (rej, res) {
      var applyFn, val;
      var doReject = once(rej);

      var resolveIfDone = jail(doReject, function () {
        if (applyFn != null && val != null) {
          return res(applyFn(val));
        }
      });

      self._fork(doReject, function (fn) {
        applyFn = fn;
        resolveIfDone();
      });

      m._fork(doReject, function (v) {
        val = v;
        resolveIfDone();
      });
    });
  };

  // applicative
  Future.of = function (x) {
    // should include a default rejection?
    return new Future(function (_, resolve) {
      return resolve(x);
    });
  };

  Future.prototype.of = Future.of;

  // chain
  //  f must be a function which returns a value
  //  f must return a value of the same Chain
  //  chain must return a value of the same Chain
  //:: Future a, b => (b -> Future c) -> Future c
  Future.prototype.chain = function (f) {
    // Sorella's:
    return new Future(function (reject, resolve) {
      return this._fork(function (a) {
        return reject(a);
      }, jail(reject, function (b) {
        return f(b)._fork(reject, resolve);
      }));
    }.bind(this));
  };

  // chainRec
  //
  // Heavily influenced by the Aff MonadRec instance
  // https://github.com/slamdata/purescript-aff/blob/51106474122d0e5aec8e3d5da5bb66cfe8062f55/src/Control/Monad/Aff.js#L263-L322
  Future.chainRec = Future.prototype.chainRec = function (f, a) {
    return Future(function (reject, resolve) {
      return function go(acc) {
        // isSync could be in three possable states
        // * null - unresolved status
        // * true - synchronous future
        // * false - asynchronous future
        var isSync = null;
        var state = util.chainRecNext(acc);
        var onResolve = function (v) {
          // If the `isSync` is still unresolved, we have observed a
          // synchronous future. Otherwise, `isSync` will be `false`.
          if (isSync === null) {
            isSync = true;
            // Store the result for further synchronous processing.
            state = v;
          } else {
            // When we have observed an asynchronous future, we use normal
            // recursion. This is safe because we will be on a new stack.
            (v.isNext ? go : resolve)(v.value);
          }
        };
        while (state.isNext) {
          isSync = null;
          f(util.chainRecNext, util.chainRecDone, state.value).fork(reject, onResolve);
          // If the `isSync` has already resolved to `true` by our `onResolve`, then
          // we have observed a synchronous future. Otherwise it will still be `null`.
          if (isSync === true) {
            continue;
          } else {
            // If the status has not resolved yet, then we have observed an
            // asynchronous or failed future so update status and exit the loop.
            isSync = false;
            return;
          }
        }
        resolve(state.value);
      }(a);
    });
  };

  // chainReject
  // Like chain but operates on the reject instead of the resolve case.
  //:: Future a, b => (a -> Future c) -> Future c
  Future.prototype.chainReject = function (f) {
    return new Future(function (reject, resolve) {
      return this._fork(jail(reject, function (a) {
        return f(a)._fork(reject, resolve);
      }), function (b) {
        return resolve(b);
      });
    }.bind(this));
  };

  // monad
  // A value that implements the Monad specification must also implement the Applicative and Chain specifications.
  // see above.

  Future.prototype.bimap = function (errFn, successFn) {
    var self = this;
    return new Future(function (reject, resolve) {
      self._fork(jail(reject, function (err) {
        reject(errFn(err));
      }), jail(reject, function (val) {
        resolve(successFn(val));
      }));
    });
  };

  Future.reject = function (val) {
    return new Future(function (reject) {
      reject(val);
    });
  };

  Future.prototype.toString = function () {
    return 'Future(' + toString(this._fork) + ')';
  };

  Future.cache = function (f) {
    var status = 'IDLE';
    var listeners = [];
    var cachedValue;

    var handleCompletion = curry(function (newStatus, cb, val) {
      status = newStatus;
      cachedValue = val;
      cb(val);
      forEach(function (listener) {
        listener[status](cachedValue);
      }, listeners);
    });

    function addListeners(reject, resolve) {
      listeners.push({ REJECTED: reject, RESOLVED: resolve });
    }

    function doResolve(reject, resolve) {
      status = 'PENDING';
      return f._fork(handleCompletion('REJECTED', reject), handleCompletion('RESOLVED', resolve));
    }

    return new Future(function (reject, resolve) {

      switch (status) {
        case 'IDLE':
          doResolve(reject, resolve);break;
        case 'PENDING':
          addListeners(reject, resolve);break;
        case 'REJECTED':
          reject(cachedValue);break;
        case 'RESOLVED':
          resolve(cachedValue);break;
      }
    });
  };

  module.exports = Future;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/IO.js', ['ramda/src/compose', 'ramda/src/toString', './internal/util'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var compose = $__require('ramda/src/compose');
  var toString = $__require('ramda/src/toString');

  var util = $__require('./internal/util');

  module.exports = IO;

  function IO(fn) {
    if (!(this instanceof IO)) {
      return new IO(fn);
    }
    this.fn = fn;
  }

  IO.prototype['@@type'] = 'ramda-fantasy/IO';

  // `f` must return an IO
  IO.prototype.chain = function (f) {
    var io = this;
    return new IO(function () {
      var next = f(io.fn.apply(io, arguments));
      return next.fn.apply(next, arguments);
    });
  };

  //chainRec
  IO.chainRec = IO.prototype.chainRec = function (f, i) {
    return new IO(function () {
      var state = util.chainRecNext(i);
      while (state.isNext) {
        state = f(util.chainRecNext, util.chainRecDone, state.value).fn();
      }
      return state.value;
    });
  };

  IO.prototype.map = function (f) {
    var io = this;
    return new IO(compose(f, io.fn));
  };

  // `this` IO must wrap a function `f` that takes an IO (`thatIo`) as input
  // `f` must return an IO
  IO.prototype.ap = function (thatIo) {
    return this.chain(function (f) {
      return thatIo.map(f);
    });
  };

  IO.runIO = function (io) {
    return io.runIO.apply(io, [].slice.call(arguments, 1));
  };

  IO.prototype.runIO = function () {
    return this.fn.apply(this, arguments);
  };

  IO.prototype.of = function (x) {
    return new IO(function () {
      return x;
    });
  };

  IO.of = IO.prototype.of;

  IO.prototype.toString = function () {
    return 'IO(' + toString(this.fn) + ')';
  };
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/lift2.js', ['ramda/src/curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var curryN = $__require('ramda/src/curryN');

  module.exports = curryN(3, function lift2(f, a1, a2) {
    return a1.map(f).ap(a2);
  });
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/lift3.js', ['ramda/src/curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var curryN = $__require('ramda/src/curryN');

  module.exports = curryN(4, function lift3(f, a1, a2, a3) {
    return a1.map(f).ap(a2).ap(a3);
  });
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Maybe.js', ['ramda/src/toString', 'ramda/src/curry', './internal/util.js'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var toString = $__require('ramda/src/toString');
  var curry = $__require('ramda/src/curry');

  var util = $__require('./internal/util.js');

  function Maybe(x) {
    return x == null ? _nothing : Maybe.Just(x);
  }

  Maybe.prototype['@@type'] = 'ramda-fantasy/Maybe';

  function Just(x) {
    this.value = x;
  }
  util.extend(Just, Maybe);

  Just.prototype.isJust = true;
  Just.prototype.isNothing = false;

  function Nothing() {}
  util.extend(Nothing, Maybe);

  Nothing.prototype.isNothing = true;
  Nothing.prototype.isJust = false;

  var _nothing = new Nothing();

  Maybe.Nothing = function () {
    return _nothing;
  };

  Maybe.Just = function (x) {
    return new Just(x);
  };

  Maybe.of = Maybe.Just;

  Maybe.prototype.of = Maybe.Just;

  Maybe.isJust = function (x) {
    return x.isJust;
  };

  Maybe.isNothing = function (x) {
    return x.isNothing;
  };

  Maybe.maybe = curry(function (nothingVal, justFn, m) {
    return m.reduce(function (_, x) {
      return justFn(x);
    }, nothingVal);
  });

  // functor
  Just.prototype.map = function (f) {
    return this.of(f(this.value));
  };

  Nothing.prototype.map = util.returnThis;

  // apply
  // takes a Maybe that wraps a function (`app`) and applies its `map`
  // method to this Maybe's value, which must be a function.
  Just.prototype.ap = function (m) {
    return m.map(this.value);
  };

  Nothing.prototype.ap = util.returnThis;

  // applicative
  // `of` inherited from `Maybe`


  // chain
  //  f must be a function which returns a value
  //  f must return a value of the same Chain
  //  chain must return a value of the same Chain
  Just.prototype.chain = util.baseMap;

  Nothing.prototype.chain = util.returnThis;

  //chainRec
  Maybe.chainRec = Maybe.prototype.chainRec = function (f, i) {
    var res,
        state = util.chainRecNext(i);
    while (state.isNext) {
      res = f(util.chainRecNext, util.chainRecDone, state.value);
      if (Maybe.isNothing(res)) {
        return res;
      }
      state = res.value;
    }
    return Maybe.Just(state.value);
  };

  //
  Just.prototype.datatype = Just;

  Nothing.prototype.datatype = Nothing;

  // monad
  // A value that implements the Monad specification must also implement the Applicative and Chain specifications.
  // see above.

  // equality method to enable testing
  Just.prototype.equals = util.getEquals(Just);

  Nothing.prototype.equals = function (that) {
    return that === _nothing;
  };

  Maybe.prototype.isNothing = function () {
    return this === _nothing;
  };

  Maybe.prototype.isJust = function () {
    return this instanceof Just;
  };

  Just.prototype.getOrElse = function () {
    return this.value;
  };

  Nothing.prototype.getOrElse = function (a) {
    return a;
  };

  Just.prototype.reduce = function (f, x) {
    return f(x, this.value);
  };

  Nothing.prototype.reduce = function (f, x) {
    return x;
  };

  Just.prototype.toString = function () {
    return 'Maybe.Just(' + toString(this.value) + ')';
  };

  Nothing.prototype.toString = function () {
    return 'Maybe.Nothing()';
  };

  module.exports = Maybe;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Reader.js', ['ramda/src/compose', 'ramda/src/identity', 'ramda/src/toString', 'ramda/src/always'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var compose = $__require('ramda/src/compose');
  var identity = $__require('ramda/src/identity');
  var toString = $__require('ramda/src/toString');
  var always = $__require('ramda/src/always');

  function Reader(run) {
    if (!(this instanceof Reader)) {
      return new Reader(run);
    }
    this.run = run;
  }

  Reader.run = function (reader) {
    return reader.run.apply(reader, [].slice.call(arguments, 1));
  };

  Reader.prototype['@@type'] = 'ramda-fantasy/Reader';

  Reader.prototype.chain = function (f) {
    var reader = this;
    return new Reader(function (r) {
      return f(reader.run(r)).run(r);
    });
  };

  Reader.prototype.ap = function (a) {
    return this.chain(function (f) {
      return a.map(f);
    });
  };

  Reader.prototype.map = function (f) {
    return this.chain(function (a) {
      return Reader.of(f(a));
    });
  };

  Reader.prototype.of = function (a) {
    return new Reader(function () {
      return a;
    });
  };
  Reader.of = Reader.prototype.of;

  Reader.ask = Reader(identity);

  Reader.prototype.toString = function () {
    return 'Reader(' + toString(this.run) + ')';
  };

  Reader.T = function (M) {
    var ReaderT = function ReaderT(run) {
      if (!(this instanceof ReaderT)) {
        return new ReaderT(run);
      }
      this.run = run;
    };

    ReaderT.lift = compose(ReaderT, always);

    ReaderT.ask = ReaderT(M.of);

    ReaderT.prototype.of = ReaderT.of = function (a) {
      return ReaderT(function () {
        return M.of(a);
      });
    };

    ReaderT.prototype.chain = function (f) {
      var readerT = this;
      return ReaderT(function (e) {
        var m = readerT.run(e);
        return m.chain(function (a) {
          return f(a).run(e);
        });
      });
    };

    ReaderT.prototype.map = function (f) {
      return this.chain(function (a) {
        return ReaderT.of(f(a));
      });
    };

    ReaderT.prototype.ap = function (a) {
      var readerT = this;
      return ReaderT(function (e) {
        return readerT.run(e).ap(a.run(e));
      });
    };

    ReaderT.prototype.toString = function () {
      return 'ReaderT[' + M.name + '](' + toString(this.run) + ')';
    };

    return ReaderT;
  };

  module.exports = Reader;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Identity.js', ['ramda/src/toString', './internal/util'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var toString = $__require('ramda/src/toString');

  var util = $__require('./internal/util');

  /**
   * A data type that holds a value and exposes a monadic api.
   */

  /**
   * Constructs a new `Identity[a]` data type that holds a single
   * value `a`.
   * @param {*} a Value of any type
   * @sig a -> Identity[a]
   */
  function Identity(x) {
    if (!(this instanceof Identity)) {
      return new Identity(x);
    }
    this.value = x;
  }

  Identity.prototype['@@type'] = 'ramda-fantasy/Identity';

  /**
   * Applicative specification. Creates a new `Identity[a]` holding the value `a`.
   * @param {*} a Value of any type
   * @returns Identity[a]
   * @sig a -> Identity[a]
   */
  Identity.of = function (x) {
    return new Identity(x);
  };
  Identity.prototype.of = Identity.of;

  /**
   * Functor specification. Creates a new `Identity[a]` mapping function `f` onto
   * `a` returning any value b.
   * @param {Function} f Maps `a` to any value `b`
   * @returns Identity[b]
   * @sig @Identity[a] => (a -> b) -> Identity[b]
   */
  Identity.prototype.map = function (f) {
    return new Identity(f(this.value));
  };

  /**
   * Apply specification. Applies the function inside the `Identity[a]`
   * type to another applicative type.
   * @param {Applicative[a]} app Applicative that will apply its function
   * @returns Applicative[b]
   * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]
   */
  Identity.prototype.ap = function (app) {
    return app.map(this.value);
  };

  /**
   * Chain specification. Transforms the value of the `Identity[a]`
   * type using an unary function to monads. The `Identity[a]` type
   * should contain a function, otherwise an error is thrown.
   *
   * @param {Function} fn Transforms `a` into a `Monad[b]`
   * @returns Monad[b]
   * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]
   */
  Identity.prototype.chain = function (fn) {
    return fn(this.value);
  };

  // chainRec
  Identity.chainRec = Identity.prototype.chainRec = function (f, i) {
    var state = util.chainRecNext(i);
    while (state.isNext) {
      state = f(util.chainRecNext, util.chainRecDone, state.value).get();
    }
    return Identity(state.value);
  };

  /**
   * Returns the value of `Identity[a]`
   *
   * @returns a
   * @sig (Identity[a]) => a
   */
  Identity.prototype.get = function () {
    return this.value;
  };

  // equality method to enable testing
  Identity.prototype.equals = util.getEquals(Identity);

  Identity.prototype.toString = function () {
    return 'Identity(' + toString(this.value) + ')';
  };

  module.exports = Identity;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/internal/util.js', ['ramda/src/equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _equals = $__require('ramda/src/equals');

  module.exports = {

    baseMap: function (f) {
      return f(this.value);
    },

    getEquals: function (constructor) {
      return function equals(that) {
        return that instanceof constructor && _equals(this.value, that.value);
      };
    },

    extend: function (Child, Parent) {
      function Ctor() {
        this.constructor = Child;
      }
      Ctor.prototype = Parent.prototype;
      Child.prototype = new Ctor();
      Child.super_ = Parent.prototype;
    },

    identity: function (x) {
      return x;
    },

    notImplemented: function (str) {
      return function () {
        throw new Error(str + ' is not implemented');
      };
    },

    notCallable: function (fn) {
      return function () {
        throw new Error(fn + ' cannot be called directly');
      };
    },

    returnThis: function () {
      return this;
    },

    chainRecNext: function (v) {
      return { isNext: true, value: v };
    },

    chainRecDone: function (v) {
      return { isNext: false, value: v };
    },

    deriveAp: function (Type) {
      return function (fa) {
        return this.chain(function (f) {
          return fa.chain(function (a) {
            return Type.of(f(a));
          });
        });
      };
    },

    deriveMap: function (Type) {
      return function (f) {
        return this.chain(function (a) {
          return Type.of(f(a));
        });
      };
    }

  };
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/State.js', ['ramda/src/curry', './Identity', './Tuple', './internal/util'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var curry = $__require('ramda/src/curry');

  var Identity = $__require('./Identity');
  var Tuple = $__require('./Tuple');
  var util = $__require('./internal/util');

  function T(M) {
    function StateT(run) {
      if (!(this instanceof StateT)) {
        return new StateT(run);
      }
      this._run = run;
    }
    StateT.prototype.run = function (s) {
      return this._run(s);
    };
    StateT.prototype.eval = function (s) {
      return Tuple.fst(this.run(s));
    };
    StateT.prototype.exec = function (s) {
      return Tuple.snd(this.run(s));
    };
    StateT.prototype.chain = function (f) {
      var state = this;
      return StateT(function (s) {
        return state._run(s).chain(function (t) {
          return f(Tuple.fst(t))._run(Tuple.snd(t));
        });
      });
    };
    StateT.of = StateT.prototype.of = function (a) {
      return StateT(function (s) {
        return M.of(Tuple(a, s));
      });
    };
    StateT.prototype.ap = util.deriveAp(StateT);
    StateT.prototype.map = util.deriveMap(StateT);
    StateT.tailRec = curry(function (stepFn, init) {
      return StateT(function (s) {
        return M.tailRec(function (t) {
          return stepFn(Tuple.fst(t))._run(Tuple.snd(t)).chain(function (t_) {
            return M.of(Tuple.fst(t_).bimap(function (a) {
              return Tuple(a, Tuple.snd(t_));
            }, function (b) {
              return Tuple(b, Tuple.snd(t_));
            }));
          });
        }, Tuple(init, s));
      });
    });
    StateT.lift = function (ma) {
      return StateT(function (s) {
        return ma.chain(function (a) {
          return M.of(Tuple(a, s));
        });
      });
    };
    StateT.get = StateT(function (s) {
      return M.of(Tuple(s, s));
    });
    StateT.gets = function (f) {
      return StateT(function (s) {
        return M.of(Tuple(f(s), s));
      });
    };
    StateT.put = function (s) {
      return StateT(function (_) {
        return M.of(Tuple(void _, s));
      });
    };
    StateT.modify = function (f) {
      return StateT(function (s) {
        return M.of(Tuple(void 0, f(s)));
      });
    };

    return StateT;
  }

  var State = T(Identity);
  State.T = T;
  State.prototype.run = function (s) {
    return this._run(s).value;
  };

  module.exports = State;
});
System.registerDynamic('npm:ramda-fantasy@0.7.0/src/Tuple.js', ['ramda/src/toString', 'ramda/src/equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var toString = $__require('ramda/src/toString');
  var equals = $__require('ramda/src/equals');

  function Tuple(x, y) {
    switch (arguments.length) {
      case 0:
        throw new TypeError('no arguments to Tuple');
      case 1:
        return function (y) {
          return new _Tuple(x, y);
        };
      default:
        return new _Tuple(x, y);
    }
  }

  function _Tuple(x, y) {
    this[0] = x;
    this[1] = y;
    this.length = 2;
  }

  function ensureConcat(xs) {
    xs.forEach(function (x) {
      if (typeof x.concat != 'function') {
        throw new TypeError(toString(x) + ' must be a semigroup to perform this operation');
      }
    });
  }

  Tuple.fst = function (x) {
    return x[0];
  };

  Tuple.snd = function (x) {
    return x[1];
  };

  _Tuple.prototype['@@type'] = 'ramda-fantasy/Tuple';

  // semigroup
  _Tuple.prototype.concat = function (x) {
    ensureConcat([this[0], this[1]]);
    return Tuple(this[0].concat(x[0]), this[1].concat(x[1]));
  };

  // functor
  _Tuple.prototype.map = function (f) {
    return Tuple(this[0], f(this[1]));
  };

  // apply
  _Tuple.prototype.ap = function (m) {
    ensureConcat([this[0]]);
    return Tuple(this[0].concat(m[0]), this[1](m[1]));
  };

  // setoid
  _Tuple.prototype.equals = function (that) {
    return that instanceof _Tuple && equals(this[0], that[0]) && equals(this[1], that[1]);
  };

  _Tuple.prototype.toString = function () {
    return 'Tuple(' + toString(this[0]) + ', ' + toString(this[1]) + ')';
  };

  module.exports = Tuple;
});
System.registerDynamic("npm:ramda-fantasy@0.7.0.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:ramda-fantasy@0.7.0/index.js', ['./src/Either', './src/Future', './src/Identity', './src/IO', './src/lift2', './src/lift3', './src/Maybe', './src/Reader', './src/State', './src/Tuple'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = {
    Either: $__require('./src/Either'),
    Future: $__require('./src/Future'),
    Identity: $__require('./src/Identity'),
    IO: $__require('./src/IO'),
    lift2: $__require('./src/lift2'),
    lift3: $__require('./src/lift3'),
    Maybe: $__require('./src/Maybe'),
    Reader: $__require('./src/Reader'),
    State: $__require('./src/State'),
    Tuple: $__require('./src/Tuple')
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/F.js', ['./always'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var always = $__require('./always');

  /**
   * A function that always returns `false`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.always, R.T
   * @example
   *
   *      R.F(); //=> false
   */
  module.exports = always(false);
});
System.registerDynamic('npm:ramda@0.23.0/src/T.js', ['./always'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var always = $__require('./always');

  /**
   * A function that always returns `true`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.always, R.F
   * @example
   *
   *      R.T(); //=> true
   */
  module.exports = always(true);
});
System.registerDynamic('npm:ramda@0.23.0/src/__.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * A special placeholder value used to specify "gaps" within curried functions,
   * allowing partial application of any combination of arguments, regardless of
   * their positions.
   *
   * If `g` is a curried ternary function and `_` is `R.__`, the following are
   * equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2, _)(1, 3)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @constant
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @example
   *
   *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
   *      greet('Alice'); //=> 'Hello, Alice!'
   */
  module.exports = { '@@functional/placeholder': true };
});
System.registerDynamic('npm:ramda@0.23.0/src/addIndex.js', ['./internal/_concat', './internal/_curry1', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry1 = $__require('./internal/_curry1');
  var curryN = $__require('./curryN');

  /**
   * Creates a new list iteration function from an existing one by adding two new
   * parameters to its callback function: the current index, and the entire list.
   *
   * This would turn, for instance, Ramda's simple `map` function into one that
   * more closely resembles `Array.prototype.map`. Note that this will only work
   * for functions in which the iteration callback function is the first
   * parameter, and where the list is the last parameter. (This latter might be
   * unimportant if the list parameter is not used.)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Function
   * @category List
   * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
   * @param {Function} fn A list iteration function that does not pass index or list to its callback
   * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
   * @example
   *
   *      var mapIndexed = R.addIndex(R.map);
   *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
   *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
   */
  module.exports = _curry1(function addIndex(fn) {
    return curryN(fn.length, function () {
      var idx = 0;
      var origFn = arguments[0];
      var list = arguments[arguments.length - 1];
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = function () {
        var result = origFn.apply(this, _concat(arguments, [idx, list]));
        idx += 1;
        return result;
      };
      return fn.apply(this, args);
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xall.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XAll(f, xf) {
      this.xf = xf;
      this.f = f;
      this.all = true;
    }
    XAll.prototype['@@transducer/init'] = _xfBase.init;
    XAll.prototype['@@transducer/result'] = function (result) {
      if (this.all) {
        result = this.xf['@@transducer/step'](result, true);
      }
      return this.xf['@@transducer/result'](result);
    };
    XAll.prototype['@@transducer/step'] = function (result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf['@@transducer/step'](result, false));
      }
      return result;
    };

    return _curry2(function _xall(f, xf) {
      return new XAll(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/all.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xall'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xall = $__require('./internal/_xall');

  /**
   * Returns `true` if all elements of the list match the predicate, `false` if
   * there are any that don't.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
   *         otherwise.
   * @see R.any, R.none, R.transduce
   * @example
   *
   *      var equals3 = R.equals(3);
   *      R.all(equals3)([3, 3, 3, 3]); //=> true
   *      R.all(equals3)([3, 3, 1, 3]); //=> false
   */
  module.exports = _curry2(_dispatchable(['all'], _xall, function all(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }
      idx += 1;
    }
    return true;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/allPass.js', ['./internal/_curry1', './curryN', './max', './pluck', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var curryN = $__require('./curryN');
  var max = $__require('./max');
  var pluck = $__require('./pluck');
  var reduce = $__require('./reduce');

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if every one of the provided predicates is satisfied
   * by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.anyPass
   * @example
   *
   *      var isQueen = R.propEq('rank', 'Q');
   *      var isSpade = R.propEq('suit', '♠︎');
   *      var isQueenOfSpades = R.allPass([isQueen, isSpade]);
   *
   *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
   *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
   */
  module.exports = _curry1(function allPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }
        idx += 1;
      }
      return true;
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/anyPass.js', ['./internal/_curry1', './curryN', './max', './pluck', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var curryN = $__require('./curryN');
  var max = $__require('./max');
  var pluck = $__require('./pluck');
  var reduce = $__require('./reduce');

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if at least one of the provided predicates is
   * satisfied by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.allPass
   * @example
   *
   *      var isClub = R.propEq('suit', '♣');
   *      var isSpade = R.propEq('suit', '♠');
   *      var isBlackCard = R.anyPass([isClub, isSpade]);
   *
   *      isBlackCard({rank: '10', suit: '♣'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♠'}); //=> true
   *      isBlackCard({rank: 'Q', suit: '♦'}); //=> false
   */
  module.exports = _curry1(function anyPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;
      while (idx < len) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }
        idx += 1;
      }
      return false;
    });
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_aperture.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _aperture(n, list) {
    var idx = 0;
    var limit = list.length - (n - 1);
    var acc = new Array(limit >= 0 ? limit : 0);
    while (idx < limit) {
      acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
      idx += 1;
    }
    return acc;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xaperture.js', ['./_concat', './_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./_concat');
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XAperture(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }
    XAperture.prototype['@@transducer/init'] = _xfBase.init;
    XAperture.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };
    XAperture.prototype['@@transducer/step'] = function (result, input) {
      this.store(input);
      return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
    };
    XAperture.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;
      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };
    XAperture.prototype.getCopy = function () {
      return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
    };

    return _curry2(function _xaperture(n, xf) {
      return new XAperture(n, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/aperture.js', ['./internal/_aperture', './internal/_curry2', './internal/_dispatchable', './internal/_xaperture'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _aperture = $__require('./internal/_aperture');
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xaperture = $__require('./internal/_xaperture');

  /**
   * Returns a new list, composed of n-tuples of consecutive elements If `n` is
   * greater than the length of the list, an empty list is returned.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @param {Number} n The size of the tuples to create
   * @param {Array} list The list to split into `n`-length tuples
   * @return {Array} The resulting list of `n`-length tuples
   * @see R.transduce
   * @example
   *
   *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
   *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
   *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
   */
  module.exports = _curry2(_dispatchable([], _xaperture, _aperture));
});
System.registerDynamic('npm:ramda@0.23.0/src/append.js', ['./internal/_concat', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new list containing the contents of the given list, followed by
   * the given element.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The element to add to the end of the new list.
   * @param {Array} list The list of elements to add a new item to.
   *        list.
   * @return {Array} A new list containing the elements of the old list followed by `el`.
   * @see R.prepend
   * @example
   *
   *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
   *      R.append('tests', []); //=> ['tests']
   *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
   */
  module.exports = _curry2(function append(el, list) {
    return _concat(list, [el]);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/apply.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Applies function `fn` to the argument list `args`. This is useful for
   * creating a fixed-arity function from a variadic function. `fn` should be a
   * bound function if context is significant.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> a) -> [*] -> a
   * @param {Function} fn The function which will be called with `args`
   * @param {Array} args The arguments to call `fn` with
   * @return {*} result The result, equivalent to `fn(...args)`
   * @see R.call, R.unapply
   * @example
   *
   *      var nums = [1, 2, 3, -99, 42, 6, 7];
   *      R.apply(Math.max, nums); //=> 42
   * @symb R.apply(f, [a, b, c]) = f(a, b, c)
   */
  module.exports = _curry2(function apply(fn, args) {
    return fn.apply(this, args);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/applySpec.js', ['./internal/_curry1', './apply', './curryN', './map', './max', './pluck', './reduce', './values'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var apply = $__require('./apply');
  var curryN = $__require('./curryN');
  var map = $__require('./map');
  var max = $__require('./max');
  var pluck = $__require('./pluck');
  var reduce = $__require('./reduce');
  var values = $__require('./values');

  /**
   * Given a spec object recursively mapping properties to functions, creates a
   * function producing an object of the same structure, by mapping each property
   * to the result of calling its associated function with the supplied arguments.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
   * @param {Object} spec an object recursively mapping properties to functions for
   *        producing the values for these properties.
   * @return {Function} A function that returns an object of the same structure
   * as `spec', with each property set to the value returned by calling its
   * associated function with the supplied arguments.
   * @see R.converge, R.juxt
   * @example
   *
   *      var getMetrics = R.applySpec({
   *                                      sum: R.add,
   *                                      nested: { mul: R.multiply }
   *                                   });
   *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
   * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
   */
  module.exports = _curry1(function applySpec(spec) {
    spec = map(function (v) {
      return typeof v == 'function' ? v : applySpec(v);
    }, spec);
    return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
      var args = arguments;
      return map(function (f) {
        return apply(f, args);
      }, spec);
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/ascend.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Makes an ascending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
   * @example
   *
   *      var byAge = R.ascend(R.prop('age'));
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByYoungestFirst = R.sort(byAge, people);
   */
  module.exports = _curry3(function ascend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/binary.js', ['./internal/_curry1', './nAry'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var nAry = $__require('./nAry');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 2 parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (* -> c) -> (a, b -> c)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 2.
   * @example
   *
   *      var takesThreeArgs = function(a, b, c) {
   *        return [a, b, c];
   *      };
   *      takesThreeArgs.length; //=> 3
   *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
   *
   *      var takesTwoArgs = R.binary(takesThreeArgs);
   *      takesTwoArgs.length; //=> 2
   *      // Only 2 arguments are passed to the wrapped function
   *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
   * @symb R.binary(f)(a, b, c) = f(a, b)
   */
  module.exports = _curry1(function binary(fn) {
    return nAry(2, fn);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/and.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if both arguments are `true`; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any} the first argument if it is falsy, otherwise the second argument.
   * @see R.both
   * @example
   *
   *      R.and(true, true); //=> true
   *      R.and(true, false); //=> false
   *      R.and(false, true); //=> false
   *      R.and(false, false); //=> false
   */
  module.exports = _curry2(function and(a, b) {
    return a && b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/both.js', ['./internal/_curry2', './internal/_isFunction', './and', './lift'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isFunction = $__require('./internal/_isFunction');
  var and = $__require('./and');
  var lift = $__require('./lift');

  /**
   * A function which calls the two provided functions and returns the `&&`
   * of the results.
   * It returns the result of the first function if it is false-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * false-y value.
   *
   * In addition to functions, `R.both` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f A predicate
   * @param {Function} g Another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
   * @see R.and
   * @example
   *
   *      var gt10 = R.gt(R.__, 10)
   *      var lt20 = R.lt(R.__, 20)
   *      var f = R.both(gt10, lt20);
   *      f(15); //=> true
   *      f(30); //=> false
   */
  module.exports = _curry2(function both(f, g) {
    return _isFunction(f) ? function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } : lift(and)(f, g);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/call.js', ['./curry'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var curry = $__require('./curry');

  /**
   * Returns the result of calling its first argument with the remaining
   * arguments. This is occasionally useful as a converging function for
   * `R.converge`: the left branch can produce a function while the right branch
   * produces a value to be passed to that function as an argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig (*... -> a),*... -> a
   * @param {Function} fn The function to apply to the remaining arguments.
   * @param {...*} args Any number of positional arguments.
   * @return {*}
   * @see R.apply
   * @example
   *
   *      R.call(R.add, 1, 2); //=> 3
   *
   *      var indentN = R.pipe(R.times(R.always(' ')),
   *                           R.join(''),
   *                           R.replace(/^(?!$)/gm));
   *
   *      var format = R.converge(R.call, [
   *                                  R.pipe(R.prop('indent'), indentN),
   *                                  R.prop('value')
   *                              ]);
   *
   *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
   * @symb R.call(f, a, b) = f(a, b)
   */
  module.exports = curry(function call(fn) {
    return fn.apply(this, Array.prototype.slice.call(arguments, 1));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/clamp.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Restricts a number to be within a range.
   *
   * Also works for other ordered types such as Strings and Dates.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Relation
   * @sig Ord a => a -> a -> a -> a
   * @param {Number} minimum The lower limit of the clamp (inclusive)
   * @param {Number} maximum The upper limit of the clamp (inclusive)
   * @param {Number} value Value to be clamped
   * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
   * @example
   *
   *      R.clamp(1, 10, -5) // => 1
   *      R.clamp(1, 10, 15) // => 10
   *      R.clamp(1, 10, 4)  // => 4
   */
  module.exports = _curry3(function clamp(min, max, value) {
    if (min > max) {
      throw new Error('min must not be greater than max in clamp(min, max, value)');
    }
    return value < min ? min : value > max ? max : value;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/clone.js', ['./internal/_clone', './internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _clone = $__require('./internal/_clone');
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Creates a deep copy of the value which may contain (nested) `Array`s and
   * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
   * assigned by reference rather than copied
   *
   * Dispatches to a `clone` method if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {*} -> {*}
   * @param {*} value The object or array to clone
   * @return {*} A deeply cloned copy of `val`
   * @example
   *
   *      var objects = [{}, {}, {}];
   *      var objectsClone = R.clone(objects);
   *      objects === objectsClone; //=> false
   *      objects[0] === objectsClone[0]; //=> false
   */
  module.exports = _curry1(function clone(value) {
    return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/comparator.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Makes a comparator function out of a function that reports whether the first
   * element is less than the second.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a, b -> Boolean) -> (a, b -> Number)
   * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
   * is less than the second, `false` otherwise
   * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
   * @example
   *
   *      var byAge = R.comparator((a, b) => a.age < b.age);
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByIncreasingAge = R.sort(byAge, people);
   */
  module.exports = _curry1(function comparator(pred) {
    return function (a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/complement.js', ['./lift', './not'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var lift = $__require('./lift');
  var not = $__require('./not');

  /**
   * Takes a function `f` and returns a function `g` such that if called with the same arguments
   * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
   *
   * `R.complement` may be applied to any functor
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> *) -> (*... -> Boolean)
   * @param {Function} f
   * @return {Function}
   * @see R.not
   * @example
   *
   *      var isNotNil = R.complement(R.isNil);
   *      isNil(null); //=> true
   *      isNotNil(null); //=> false
   *      isNil(7); //=> false
   *      isNotNil(7); //=> true
   */
  module.exports = lift(not);
});
System.registerDynamic('npm:ramda@0.23.0/src/composeP.js', ['./pipeP', './reverse'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var pipeP = $__require('./pipeP');
  var reverse = $__require('./reverse');

  /**
   * Performs right-to-left composition of one or more Promise-returning
   * functions. The rightmost function may have any arity; the remaining
   * functions must be unary.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
   * @param {...Function} functions The functions to compose
   * @return {Function}
   * @see R.pipeP
   * @example
   *
   *      var db = {
   *        users: {
   *          JOE: {
   *            name: 'Joe',
   *            followers: ['STEVE', 'SUZY']
   *          }
   *        }
   *      }
   *
   *      // We'll pretend to do a db lookup which returns a promise
   *      var lookupUser = (userId) => Promise.resolve(db.users[userId])
   *      var lookupFollowers = (user) => Promise.resolve(user.followers)
   *      lookupUser('JOE').then(lookupFollowers)
   *
   *      //  followersForUser :: String -> Promise [UserId]
   *      var followersForUser = R.composeP(lookupFollowers, lookupUser);
   *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
   *      // Followers: ["STEVE","SUZY"]
   */
  module.exports = function composeP() {
    if (arguments.length === 0) {
      throw new Error('composeP requires at least one argument');
    }
    return pipeP.apply(this, reverse(arguments));
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/cond.js', ['./internal/_arity', './internal/_curry1', './map', './max', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _curry1 = $__require('./internal/_curry1');
  var map = $__require('./map');
  var max = $__require('./max');
  var reduce = $__require('./reduce');

  /**
   * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
   * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
   * to `fn` are applied to each of the predicates in turn until one returns a
   * "truthy" value, at which point `fn` returns the result of applying its
   * arguments to the corresponding transformer. If none of the predicates
   * matches, `fn` returns undefined.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Logic
   * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
   * @param {Array} pairs A list of [predicate, transformer]
   * @return {Function}
   * @example
   *
   *      var fn = R.cond([
   *        [R.equals(0),   R.always('water freezes at 0°C')],
   *        [R.equals(100), R.always('water boils at 100°C')],
   *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
   *      ]);
   *      fn(0); //=> 'water freezes at 0°C'
   *      fn(50); //=> 'nothing special happens at 50°C'
   *      fn(100); //=> 'water boils at 100°C'
   */
  module.exports = _curry1(function cond(pairs) {
    var arity = reduce(max, 0, map(function (pair) {
      return pair[0].length;
    }, pairs));
    return _arity(arity, function () {
      var idx = 0;
      while (idx < pairs.length) {
        if (pairs[idx][0].apply(this, arguments)) {
          return pairs[idx][1].apply(this, arguments);
        }
        idx += 1;
      }
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/construct.js', ['./internal/_curry1', './constructN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var constructN = $__require('./constructN');

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> {*}) -> (* -> {*})
   * @param {Function} fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @example
   *
   *      // Constructor function
   *      function Animal(kind) {
   *        this.kind = kind;
   *      };
   *      Animal.prototype.sighting = function() {
   *        return "It's a " + this.kind + "!";
   *      }
   *
   *      var AnimalConstructor = R.construct(Animal)
   *
   *      // Notice we no longer need the 'new' keyword:
   *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
   *
   *      var animalTypes = ["Lion", "Tiger", "Bear"];
   *      var animalSighting = R.invoker(0, 'sighting');
   *      var sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
   *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
   */
  module.exports = _curry1(function construct(Fn) {
    return constructN(Fn.length, Fn);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/constructN.js', ['./internal/_curry2', './curry', './nAry'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var curry = $__require('./curry');
  var nAry = $__require('./nAry');

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type. The arity of the function
   * returned is specified to allow using variadic constructor functions.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Function
   * @sig Number -> (* -> {*}) -> (* -> {*})
   * @param {Number} n The arity of the constructor function.
   * @param {Function} Fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @example
   *
   *      // Variadic Constructor function
   *      function Salad() {
   *        this.ingredients = arguments;
   *      };
   *      Salad.prototype.recipe = function() {
   *        var instructions = R.map((ingredient) => (
   *          'Add a whollop of ' + ingredient, this.ingredients)
   *        )
   *        return R.join('\n', instructions)
   *      }
   *
   *      var ThreeLayerSalad = R.constructN(3, Salad)
   *
   *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
   *      var salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup')
   *      console.log(salad.recipe());
   *      // Add a whollop of Mayonnaise
   *      // Add a whollop of Potato Chips
   *      // Add a whollop of Potato Ketchup
   */
  module.exports = _curry2(function constructN(n, Fn) {
    if (n > 10) {
      throw new Error('Constructor with greater than ten arguments');
    }
    if (n === 0) {
      return function () {
        return new Fn();
      };
    }
    return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
      switch (arguments.length) {
        case 1:
          return new Fn($0);
        case 2:
          return new Fn($0, $1);
        case 3:
          return new Fn($0, $1, $2);
        case 4:
          return new Fn($0, $1, $2, $3);
        case 5:
          return new Fn($0, $1, $2, $3, $4);
        case 6:
          return new Fn($0, $1, $2, $3, $4, $5);
        case 7:
          return new Fn($0, $1, $2, $3, $4, $5, $6);
        case 8:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
        case 9:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
        case 10:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
      }
    }));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/contains.js', ['./internal/_contains', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./internal/_contains');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if the specified value is equal, in `R.equals` terms, to at
   * least one element of the given list; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Boolean
   * @param {Object} a The item to compare against.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
   * @see R.any
   * @example
   *
   *      R.contains(3, [1, 2, 3]); //=> true
   *      R.contains(4, [1, 2, 3]); //=> false
   *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
   *      R.contains([42], [[42]]); //=> true
   */
  module.exports = _curry2(_contains);
});
System.registerDynamic('npm:ramda@0.23.0/src/countBy.js', ['./reduceBy'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var reduceBy = $__require('./reduceBy');

  /**
   * Counts the elements of a list according to how many match each value of a
   * key generated by the supplied function. Returns an object mapping the keys
   * produced by `fn` to the number of occurrences in the list. Note that all
   * keys are coerced to strings because of how JavaScript objects work.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig (a -> String) -> [a] -> {*}
   * @param {Function} fn The function used to map values to keys.
   * @param {Array} list The list to count elements from.
   * @return {Object} An object mapping keys to number of occurrences in the list.
   * @example
   *
   *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
   *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
   *
   *      var letters = ['a', 'b', 'A', 'a', 'B', 'c'];
   *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
   */
  module.exports = reduceBy(function (acc, elem) {
    return acc + 1;
  }, 0);
});
System.registerDynamic('npm:ramda@0.23.0/src/dec.js', ['./add'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var add = $__require('./add');

  /**
   * Decrements its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n - 1
   * @see R.inc
   * @example
   *
   *      R.dec(42); //=> 41
   */
  module.exports = add(-1);
});
System.registerDynamic('npm:ramda@0.23.0/src/descend.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Makes a descending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
   * @example
   *
   *      var byAge = R.descend(R.prop('age'));
   *      var people = [
   *        // ...
   *      ];
   *      var peopleByOldestFirst = R.sort(byAge, people);
   */
  module.exports = _curry3(function descend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa > bb ? -1 : aa < bb ? 1 : 0;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/dissoc.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Object
   * @sig String -> {k: v} -> {k: v}
   * @param {String} prop The name of the property to dissociate
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   * @see R.assoc
   * @example
   *
   *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
   */
  module.exports = _curry2(function dissoc(prop, obj) {
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    delete result[prop];
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/dissocPath.js', ['./internal/_curry2', './assoc', './dissoc'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var assoc = $__require('./assoc');
  var dissoc = $__require('./dissoc');

  /**
   * Makes a shallow clone of an object, omitting the property at the given path.
   * Note that this copies and flattens prototype properties onto the new object
   * as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.11.0
   * @category Object
   * @sig [String] -> {k: v} -> {k: v}
   * @param {Array} path The path to the value to omit
   * @param {Object} obj The object to clone
   * @return {Object} A new object without the property at path
   * @see R.assocPath
   * @example
   *
   *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
   */
  module.exports = _curry2(function dissocPath(path, obj) {
    switch (path.length) {
      case 0:
        return obj;
      case 1:
        return dissoc(path[0], obj);
      default:
        var head = path[0];
        var tail = Array.prototype.slice.call(path, 1);
        return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
    }
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/divide.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Divides two numbers. Equivalent to `a / b`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a / b`.
   * @see R.multiply
   * @example
   *
   *      R.divide(71, 100); //=> 0.71
   *
   *      var half = R.divide(R.__, 2);
   *      half(42); //=> 21
   *
   *      var reciprocal = R.divide(1);
   *      reciprocal(4);   //=> 0.25
   */
  module.exports = _curry2(function divide(a, b) {
    return a / b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_dropLast.js', ['../take'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var take = $__require('../take');

  module.exports = function dropLast(n, xs) {
    return take(n < xs.length ? xs.length - n : 0, xs);
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xdropLast.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XDropLast(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }
    XDropLast.prototype['@@transducer/init'] = _xfBase.init;
    XDropLast.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };
    XDropLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.full) {
        result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
      }
      this.store(input);
      return result;
    };
    XDropLast.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;
      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    return _curry2(function _xdropLast(n, xf) {
      return new XDropLast(n, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/dropLast.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_dropLast', './internal/_xdropLast'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _dropLast = $__require('./internal/_dropLast');
  var _xdropLast = $__require('./internal/_xdropLast');

  /**
   * Returns a list containing all but the last `n` elements of the given `list`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements of `list` to skip.
   * @param {Array} list The list of elements to consider.
   * @return {Array} A copy of the list with only the first `list.length - n` elements
   * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
   * @example
   *
   *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(3, 'ramda');               //=> 'ra'
   */
  module.exports = _curry2(_dispatchable([], _xdropLast, _dropLast));
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_dropLastWhile.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function dropLastWhile(pred, list) {
    var idx = list.length - 1;
    while (idx >= 0 && pred(list[idx])) {
      idx -= 1;
    }
    return Array.prototype.slice.call(list, 0, idx + 1);
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xdropLastWhile.js', ['./_curry2', './_reduce', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduce = $__require('./_reduce');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XDropLastWhile(fn, xf) {
      this.f = fn;
      this.retained = [];
      this.xf = xf;
    }
    XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropLastWhile.prototype['@@transducer/result'] = function (result) {
      this.retained = null;
      return this.xf['@@transducer/result'](result);
    };
    XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.retain(result, input) : this.flush(result, input);
    };
    XDropLastWhile.prototype.flush = function (result, input) {
      result = _reduce(this.xf['@@transducer/step'], result, this.retained);
      this.retained = [];
      return this.xf['@@transducer/step'](result, input);
    };
    XDropLastWhile.prototype.retain = function (result, input) {
      this.retained.push(input);
      return result;
    };

    return _curry2(function _xdropLastWhile(fn, xf) {
      return new XDropLastWhile(fn, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/dropLastWhile.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_dropLastWhile', './internal/_xdropLastWhile'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _dropLastWhile = $__require('./internal/_dropLastWhile');
  var _xdropLastWhile = $__require('./internal/_xdropLastWhile');

  /**
   * Returns a new list excluding all the tailing elements of a given list which
   * satisfy the supplied predicate function. It passes each value from the right
   * to the supplied predicate function, skipping elements until the predicate
   * function returns a `falsy` value. The predicate function is applied to one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @param {Function} predicate The function to be called on each element
   * @param {Array} list The collection to iterate over.
   * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
   * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
   * @example
   *
   *      var lteThree = x => x <= 3;
   *
   *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
   */
  module.exports = _curry2(_dispatchable([], _xdropLastWhile, _dropLastWhile));
});
System.registerDynamic('npm:ramda@0.23.0/src/dropRepeats.js', ['./internal/_curry1', './internal/_dispatchable', './internal/_xdropRepeatsWith', './dropRepeatsWith', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xdropRepeatsWith = $__require('./internal/_xdropRepeatsWith');
  var dropRepeatsWith = $__require('./dropRepeatsWith');
  var equals = $__require('./equals');

  /**
   * Returns a new list without any consecutively repeating elements. `R.equals`
   * is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
   */
  module.exports = _curry1(_dispatchable([], _xdropRepeatsWith(equals), dropRepeatsWith(equals)));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xdropRepeatsWith.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XDropRepeatsWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.lastValue = undefined;
      this.seenFirstValue = false;
    }

    XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
    XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;
    XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
      var sameAsLast = false;
      if (!this.seenFirstValue) {
        this.seenFirstValue = true;
      } else if (this.pred(this.lastValue, input)) {
        sameAsLast = true;
      }
      this.lastValue = input;
      return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
    };

    return _curry2(function _xdropRepeatsWith(pred, xf) {
      return new XDropRepeatsWith(pred, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/dropRepeatsWith.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xdropRepeatsWith', './last'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xdropRepeatsWith = $__require('./internal/_xdropRepeatsWith');
  var last = $__require('./last');

  /**
   * Returns a new list without any consecutively repeating elements. Equality is
   * determined by applying the supplied predicate to each pair of consecutive elements. The
   * first element in a series of equal elements will be preserved.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig (a, a -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
   *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
   */
  module.exports = _curry2(_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;
    if (len !== 0) {
      result[0] = list[0];
      while (idx < len) {
        if (!pred(last(result), list[idx])) {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
    }
    return result;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xdropWhile.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XDropWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
    XDropWhile.prototype['@@transducer/step'] = function (result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }
        this.f = null;
      }
      return this.xf['@@transducer/step'](result, input);
    };

    return _curry2(function _xdropWhile(f, xf) {
      return new XDropWhile(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/dropWhile.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xdropWhile'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xdropWhile = $__require('./internal/_xdropWhile');

  /**
   * Returns a new list excluding the leading elements of a given list which
   * satisfy the supplied predicate function. It passes each value to the supplied
   * predicate function, skipping elements while the predicate function returns
   * `true`. The predicate function is applied to one argument: *(value)*.
   *
   * Dispatches to the `dropWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @param {Function} fn The function called per iteration.
   * @param {Array} list The collection to iterate over.
   * @return {Array} A new array.
   * @see R.takeWhile, R.transduce, R.addIndex
   * @example
   *
   *      var lteTwo = x => x <= 2;
   *
   *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
   */
  module.exports = _curry2(_dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len && pred(list[idx])) {
      idx += 1;
    }
    return Array.prototype.slice.call(list, idx);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/either.js', ['./internal/_curry2', './internal/_isFunction', './lift', './or'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isFunction = $__require('./internal/_isFunction');
  var lift = $__require('./lift');
  var or = $__require('./or');

  /**
   * A function wrapping calls to the two functions in an `||` operation,
   * returning the result of the first function if it is truth-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * truth-y value.
   *
   * In addition to functions, `R.either` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f a predicate
   * @param {Function} g another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
   * @see R.or
   * @example
   *
   *      var gt10 = x => x > 10;
   *      var even = x => x % 2 === 0;
   *      var f = R.either(gt10, even);
   *      f(101); //=> true
   *      f(8); //=> true
   */
  module.exports = _curry2(function either(f, g) {
    return _isFunction(f) ? function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } : lift(or)(f, g);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/eqBy.js', ['./internal/_curry3', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var equals = $__require('./equals');

  /**
   * Takes a function and two values in its domain and returns `true` if the
   * values map to the same value in the codomain; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Relation
   * @sig (a -> b) -> a -> a -> Boolean
   * @param {Function} f
   * @param {*} x
   * @param {*} y
   * @return {Boolean}
   * @example
   *
   *      R.eqBy(Math.abs, 5, -5); //=> true
   */
  module.exports = _curry3(function eqBy(f, x, y) {
    return equals(f(x), f(y));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/eqProps.js', ['./internal/_curry3', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var equals = $__require('./equals');

  /**
   * Reports whether two objects have the same value, in `R.equals` terms, for
   * the specified property. Useful as a curried predicate.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig k -> {k: v} -> {k: v} -> Boolean
   * @param {String} prop The name of the property to compare
   * @param {Object} obj1
   * @param {Object} obj2
   * @return {Boolean}
   *
   * @example
   *
   *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
   *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
   *      R.eqProps('a', o1, o2); //=> false
   *      R.eqProps('c', o1, o2); //=> true
   */
  module.exports = _curry3(function eqProps(prop, obj1, obj2) {
    return equals(obj1[prop], obj2[prop]);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/evolve.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a new object by recursively evolving a shallow copy of `object`,
   * according to the `transformation` functions. All non-primitive properties
   * are copied by reference.
   *
   * A `transformation` function will not be invoked if its corresponding key
   * does not exist in the evolved object.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {k: (v -> v)} -> {k: v} -> {k: v}
   * @param {Object} transformations The object specifying transformation functions to apply
   *        to the object.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
   *      var transformations = {
   *        firstName: R.trim,
   *        lastName: R.trim, // Will not get invoked.
   *        data: {elapsed: R.add(1), remaining: R.add(-1)}
   *      };
   *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
   */
  module.exports = _curry2(function evolve(transformations, object) {
    var result = {};
    var transformation, key, type;
    for (key in object) {
      transformation = transformations[key];
      type = typeof transformation;
      result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfind.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XFind(f, xf) {
      this.xf = xf;
      this.f = f;
      this.found = false;
    }
    XFind.prototype['@@transducer/init'] = _xfBase.init;
    XFind.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, void 0);
      }
      return this.xf['@@transducer/result'](result);
    };
    XFind.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, input));
      }
      return result;
    };

    return _curry2(function _xfind(f, xf) {
      return new XFind(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/find.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xfind'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xfind = $__require('./internal/_xfind');

  /**
   * Returns the first element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Dispatches to the `find` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   *        desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
   *      R.find(R.propEq('a', 4))(xs); //=> undefined
   */
  module.exports = _curry2(_dispatchable(['find'], _xfind, function find(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx += 1;
    }
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfindIndex.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XFindIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.found = false;
    }
    XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
    XFindIndex.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, -1);
      }
      return this.xf['@@transducer/result'](result);
    };
    XFindIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, this.idx));
      }
      return result;
    };

    return _curry2(function _xfindIndex(f, xf) {
      return new XFindIndex(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/findIndex.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xfindIndex'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xfindIndex = $__require('./internal/_xfindIndex');

  /**
   * Returns the index of the first element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
   *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
   */
  module.exports = _curry2(_dispatchable([], _xfindIndex, function findIndex(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (fn(list[idx])) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfindLast.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XFindLast(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFindLast.prototype['@@transducer/init'] = _xfBase.init;
    XFindLast.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
    };
    XFindLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.last = input;
      }
      return result;
    };

    return _curry2(function _xfindLast(f, xf) {
      return new XFindLast(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/findLast.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xfindLast'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xfindLast = $__require('./internal/_xfindLast');

  /**
   * Returns the last element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
   *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
   */
  module.exports = _curry2(_dispatchable([], _xfindLast, function findLast(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return list[idx];
      }
      idx -= 1;
    }
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfindLastIndex.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XFindLastIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.lastIdx = -1;
    }
    XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
    XFindLastIndex.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
    };
    XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;
      if (this.f(input)) {
        this.lastIdx = this.idx;
      }
      return result;
    };

    return _curry2(function _xfindLastIndex(f, xf) {
      return new XFindLastIndex(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/findLastIndex.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xfindLastIndex'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xfindLastIndex = $__require('./internal/_xfindLastIndex');

  /**
   * Returns the index of the last element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce
   * @example
   *
   *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
   *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
   */
  module.exports = _curry2(_dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      if (fn(list[idx])) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/flatten.js', ['./internal/_curry1', './internal/_makeFlat'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _makeFlat = $__require('./internal/_makeFlat');

  /**
   * Returns a new list by pulling every item out of it (and all its sub-arrays)
   * and putting them in a new array, depth-first.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b]
   * @param {Array} list The array to consider.
   * @return {Array} The flattened list.
   * @see R.unnest
   * @example
   *
   *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
   *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
   */
  module.exports = _curry1(_makeFlat(true));
});
System.registerDynamic('npm:ramda@0.23.0/src/forEach.js', ['./internal/_checkForMethod', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _checkForMethod = $__require('./internal/_checkForMethod');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Iterate over an input `list`, calling a provided function `fn` for each
   * element in the list.
   *
   * `fn` receives one argument: *(value)*.
   *
   * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.forEach` method. For more
   * details on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
   *
   * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
   * the original array. In some libraries this function is named `each`.
   *
   * Dispatches to the `forEach` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> *) -> [a] -> [a]
   * @param {Function} fn The function to invoke. Receives one argument, `value`.
   * @param {Array} list The list to iterate over.
   * @return {Array} The original list.
   * @see R.addIndex
   * @example
   *
   *      var printXPlusFive = x => console.log(x + 5);
   *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
   *      // logs 6
   *      // logs 7
   *      // logs 8
   * @symb R.forEach(f, [a, b, c]) = [a, b, c]
   */
  module.exports = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
    var len = list.length;
    var idx = 0;
    while (idx < len) {
      fn(list[idx]);
      idx += 1;
    }
    return list;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/forEachObjIndexed.js', ['./internal/_curry2', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var keys = $__require('./keys');

  /**
   * Iterate over an input `object`, calling a provided function `fn` for each
   * key and value in the object.
   *
   * `fn` receives three argument: *(value, key, obj)*.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Object
   * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
   * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
   * @param {Object} obj The object to iterate over.
   * @return {Object} The original object.
   * @example
   *
   *      var printKeyConcatValue = (value, key) => console.log(key + ':' + value);
   *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
   *      // logs x:1
   *      // logs y:2
   * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
   */
  module.exports = _curry2(function forEachObjIndexed(fn, obj) {
    var keyList = keys(obj);
    var idx = 0;
    while (idx < keyList.length) {
      var key = keyList[idx];
      fn(obj[key], key, obj);
      idx += 1;
    }
    return obj;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/fromPairs.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Creates a new object from a list key-value pairs. If a key appears in
   * multiple pairs, the rightmost pair is included in the object.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [[k,v]] -> {k: v}
   * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
   * @return {Object} The object made by pairing up `keys` and `values`.
   * @see R.toPairs, R.pair
   * @example
   *
   *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
   */
  module.exports = _curry1(function fromPairs(pairs) {
    var result = {};
    var idx = 0;
    while (idx < pairs.length) {
      result[pairs[idx][0]] = pairs[idx][1];
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/groupBy.js', ['./internal/_checkForMethod', './internal/_curry2', './reduceBy'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _checkForMethod = $__require('./internal/_checkForMethod');
  var _curry2 = $__require('./internal/_curry2');
  var reduceBy = $__require('./reduceBy');

  /**
   * Splits a list into sub-lists stored in an object, based on the result of
   * calling a String-returning function on each element, and grouping the
   * results according to values returned.
   *
   * Dispatches to the `groupBy` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> String) -> [a] -> {String: [a]}
   * @param {Function} fn Function :: a -> String
   * @param {Array} list The array to group
   * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
   *         that produced that key when passed to `fn`.
   * @see R.transduce
   * @example
   *
   *      var byGrade = R.groupBy(function(student) {
   *        var score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      var students = [{name: 'Abby', score: 84},
   *                      {name: 'Eddy', score: 58},
   *                      // ...
   *                      {name: 'Jack', score: 69}];
   *      byGrade(students);
   *      // {
   *      //   'A': [{name: 'Dianne', score: 99}],
   *      //   'B': [{name: 'Abby', score: 84}]
   *      //   // ...,
   *      //   'F': [{name: 'Eddy', score: 58}]
   *      // }
   */
  module.exports = _curry2(_checkForMethod('groupBy', reduceBy(function (acc, item) {
    if (acc == null) {
      acc = [];
    }
    acc.push(item);
    return acc;
  }, null)));
});
System.registerDynamic('npm:ramda@0.23.0/src/groupWith.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Takes a list and returns a list of lists where each sublist's elements are
   * all "equal" according to the provided equality function.
   *
   * @func
   * @memberOf R
   * @since v0.21.0
   * @category List
   * @sig ((a, a) → Boolean) → [a] → [[a]]
   * @param {Function} fn Function for determining whether two given (adjacent)
   *        elements should be in the same group
   * @param {Array} list The array to group. Also accepts a string, which will be
   *        treated as a list of characters.
   * @return {List} A list that contains sublists of equal elements,
   *         whose concatenations are equal to the original list.
   * @example
   *
   * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
   *
   * R.groupWith(R.eqBy(isVowel), 'aestiou')
   * //=> ['ae', 'st', 'iou']
   */
  module.exports = _curry2(function (fn, list) {
    var res = [];
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      var nextidx = idx + 1;
      while (nextidx < len && fn(list[idx], list[nextidx])) {
        nextidx += 1;
      }
      res.push(list.slice(idx, nextidx));
      idx = nextidx;
    }
    return res;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/gt.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is greater than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.lt
   * @example
   *
   *      R.gt(2, 1); //=> true
   *      R.gt(2, 2); //=> false
   *      R.gt(2, 3); //=> false
   *      R.gt('a', 'z'); //=> false
   *      R.gt('z', 'a'); //=> true
   */
  module.exports = _curry2(function gt(a, b) {
    return a > b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/gte.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is greater than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.lte
   * @example
   *
   *      R.gte(2, 1); //=> true
   *      R.gte(2, 2); //=> true
   *      R.gte(2, 3); //=> false
   *      R.gte('a', 'z'); //=> false
   *      R.gte('z', 'a'); //=> true
   */
  module.exports = _curry2(function gte(a, b) {
    return a >= b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/has.js', ['./internal/_curry2', './internal/_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _has = $__require('./internal/_has');

  /**
   * Returns whether or not an object has an own property with the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      var hasName = R.has('name');
   *      hasName({name: 'alice'});   //=> true
   *      hasName({name: 'bob'});     //=> true
   *      hasName({});                //=> false
   *
   *      var point = {x: 0, y: 0};
   *      var pointHas = R.has(R.__, point);
   *      pointHas('x');  //=> true
   *      pointHas('y');  //=> true
   *      pointHas('z');  //=> false
   */
  module.exports = _curry2(_has);
});
System.registerDynamic('npm:ramda@0.23.0/src/hasIn.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns whether or not an object or its prototype chain has a property with
   * the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      function Rectangle(width, height) {
   *        this.width = width;
   *        this.height = height;
   *      }
   *      Rectangle.prototype.area = function() {
   *        return this.width * this.height;
   *      };
   *
   *      var square = new Rectangle(2, 2);
   *      R.hasIn('width', square);  //=> true
   *      R.hasIn('area', square);  //=> true
   */
  module.exports = _curry2(function hasIn(prop, obj) {
    return prop in obj;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/head.js', ['./nth'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var nth = $__require('./nth');

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> ''
   */
  module.exports = nth(0);
});
System.registerDynamic('npm:ramda@0.23.0/src/ifElse.js', ['./internal/_curry3', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var curryN = $__require('./curryN');

  /**
   * Creates a function that will process either the `onTrue` or the `onFalse`
   * function depending upon the result of the `condition` predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
   * @param {Function} condition A predicate function
   * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
   * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
   * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
   *                    function depending upon the result of the `condition` predicate.
   * @see R.unless, R.when
   * @example
   *
   *      var incCount = R.ifElse(
   *        R.has('count'),
   *        R.over(R.lensProp('count'), R.inc),
   *        R.assoc('count', 1)
   *      );
   *      incCount({});           //=> { count: 1 }
   *      incCount({ count: 1 }); //=> { count: 2 }
   */
  module.exports = _curry3(function ifElse(condition, onTrue, onFalse) {
    return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/inc.js', ['./add'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var add = $__require('./add');

  /**
   * Increments its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n + 1
   * @see R.dec
   * @example
   *
   *      R.inc(42); //=> 43
   */
  module.exports = add(1);
});
System.registerDynamic('npm:ramda@0.23.0/src/indexBy.js', ['./reduceBy'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var reduceBy = $__require('./reduceBy');

  /**
   * Given a function that generates a key, turns a list of objects into an
   * object indexing the objects by the given key. Note that if multiple
   * objects generate the same value for the indexing key only the last value
   * will be included in the generated object.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
   * @param {Function} fn Function :: a -> String
   * @param {Array} array The array of objects to index
   * @return {Object} An object indexing each array element by the given property.
   * @example
   *
   *      var list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
   *      R.indexBy(R.prop('id'), list);
   *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
   */
  module.exports = reduceBy(function (acc, elem) {
    return elem;
  }, null);
});
System.registerDynamic('npm:ramda@0.23.0/src/indexOf.js', ['./internal/_curry2', './internal/_indexOf', './internal/_isArray'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _indexOf = $__require('./internal/_indexOf');
  var _isArray = $__require('./internal/_isArray');

  /**
   * Returns the position of the first occurrence of an item in an array, or -1
   * if the item is not included in the array. `R.equals` is used to determine
   * equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.lastIndexOf
   * @example
   *
   *      R.indexOf(3, [1,2,3,4]); //=> 2
   *      R.indexOf(10, [1,2,3,4]); //=> -1
   */
  module.exports = _curry2(function indexOf(target, xs) {
    return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/init.js', ['./slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var slice = $__require('./slice');

  /**
   * Returns all but the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.last, R.head, R.tail
   * @example
   *
   *      R.init([1, 2, 3]);  //=> [1, 2]
   *      R.init([1, 2]);     //=> [1]
   *      R.init([1]);        //=> []
   *      R.init([]);         //=> []
   *
   *      R.init('abc');  //=> 'ab'
   *      R.init('ab');   //=> 'a'
   *      R.init('a');    //=> ''
   *      R.init('');     //=> ''
   */
  module.exports = slice(0, -1);
});
System.registerDynamic('npm:ramda@0.23.0/src/insert.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Inserts the supplied element into the list, at index `index`. _Note that
   * this is not destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} index The position to insert the element
   * @param {*} elt The element to insert into the Array
   * @param {Array} list The list to insert into
   * @return {Array} A new Array with `elt` inserted at `index`.
   * @example
   *
   *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
   */
  module.exports = _curry3(function insert(idx, elt, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    var result = Array.prototype.slice.call(list, 0);
    result.splice(idx, 0, elt);
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/insertAll.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Inserts the sub-list into the list, at index `index`. _Note that this is not
   * destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig Number -> [a] -> [a] -> [a]
   * @param {Number} index The position to insert the sub-list
   * @param {Array} elts The sub-list to insert into the Array
   * @param {Array} list The list to insert the sub-list into
   * @return {Array} A new Array with `elts` inserted starting at `index`.
   * @example
   *
   *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
   */
  module.exports = _curry3(function insertAll(idx, elts, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/intersection.js', ['./internal/_contains', './internal/_curry2', './internal/_filter', './flip', './uniq'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./internal/_contains');
  var _curry2 = $__require('./internal/_curry2');
  var _filter = $__require('./internal/_filter');
  var flip = $__require('./flip');
  var uniq = $__require('./uniq');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of those
   * elements common to both lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The list of elements found in both `list1` and `list2`.
   * @see R.intersectionWith
   * @example
   *
   *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
   */
  module.exports = _curry2(function intersection(list1, list2) {
    var lookupList, filteredList;
    if (list1.length > list2.length) {
      lookupList = list1;
      filteredList = list2;
    } else {
      lookupList = list2;
      filteredList = list1;
    }
    return uniq(_filter(flip(_contains)(lookupList), filteredList));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/intersectionWith.js', ['./internal/_containsWith', './internal/_curry3', './uniqWith'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _containsWith = $__require('./internal/_containsWith');
  var _curry3 = $__require('./internal/_curry3');
  var uniqWith = $__require('./uniqWith');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of those
   * elements common to both lists. Duplication is determined according to the
   * value returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate function that determines whether
   *        the two supplied elements are equal.
   * @param {Array} list1 One list of items to compare
   * @param {Array} list2 A second list of items to compare
   * @return {Array} A new list containing those elements common to both lists.
   * @see R.intersection
   * @example
   *
   *      var buffaloSpringfield = [
   *        {id: 824, name: 'Richie Furay'},
   *        {id: 956, name: 'Dewey Martin'},
   *        {id: 313, name: 'Bruce Palmer'},
   *        {id: 456, name: 'Stephen Stills'},
   *        {id: 177, name: 'Neil Young'}
   *      ];
   *      var csny = [
   *        {id: 204, name: 'David Crosby'},
   *        {id: 456, name: 'Stephen Stills'},
   *        {id: 539, name: 'Graham Nash'},
   *        {id: 177, name: 'Neil Young'}
   *      ];
   *
   *      R.intersectionWith(R.eqBy(R.prop('id')), buffaloSpringfield, csny);
   *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
   */
  module.exports = _curry3(function intersectionWith(pred, list1, list2) {
    var lookupList, filteredList;
    if (list1.length > list2.length) {
      lookupList = list1;
      filteredList = list2;
    } else {
      lookupList = list2;
      filteredList = list1;
    }
    var results = [];
    var idx = 0;
    while (idx < filteredList.length) {
      if (_containsWith(pred, filteredList[idx], lookupList)) {
        results[results.length] = filteredList[idx];
      }
      idx += 1;
    }
    return uniqWith(pred, results);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/intersperse.js', ['./internal/_checkForMethod', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _checkForMethod = $__require('./internal/_checkForMethod');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a new list with the separator interposed between elements.
   *
   * Dispatches to the `intersperse` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} separator The element to add to the list.
   * @param {Array} list The list to be interposed.
   * @return {Array} The new list.
   * @example
   *
   *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
   */
  module.exports = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
    var out = [];
    var idx = 0;
    var length = list.length;
    while (idx < length) {
      if (idx === length - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }
      idx += 1;
    }
    return out;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_clone.js', ['./_cloneRegExp', '../type'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _cloneRegExp = $__require('./_cloneRegExp');
  var type = $__require('../type');

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Array} refFrom Array containing the source references
   * @param {Array} refTo Array containing the copied source references
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */
  module.exports = function _clone(value, refFrom, refTo, deep) {
    var copy = function copy(copiedValue) {
      var len = refFrom.length;
      var idx = 0;
      while (idx < len) {
        if (value === refFrom[idx]) {
          return refTo[idx];
        }
        idx += 1;
      }
      refFrom[idx + 1] = value;
      refTo[idx + 1] = copiedValue;
      for (var key in value) {
        copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
      }
      return copiedValue;
    };
    switch (type(value)) {
      case 'Object':
        return copy({});
      case 'Array':
        return copy([]);
      case 'Date':
        return new Date(value.valueOf());
      case 'RegExp':
        return _cloneRegExp(value);
      default:
        return value;
    }
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_stepCat.js', ['./_assign', './_identity', './_isTransformer', '../isArrayLike', '../objOf'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('./_assign');
  var _identity = $__require('./_identity');
  var _isTransformer = $__require('./_isTransformer');
  var isArrayLike = $__require('../isArrayLike');
  var objOf = $__require('../objOf');

  module.exports = function () {
    var _stepCatArray = {
      '@@transducer/init': Array,
      '@@transducer/step': function (xs, x) {
        xs.push(x);
        return xs;
      },
      '@@transducer/result': _identity
    };
    var _stepCatString = {
      '@@transducer/init': String,
      '@@transducer/step': function (a, b) {
        return a + b;
      },
      '@@transducer/result': _identity
    };
    var _stepCatObject = {
      '@@transducer/init': Object,
      '@@transducer/step': function (result, input) {
        return _assign(result, isArrayLike(input) ? objOf(input[0], input[1]) : input);
      },
      '@@transducer/result': _identity
    };

    return function _stepCat(obj) {
      if (_isTransformer(obj)) {
        return obj;
      }
      if (isArrayLike(obj)) {
        return _stepCatArray;
      }
      if (typeof obj === 'string') {
        return _stepCatString;
      }
      if (typeof obj === 'object') {
        return _stepCatObject;
      }
      throw new Error('Cannot create transformer for ' + obj);
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/into.js', ['./internal/_clone', './internal/_curry3', './internal/_isTransformer', './internal/_reduce', './internal/_stepCat'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _clone = $__require('./internal/_clone');
  var _curry3 = $__require('./internal/_curry3');
  var _isTransformer = $__require('./internal/_isTransformer');
  var _reduce = $__require('./internal/_reduce');
  var _stepCat = $__require('./internal/_stepCat');

  /**
   * Transforms the items of the list with the transducer and appends the
   * transformed items to the accumulator using an appropriate iterator function
   * based on the accumulator type.
   *
   * The accumulator can be an array, string, object or a transformer. Iterated
   * items will be appended to arrays and concatenated to strings. Objects will
   * be merged directly or 2-item arrays will be merged as key, value pairs.
   *
   * The accumulator can also be a transformer object that provides a 2-arity
   * reducing iterator function, step, 0-arity initial value function, init, and
   * 1-arity result extraction function result. The step function is used as the
   * iterator function in reduce. The result function is used to convert the
   * final accumulator into the return type and in most cases is R.identity. The
   * init function is used to provide the initial accumulator.
   *
   * The iteration is performed with R.reduce after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig a -> (b -> b) -> [c] -> a
   * @param {*} acc The initial accumulator value.
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.into([], transducer, numbers); //=> [2, 3]
   *
   *      var intoArray = R.into([]);
   *      intoArray(transducer, numbers); //=> [2, 3]
   */
  module.exports = _curry3(function into(acc, xf, list) {
    return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/invert.js', ['./internal/_curry1', './internal/_has', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _has = $__require('./internal/_has');
  var keys = $__require('./keys');

  /**
   * Same as R.invertObj, however this accounts for objects with duplicate values
   * by putting the values into an array.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: [ s, ... ]}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object with keys
   * in an array.
   * @example
   *
   *      var raceResultsByFirstName = {
   *        first: 'alice',
   *        second: 'jake',
   *        third: 'alice',
   *      };
   *      R.invert(raceResultsByFirstName);
   *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
   */
  module.exports = _curry1(function invert(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      var val = obj[key];
      var list = _has(val, out) ? out[val] : out[val] = [];
      list[list.length] = key;
      idx += 1;
    }
    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/invertObj.js', ['./internal/_curry1', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var keys = $__require('./keys');

  /**
   * Returns a new object with the keys of the given object as values, and the
   * values of the given object, which are coerced to strings, as keys. Note
   * that the last key found is preferred when handling the same value.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: s}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object
   * @example
   *
   *      var raceResults = {
   *        first: 'alice',
   *        second: 'jake'
   *      };
   *      R.invertObj(raceResults);
   *      //=> { 'alice': 'first', 'jake':'second' }
   *
   *      // Alternatively:
   *      var raceResults = ['alice', 'jake'];
   *      R.invertObj(raceResults);
   *      //=> { 'alice': '0', 'jake':'1' }
   */
  module.exports = _curry1(function invertObj(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      out[obj[key]] = key;
      idx += 1;
    }
    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/empty.js', ['./internal/_curry1', './internal/_isArguments', './internal/_isArray', './internal/_isObject', './internal/_isString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _isArguments = $__require('./internal/_isArguments');
  var _isArray = $__require('./internal/_isArray');
  var _isObject = $__require('./internal/_isObject');
  var _isString = $__require('./internal/_isString');

  /**
   * Returns the empty value of its argument's type. Ramda defines the empty
   * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
   * types are supported if they define `<Type>.empty` and/or
   * `<Type>.prototype.empty`.
   *
   * Dispatches to the `empty` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> a
   * @param {*} x
   * @return {*}
   * @example
   *
   *      R.empty(Just(42));      //=> Nothing()
   *      R.empty([1, 2, 3]);     //=> []
   *      R.empty('unicorns');    //=> ''
   *      R.empty({x: 1, y: 2});  //=> {}
   */
  module.exports = _curry1(function empty(x) {
    return x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
      return arguments;
    }() :
    // else
    void 0;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/isEmpty.js', ['./internal/_curry1', './empty', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var empty = $__require('./empty');
  var equals = $__require('./equals');

  /**
   * Returns `true` if the given value is its type's empty value; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty
   * @example
   *
   *      R.isEmpty([1, 2, 3]);   //=> false
   *      R.isEmpty([]);          //=> true
   *      R.isEmpty('');          //=> true
   *      R.isEmpty(null);        //=> false
   *      R.isEmpty({});          //=> true
   *      R.isEmpty({length: 0}); //=> false
   */
  module.exports = _curry1(function isEmpty(x) {
    return x != null && equals(x, empty(x));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/isNil.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Checks if the input value is `null` or `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
   * @example
   *
   *      R.isNil(null); //=> true
   *      R.isNil(undefined); //=> true
   *      R.isNil(0); //=> false
   *      R.isNil([]); //=> false
   */
  module.exports = _curry1(function isNil(x) {
    return x == null;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/join.js', ['./invoker'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var invoker = $__require('./invoker');

  /**
   * Returns a string made by inserting the `separator` between each element and
   * concatenating all the elements into a single string.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig String -> [a] -> String
   * @param {Number|String} separator The string used to separate the elements.
   * @param {Array} xs The elements to join into a string.
   * @return {String} str The string made by concatenating `xs` with `separator`.
   * @see R.split
   * @example
   *
   *      var spacer = R.join(' ');
   *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
   *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
   */
  module.exports = invoker(1, 'join');
});
System.registerDynamic('npm:ramda@0.23.0/src/keysIn.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Returns a list containing the names of all the properties of the supplied
   * object, including prototype properties.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own and prototype properties.
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.keysIn(f); //=> ['x', 'y']
   */
  module.exports = _curry1(function keysIn(obj) {
    var prop;
    var ks = [];
    for (prop in obj) {
      ks[ks.length] = prop;
    }
    return ks;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/last.js', ['./nth'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var nth = $__require('./nth');

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> ''
   */
  module.exports = nth(-1);
});
System.registerDynamic('npm:ramda@0.23.0/src/lastIndexOf.js', ['./internal/_curry2', './internal/_isArray', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isArray = $__require('./internal/_isArray');
  var equals = $__require('./equals');

  /**
   * Returns the position of the last occurrence of an item in an array, or -1 if
   * the item is not included in the array. `R.equals` is used to determine
   * equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.indexOf
   * @example
   *
   *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
   *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
   */
  module.exports = _curry2(function lastIndexOf(target, xs) {
    if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
      return xs.lastIndexOf(target);
    } else {
      var idx = xs.length - 1;
      while (idx >= 0) {
        if (equals(xs[idx], target)) {
          return idx;
        }
        idx -= 1;
      }
      return -1;
    }
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lensIndex.js', ['./internal/_curry1', './lens', './nth', './update'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var lens = $__require('./lens');
  var nth = $__require('./nth');
  var update = $__require('./update');

  /**
   * Returns a lens whose focus is the specified index.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Number -> Lens s a
   * @param {Number} n
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var headLens = R.lensIndex(0);
   *
   *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
   *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
   *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
   */
  module.exports = _curry1(function lensIndex(n) {
    return lens(nth(n), update(n));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/assocPath.js', ['./internal/_curry3', './internal/_has', './internal/_isArray', './internal/_isInteger', './assoc'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var _has = $__require('./internal/_has');
  var _isArray = $__require('./internal/_isArray');
  var _isInteger = $__require('./internal/_isInteger');
  var assoc = $__require('./assoc');

  /**
   * Makes a shallow clone of an object, setting or overriding the nodes required
   * to create the given path, and placing the specific value at the tail end of
   * that path. Note that this copies and flattens prototype properties onto the
   * new object as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig [Idx] -> a -> {a} -> {a}
   * @param {Array} path the path to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except along the specified path.
   * @see R.dissocPath
   * @example
   *
   *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
   *
   *      // Any missing or non-object keys in path will be overridden
   *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
   */
  module.exports = _curry3(function assocPath(path, val, obj) {
    if (path.length === 0) {
      return val;
    }
    var idx = path[0];
    if (path.length > 1) {
      var nextObj = _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
      val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
    }
    if (_isInteger(idx) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[idx] = val;
      return arr;
    } else {
      return assoc(idx, val, obj);
    }
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lensPath.js', ['./internal/_curry1', './assocPath', './lens', './path'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var assocPath = $__require('./assocPath');
  var lens = $__require('./lens');
  var path = $__require('./path');

  /**
   * Returns a lens whose focus is the specified path.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @typedefn Idx = String | Int
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig [Idx] -> Lens s a
   * @param {Array} path The path to use.
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var xHeadYLens = R.lensPath(['x', 0, 'y']);
   *
   *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> 2
   *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
   *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
   */
  module.exports = _curry1(function lensPath(p) {
    return lens(path(p), assocPath(p));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/assoc.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig String -> a -> {k: v} -> {k: v}
   * @param {String} prop The property name to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except for the changed property.
   * @see R.dissoc
   * @example
   *
   *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
   */
  module.exports = _curry3(function assoc(prop, val, obj) {
    var result = {};
    for (var p in obj) {
      result[p] = obj[p];
    }
    result[prop] = val;
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lens.js', ['./internal/_curry2', './map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var map = $__require('./map');

  /**
   * Returns a lens for the given getter and setter functions. The getter "gets"
   * the value of the focus; the setter "sets" the value of the focus. The setter
   * should not mutate the data structure.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
   * @param {Function} getter
   * @param {Function} setter
   * @return {Lens}
   * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */
  module.exports = _curry2(function lens(getter, setter) {
    return function (toFunctorFn) {
      return function (target) {
        return map(function (focus) {
          return setter(focus, target);
        }, toFunctorFn(getter(target)));
      };
    };
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lensProp.js', ['./internal/_curry1', './assoc', './lens', './prop'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var assoc = $__require('./assoc');
  var lens = $__require('./lens');
  var prop = $__require('./prop');

  /**
   * Returns a lens whose focus is the specified property.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig String -> Lens s a
   * @param {String} k
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */
  module.exports = _curry1(function lensProp(k) {
    return lens(prop(k), assoc(k));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lift.js', ['./internal/_curry1', './liftN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var liftN = $__require('./liftN');

  /**
   * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
   * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.liftN
   * @example
   *
   *      var madd3 = R.lift((a, b, c) => a + b + c);
   *
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   *
   *      var madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
   *
   *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
   */
  module.exports = _curry1(function lift(fn) {
    return liftN(fn.length, fn);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/liftN.js', ['./internal/_curry2', './internal/_reduce', './ap', './curryN', './map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _reduce = $__require('./internal/_reduce');
  var ap = $__require('./ap');
  var curryN = $__require('./curryN');
  var map = $__require('./map');

  /**
   * "lifts" a function to be the specified arity, so that it may "map over" that
   * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig Number -> (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.lift, R.ap
   * @example
   *
   *      var madd3 = R.liftN(3, (...args) => R.sum(args));
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   */
  module.exports = _curry2(function liftN(arity, fn) {
    var lifted = curryN(arity, fn);
    return curryN(arity, function () {
      return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lt.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is less than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.gt
   * @example
   *
   *      R.lt(2, 1); //=> false
   *      R.lt(2, 2); //=> false
   *      R.lt(2, 3); //=> true
   *      R.lt('a', 'z'); //=> true
   *      R.lt('z', 'a'); //=> false
   */
  module.exports = _curry2(function lt(a, b) {
    return a < b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/lte.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if the first argument is less than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.gte
   * @example
   *
   *      R.lte(2, 1); //=> false
   *      R.lte(2, 2); //=> true
   *      R.lte(2, 3); //=> true
   *      R.lte('a', 'z'); //=> true
   *      R.lte('z', 'a'); //=> false
   */
  module.exports = _curry2(function lte(a, b) {
    return a <= b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mapAccum.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * The mapAccum function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from left to right, and returning a final value of this
   * accumulator together with the new list.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccumRight
   * @example
   *
   *      var digits = ['1', '2', '3', '4'];
   *      var appender = (a, b) => [a + b, a + b];
   *
   *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
   * @symb R.mapAccum(f, a, [b, c, d]) = [
   *   f(f(f(a, b)[0], c)[0], d)[0],
   *   [
   *     f(a, b)[1],
   *     f(f(a, b)[0], c)[1],
   *     f(f(f(a, b)[0], c)[0], d)[1]
   *   ]
   * ]
   */
  module.exports = _curry3(function mapAccum(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var tuple = [acc];
    while (idx < len) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx += 1;
    }
    return [tuple[0], result];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mapAccumRight.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * The mapAccumRight function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from right to left, and returning a final value of this
   * accumulator together with the new list.
   *
   * Similar to `mapAccum`, except moves through the input list from the right to
   * the left.
   *
   * The iterator function receives two arguments, *value* and *acc*, and should
   * return a tuple *[value, acc]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (x-> acc -> (y, acc)) -> acc -> [x] -> ([y], acc)
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccum
   * @example
   *
   *      var digits = ['1', '2', '3', '4'];
   *      var append = (a, b) => [a + b, a + b];
   *
   *      R.mapAccumRight(append, 5, digits); //=> [['12345', '2345', '345', '45'], '12345']
   * @symb R.mapAccumRight(f, a, [b, c, d]) = [
   *   [
   *     f(b, f(c, f(d, a)[0])[0])[1],
   *     f(c, f(d, a)[0])[1],
   *     f(d, a)[1],
   *   ]
   *   f(b, f(c, f(d, a)[0])[0])[0],
   * ]
   */
  module.exports = _curry3(function mapAccumRight(fn, acc, list) {
    var idx = list.length - 1;
    var result = [];
    var tuple = [acc];
    while (idx >= 0) {
      tuple = fn(list[idx], tuple[0]);
      result[idx] = tuple[1];
      idx -= 1;
    }
    return [result, tuple[0]];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mapObjIndexed.js', ['./internal/_curry2', './internal/_reduce', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _reduce = $__require('./internal/_reduce');
  var keys = $__require('./keys');

  /**
   * An Object-specific version of `map`. The function is applied to three
   * arguments: *(value, key, obj)*. If only the value is significant, use
   * `map` instead.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig ((*, String, Object) -> *) -> Object -> Object
   * @param {Function} fn
   * @param {Object} obj
   * @return {Object}
   * @see R.map
   * @example
   *
   *      var values = { x: 1, y: 2, z: 3 };
   *      var prependKeyAndDouble = (num, key, obj) => key + (num * 2);
   *
   *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
   */
  module.exports = _curry2(function mapObjIndexed(fn, obj) {
    return _reduce(function (acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys(obj));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/match.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Tests a regular expression against a String. Note that this function will
   * return an empty array when there are no matches. This differs from
   * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
   * which returns `null` when there are no matches.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig RegExp -> String -> [String | Undefined]
   * @param {RegExp} rx A regular expression.
   * @param {String} str The string to match against
   * @return {Array} The list of matches or empty array.
   * @see R.test
   * @example
   *
   *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
   *      R.match(/a/, 'b'); //=> []
   *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
   */
  module.exports = _curry2(function match(rx, str) {
    return str.match(rx) || [];
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_isInteger.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * Determine if the passed argument is an integer.
   *
   * @private
   * @param {*} n
   * @category Type
   * @return {Boolean}
   */
  module.exports = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/mathMod.js', ['./internal/_curry2', './internal/_isInteger'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isInteger = $__require('./internal/_isInteger');

  /**
   * mathMod behaves like the modulo operator should mathematically, unlike the
   * `%` operator (and by extension, R.modulo). So while "-17 % 5" is -2,
   * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
   * when the modulus is zero or negative.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} m The dividend.
   * @param {Number} p the modulus.
   * @return {Number} The result of `b mod a`.
   * @example
   *
   *      R.mathMod(-17, 5);  //=> 3
   *      R.mathMod(17, 5);   //=> 2
   *      R.mathMod(17, -5);  //=> NaN
   *      R.mathMod(17, 0);   //=> NaN
   *      R.mathMod(17.2, 5); //=> NaN
   *      R.mathMod(17, 5.3); //=> NaN
   *
   *      var clock = R.mathMod(R.__, 12);
   *      clock(15); //=> 3
   *      clock(24); //=> 0
   *
   *      var seventeenMod = R.mathMod(17);
   *      seventeenMod(3);  //=> 2
   *      seventeenMod(4);  //=> 1
   *      seventeenMod(10); //=> 7
   */
  module.exports = _curry2(function mathMod(m, p) {
    if (!_isInteger(m)) {
      return NaN;
    }
    if (!_isInteger(p) || p < 1) {
      return NaN;
    }
    return (m % p + p) % p;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/maxBy.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Takes a function and two values, and returns whichever value produces the
   * larger result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.max, R.minBy
   * @example
   *
   *      //  square :: Number -> Number
   *      var square = n => n * n;
   *
   *      R.maxBy(square, -3, 2); //=> -3
   *
   *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
   *      R.reduce(R.maxBy(square), 0, []); //=> 0
   */
  module.exports = _curry3(function maxBy(f, a, b) {
    return f(b) > f(a) ? b : a;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mean.js', ['./internal/_curry1', './sum'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var sum = $__require('./sum');

  /**
   * Returns the mean of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @example
   *
   *      R.mean([2, 7, 9]); //=> 6
   *      R.mean([]); //=> NaN
   */
  module.exports = _curry1(function mean(list) {
    return sum(list) / list.length;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/median.js', ['./internal/_curry1', './mean'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var mean = $__require('./mean');

  /**
   * Returns the median of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @example
   *
   *      R.median([2, 9, 7]); //=> 7
   *      R.median([7, 2, 10, 9]); //=> 8
   *      R.median([]); //=> NaN
   */
  module.exports = _curry1(function median(list) {
    var len = list.length;
    if (len === 0) {
      return NaN;
    }
    var width = 2 - len % 2;
    var idx = (len - width) / 2;
    return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }).slice(idx, idx + width));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/memoize.js', ['./internal/_arity', './internal/_curry1', './internal/_has', './toString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _curry1 = $__require('./internal/_curry1');
  var _has = $__require('./internal/_has');
  var toString = $__require('./toString');

  /**
   * Creates a new function that, when invoked, caches the result of calling `fn`
   * for a given argument set and returns the result. Subsequent calls to the
   * memoized `fn` with the same argument set will not result in an additional
   * call to `fn`; instead, the cached result for that set of arguments will be
   * returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (*... -> a) -> (*... -> a)
   * @param {Function} fn The function to memoize.
   * @return {Function} Memoized version of `fn`.
   * @example
   *
   *      var count = 0;
   *      var factorial = R.memoize(n => {
   *        count += 1;
   *        return R.product(R.range(1, n + 1));
   *      });
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      count; //=> 1
   */
  module.exports = _curry1(function memoize(fn) {
    var cache = {};
    return _arity(fn.length, function () {
      var key = toString(arguments);
      if (!_has(key, cache)) {
        cache[key] = fn.apply(this, arguments);
      }
      return cache[key];
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/merge.js', ['./internal/_assign', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('./internal/_assign');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      var resetToDefault = R.merge(R.__, {x: 0});
   *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
   * @symb R.merge({ x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: 5, z: 3 }
   */
  module.exports = _curry2(function merge(l, r) {
    return _assign({}, l, r);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_objectAssign.js', ['./_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _has = $__require('./_has');

  // Based on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  module.exports = function _objectAssign(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    var idx = 1;
    var length = arguments.length;
    while (idx < length) {
      var source = arguments[idx];
      if (source != null) {
        for (var nextKey in source) {
          if (_has(nextKey, source)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
      idx += 1;
    }
    return output;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_assign.js', ['./_objectAssign'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _objectAssign = $__require('./_objectAssign');

  module.exports = typeof Object.assign === 'function' ? Object.assign : _objectAssign;
});
System.registerDynamic('npm:ramda@0.23.0/src/mergeAll.js', ['./internal/_assign', './internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _assign = $__require('./internal/_assign');
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Merges a list of objects together into one object.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig [{k: v}] -> {k: v}
   * @param {Array} list An array of objects
   * @return {Object} A merged object.
   * @see R.reduce
   * @example
   *
   *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
   *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
   * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
   */
  module.exports = _curry1(function mergeAll(list) {
    return _assign.apply(null, [{}].concat(list));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mergeWith.js', ['./internal/_curry3', './mergeWithKey'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var mergeWithKey = $__require('./mergeWithKey');

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the values
   * associated with the key in each object, with the result being used as the
   * value associated with the key in the returned object. The key will be
   * excluded from the returned object if the resulting value is `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig (a -> a -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.merge, R.mergeWithKey
   * @example
   *
   *      R.mergeWith(R.concat,
   *                  { a: true, values: [10, 20] },
   *                  { b: true, values: [15, 35] });
   *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
   */
  module.exports = _curry3(function mergeWith(fn, l, r) {
    return mergeWithKey(function (_, _l, _r) {
      return fn(_l, _r);
    }, l, r);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/mergeWithKey.js', ['./internal/_curry3', './internal/_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var _has = $__require('./internal/_has');

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the key
   * and the values associated with the key in each object, with the result being
   * used as the value associated with the key in the returned object. The key
   * will be excluded from the returned object if the resulting value is
   * `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig (String -> a -> a -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.merge, R.mergeWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeWithKey(concatValues,
   *                     { a: true, thing: 'foo', values: [10, 20] },
   *                     { b: true, thing: 'bar', values: [15, 35] });
   *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
   * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
   */
  module.exports = _curry3(function mergeWithKey(fn, l, r) {
    var result = {};
    var k;

    for (k in l) {
      if (_has(k, l)) {
        result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
      }
    }

    for (k in r) {
      if (_has(k, r) && !_has(k, result)) {
        result[k] = r[k];
      }
    }

    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/min.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns the smaller of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.minBy, R.max
   * @example
   *
   *      R.min(789, 123); //=> 123
   *      R.min('a', 'b'); //=> 'a'
   */
  module.exports = _curry2(function min(a, b) {
    return b < a ? b : a;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/minBy.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Takes a function and two values, and returns whichever value produces the
   * smaller result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.min, R.maxBy
   * @example
   *
   *      //  square :: Number -> Number
   *      var square = n => n * n;
   *
   *      R.minBy(square, -3, 2); //=> 2
   *
   *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
   *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
   */
  module.exports = _curry3(function minBy(f, a, b) {
    return f(b) < f(a) ? b : a;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/modulo.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Divides the first parameter by the second and returns the remainder. Note
   * that this function preserves the JavaScript-style behavior for modulo. For
   * mathematical modulo see `mathMod`.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The value to the divide.
   * @param {Number} b The pseudo-modulus
   * @return {Number} The result of `b % a`.
   * @see R.mathMod
   * @example
   *
   *      R.modulo(17, 3); //=> 2
   *      // JS behavior:
   *      R.modulo(-17, 3); //=> -2
   *      R.modulo(17, -3); //=> 2
   *
   *      var isOdd = R.modulo(R.__, 2);
   *      isOdd(42); //=> 0
   *      isOdd(21); //=> 1
   */
  module.exports = _curry2(function modulo(a, b) {
    return a % b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/negate.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Negates its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number}
   * @example
   *
   *      R.negate(42); //=> -42
   */
  module.exports = _curry1(function negate(n) {
    return -n;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xany.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XAny(f, xf) {
      this.xf = xf;
      this.f = f;
      this.any = false;
    }
    XAny.prototype['@@transducer/init'] = _xfBase.init;
    XAny.prototype['@@transducer/result'] = function (result) {
      if (!this.any) {
        result = this.xf['@@transducer/step'](result, false);
      }
      return this.xf['@@transducer/result'](result);
    };
    XAny.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.any = true;
        result = _reduced(this.xf['@@transducer/step'](result, true));
      }
      return result;
    };

    return _curry2(function _xany(f, xf) {
      return new XAny(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/any.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xany'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xany = $__require('./internal/_xany');

  /**
   * Returns `true` if at least one of elements of the list match the predicate,
   * `false` otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
   *         otherwise.
   * @see R.all, R.none, R.transduce
   * @example
   *
   *      var lessThan0 = R.flip(R.lt)(0);
   *      var lessThan2 = R.flip(R.lt)(2);
   *      R.any(lessThan0)([1, 2]); //=> false
   *      R.any(lessThan2)([1, 2]); //=> true
   */
  module.exports = _curry2(_dispatchable(['any'], _xany, function any(fn, list) {
    var idx = 0;
    while (idx < list.length) {
      if (fn(list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/none.js', ['./internal/_complement', './internal/_curry2', './internal/_dispatchable', './internal/_xany', './any'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _complement = $__require('./internal/_complement');
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xany = $__require('./internal/_xany');
  var any = $__require('./any');

  /**
   * Returns `true` if no elements of the list match the predicate, `false`
   * otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
   * @see R.all, R.any
   * @example
   *
   *      var isEven = n => n % 2 === 0;
   *
   *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
   *      R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
   */
  module.exports = _curry2(_complement(_dispatchable(['any'], _xany, any)));
});
System.registerDynamic('npm:ramda@0.23.0/src/not.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * A function that returns the `!` of its argument. It will return `true` when
   * passed false-y value, and `false` when passed a truth-y one.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig * -> Boolean
   * @param {*} a any value
   * @return {Boolean} the logical inverse of passed argument.
   * @see R.complement
   * @example
   *
   *      R.not(true); //=> false
   *      R.not(false); //=> true
   *      R.not(0); //=> true
   *      R.not(1); //=> false
   */
  module.exports = _curry1(function not(a) {
    return !a;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/nth.js', ['./internal/_curry2', './internal/_isString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isString = $__require('./internal/_isString');

  /**
   * Returns the nth element of the given list or string. If n is negative the
   * element at index length + n is returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> a | Undefined
   * @sig Number -> String -> String
   * @param {Number} offset
   * @param {*} list
   * @return {*}
   * @example
   *
   *      var list = ['foo', 'bar', 'baz', 'quux'];
   *      R.nth(1, list); //=> 'bar'
   *      R.nth(-1, list); //=> 'quux'
   *      R.nth(-99, list); //=> undefined
   *
   *      R.nth(2, 'abc'); //=> 'c'
   *      R.nth(3, 'abc'); //=> ''
   * @symb R.nth(-1, [a, b, c]) = c
   * @symb R.nth(0, [a, b, c]) = a
   * @symb R.nth(1, [a, b, c]) = b
   */
  module.exports = _curry2(function nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/nthArg.js', ['./internal/_curry1', './curryN', './nth'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var curryN = $__require('./curryN');
  var nth = $__require('./nth');

  /**
   * Returns a function which returns its nth argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig Number -> *... -> *
   * @param {Number} n
   * @return {Function}
   * @example
   *
   *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
   *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
   * @symb R.nthArg(-1)(a, b, c) = c
   * @symb R.nthArg(0)(a, b, c) = a
   * @symb R.nthArg(1)(a, b, c) = b
   */
  module.exports = _curry1(function nthArg(n) {
    var arity = n < 0 ? 1 : n + 1;
    return curryN(arity, function () {
      return nth(n, arguments);
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/objOf.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates an object containing a single key:value pair.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @sig String -> a -> {String:a}
   * @param {String} key
   * @param {*} val
   * @return {Object}
   * @see R.pair
   * @example
   *
   *      var matchPhrases = R.compose(
   *        R.objOf('must'),
   *        R.map(R.objOf('match_phrase'))
   *      );
   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
   */
  module.exports = _curry2(function objOf(key, val) {
    var obj = {};
    obj[key] = val;
    return obj;
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_of.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _of(x) {
    return [x];
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/of.js', ['./internal/_curry1', './internal/_of'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _of = $__require('./internal/_of');

  /**
   * Returns a singleton array containing the value provided.
   *
   * Note this `of` is different from the ES6 `of`; See
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> [a]
   * @param {*} x any value
   * @return {Array} An array wrapping `x`.
   * @example
   *
   *      R.of(null); //=> [null]
   *      R.of([42]); //=> [[42]]
   */
  module.exports = _curry1(_of);
});
System.registerDynamic('npm:ramda@0.23.0/src/omit.js', ['./internal/_contains', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./internal/_contains');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a partial copy of an object omitting the keys specified.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [String] -> {String: *} -> {String: *}
   * @param {Array} names an array of String property names to omit from the new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with properties from `names` not on it.
   * @see R.pick
   * @example
   *
   *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
   */
  module.exports = _curry2(function omit(names, obj) {
    var result = {};
    for (var prop in obj) {
      if (!_contains(prop, names)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/once.js', ['./internal/_arity', './internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Accepts a function `fn` and returns a function that guards invocation of
   * `fn` such that `fn` can only ever be called once, no matter how many times
   * the returned function is invoked. The first value calculated is returned in
   * subsequent invocations.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a... -> b) -> (a... -> b)
   * @param {Function} fn The function to wrap in a call-only-once wrapper.
   * @return {Function} The wrapped function.
   * @example
   *
   *      var addOneOnce = R.once(x => x + 1);
   *      addOneOnce(10); //=> 11
   *      addOneOnce(addOneOnce(50)); //=> 11
   */
  module.exports = _curry1(function once(fn) {
    var called = false;
    var result;
    return _arity(fn.length, function () {
      if (called) {
        return result;
      }
      called = true;
      result = fn.apply(this, arguments);
      return result;
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/or.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns `true` if one or both of its arguments are `true`. Returns `false`
   * if both arguments are `false`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any} the first argument if truthy, otherwise the second argument.
   * @see R.either
   * @example
   *
   *      R.or(true, true); //=> true
   *      R.or(true, false); //=> true
   *      R.or(false, true); //=> true
   *      R.or(false, false); //=> false
   */
  module.exports = _curry2(function or(a, b) {
    return a || b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/pair.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category List
   * @sig a -> b -> (a,b)
   * @param {*} fst
   * @param {*} snd
   * @return {Array}
   * @see R.objOf, R.of
   * @example
   *
   *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
   */
  module.exports = _curry2(function pair(fst, snd) {
    return [fst, snd];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/partial.js', ['./internal/_concat', './internal/_createPartialApplicator'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _createPartialApplicator = $__require('./internal/_createPartialApplicator');

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided initially followed by the arguments provided to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partialRight
   * @example
   *
   *      var multiply2 = (a, b) => a * b;
   *      var double = R.partial(multiply2, [2]);
   *      double(2); //=> 4
   *
   *      var greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      var sayHello = R.partial(greet, ['Hello']);
   *      var sayHelloToMs = R.partial(sayHello, ['Ms.']);
   *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
   */
  module.exports = _createPartialApplicator(_concat);
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_createPartialApplicator.js', ['./_arity', './_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./_arity');
  var _curry2 = $__require('./_curry2');

  module.exports = function _createPartialApplicator(concat) {
    return _curry2(function (fn, args) {
      return _arity(Math.max(0, fn.length - args.length), function () {
        return fn.apply(this, concat(args, arguments));
      });
    });
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/partialRight.js', ['./internal/_concat', './internal/_createPartialApplicator', './flip'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _createPartialApplicator = $__require('./internal/_createPartialApplicator');
  var flip = $__require('./flip');

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided to `g` followed by the arguments provided initially.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partial
   * @example
   *
   *      var greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      var greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
   *
   *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
   */
  module.exports = _createPartialApplicator(flip(_concat));
});
System.registerDynamic('npm:ramda@0.23.0/src/max.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns the larger of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.maxBy, R.min
   * @example
   *
   *      R.max(789, 123); //=> 789
   *      R.max('a', 'b'); //=> 'b'
   */
  module.exports = _curry2(function max(a, b) {
    return b > a ? b : a;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/converge.js', ['./internal/_curry2', './internal/_map', './curryN', './max', './pluck', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _map = $__require('./internal/_map');
  var curryN = $__require('./curryN');
  var max = $__require('./max');
  var pluck = $__require('./pluck');
  var reduce = $__require('./reduce');

  /**
   * Accepts a converging function and a list of branching functions and returns
   * a new function. When invoked, this new function is applied to some
   * arguments, each branching function is applied to those same arguments. The
   * results of each branching function are passed as arguments to the converging
   * function to produce the return value.
   *
   * @func
   * @memberOf R
   * @since v0.4.2
   * @category Function
   * @sig (x1 -> x2 -> ... -> z) -> [(a -> b -> ... -> x1), (a -> b -> ... -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} after A function. `after` will be invoked with the return values of
   *        `fn1` and `fn2` as its arguments.
   * @param {Array} functions A list of functions.
   * @return {Function} A new function.
   * @see R.useWith
   * @example
   *
   *      var average = R.converge(R.divide, [R.sum, R.length])
   *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
   *
   *      var strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
   *      strangeConcat("Yodel") //=> "YODELyodel"
   *
   * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
   */
  module.exports = _curry2(function converge(after, fns) {
    return curryN(reduce(max, 0, pluck('length', fns)), function () {
      var args = arguments;
      var context = this;
      return after.apply(context, _map(function (fn) {
        return fn.apply(context, args);
      }, fns));
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/juxt.js', ['./internal/_curry1', './converge'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var converge = $__require('./converge');

  /**
   * juxt applies a list of functions to a list of values.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Function
   * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
   * @param {Array} fns An array of functions
   * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
   * @see R.applySpec
   * @example
   *
   *      var getRange = R.juxt([Math.min, Math.max]);
   *      getRange(3, 4, 9, -3); //=> [-3, 9]
   * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
   */
  module.exports = _curry1(function juxt(fns) {
    return converge(function () {
      return Array.prototype.slice.call(arguments, 0);
    }, fns);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/partition.js', ['./filter', './juxt', './reject'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var filter = $__require('./filter');
  var juxt = $__require('./juxt');
  var reject = $__require('./reject');

  /**
   * Takes a predicate and a list or other "filterable" object and returns the
   * pair of filterable objects of the same type of elements which do and do not
   * satisfy, the predicate, respectively.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
   * @param {Function} pred A predicate to determine which side the element belongs to.
   * @param {Array} filterable the list (or other filterable) to partition.
   * @return {Array} An array, containing first the subset of elements that satisfy the
   *         predicate, and second the subset of elements that do not satisfy.
   * @see R.filter, R.reject
   * @example
   *
   *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
   *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
   *
   *      R.partition(R.contains('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
   *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
   */
  module.exports = juxt([filter, reject]);
});
System.registerDynamic('npm:ramda@0.23.0/src/pathEq.js', ['./internal/_curry3', './equals', './path'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var equals = $__require('./equals');
  var path = $__require('./path');

  /**
   * Determines whether a nested path on an object has a specific value, in
   * `R.equals` terms. Most likely used to filter a list.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Relation
   * @typedefn Idx = String | Int
   * @sig [Idx] -> a -> {a} -> Boolean
   * @param {Array} path The path of the nested property to use
   * @param {*} val The value to compare the nested property with
   * @param {Object} obj The object to check the nested property in
   * @return {Boolean} `true` if the value equals the nested object property,
   *         `false` otherwise.
   * @example
   *
   *      var user1 = { address: { zipCode: 90210 } };
   *      var user2 = { address: { zipCode: 55555 } };
   *      var user3 = { name: 'Bob' };
   *      var users = [ user1, user2, user3 ];
   *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
   *      R.filter(isFamous, users); //=> [ user1 ]
   */
  module.exports = _curry3(function pathEq(_path, val, obj) {
    return equals(path(_path, obj), val);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/defaultTo.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns the second argument if it is not `null`, `undefined` or `NaN`
   * otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {a} default The default value.
   * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
   * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
   * @example
   *
   *      var defaultTo42 = R.defaultTo(42);
   *
   *      defaultTo42(null);  //=> 42
   *      defaultTo42(undefined);  //=> 42
   *      defaultTo42('Ramda');  //=> 'Ramda'
   *      // parseInt('string') results in NaN
   *      defaultTo42(parseInt('string')); //=> 42
   */
  module.exports = _curry2(function defaultTo(d, v) {
    return v == null || v !== v ? d : v;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/pathOr.js', ['./internal/_curry3', './defaultTo', './path'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var defaultTo = $__require('./defaultTo');
  var path = $__require('./path');

  /**
   * If the given, non-null object has a value at the given path, returns the
   * value at that path. Otherwise returns the provided default value.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig a -> [Idx] -> {a} -> a
   * @param {*} d The default value.
   * @param {Array} p The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path` of the supplied object or the default value.
   * @example
   *
   *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
   */
  module.exports = _curry3(function pathOr(d, p, obj) {
    return defaultTo(d, path(p, obj));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/path.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Retrieve the value at a given path.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig [Idx] -> {a} -> a | Undefined
   * @param {Array} path The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path`.
   * @see R.prop
   * @example
   *
   *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
   */
  module.exports = _curry2(function path(paths, obj) {
    var val = obj;
    var idx = 0;
    while (idx < paths.length) {
      if (val == null) {
        return;
      }
      val = val[paths[idx]];
      idx += 1;
    }
    return val;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/pathSatisfies.js', ['./internal/_curry3', './path'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var path = $__require('./path');

  /**
   * Returns `true` if the specified object property at given path satisfies the
   * given predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Logic
   * @typedefn Idx = String | Int
   * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
   * @param {Function} pred
   * @param {Array} propPath
   * @param {*} obj
   * @return {Boolean}
   * @see R.propSatisfies, R.path
   * @example
   *
   *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
   */
  module.exports = _curry3(function pathSatisfies(pred, propPath, obj) {
    return propPath.length > 0 && pred(path(propPath, obj));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/pick.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a partial copy of an object containing only the keys specified. If
   * the key does not exist, the property is ignored.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.omit, R.props
   * @example
   *
   *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
   */
  module.exports = _curry2(function pick(names, obj) {
    var result = {};
    var idx = 0;
    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/pickBy.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a partial copy of an object containing only the keys that satisfy
   * the supplied predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
   * @param {Function} pred A predicate to determine whether or not a key
   *        should be included on the output object.
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties that satisfy `pred`
   *         on it.
   * @see R.pick, R.filter
   * @example
   *
   *      var isUpperCase = (val, key) => key.toUpperCase() === key;
   *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
   */
  module.exports = _curry2(function pickBy(test, obj) {
    var result = {};
    for (var prop in obj) {
      if (test(obj[prop], prop, obj)) {
        result[prop] = obj[prop];
      }
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/composeK.js', ['./chain', './compose', './map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var chain = $__require('./chain');
  var compose = $__require('./compose');
  var map = $__require('./map');

  /**
   * Returns the right-to-left Kleisli composition of the provided functions,
   * each of which must return a value of a type supported by [`chain`](#chain).
   *
   * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Function
   * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipeK
   * @example
   *
   *       //  get :: String -> Object -> Maybe *
   *       var get = R.curry((propName, obj) => Maybe(obj[propName]))
   *
   *       //  getStateCode :: Maybe String -> Maybe String
   *       var getStateCode = R.composeK(
   *         R.compose(Maybe.of, R.toUpper),
   *         get('state'),
   *         get('address'),
   *         get('user'),
   *       );
   *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
   *       getStateCode({}); //=> Maybe.Nothing()
   * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
   */
  module.exports = function composeK() {
    if (arguments.length === 0) {
      throw new Error('composeK requires at least one argument');
    }
    var init = Array.prototype.slice.call(arguments);
    var last = init.pop();
    return compose(compose.apply(this, map(chain, init)), last);
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/pipeK.js', ['./composeK', './reverse'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var composeK = $__require('./composeK');
  var reverse = $__require('./reverse');

  /**
   * Returns the left-to-right Kleisli composition of the provided functions,
   * each of which must return a value of a type supported by [`chain`](#chain).
   *
   * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Function
   * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
   * @param {...Function}
   * @return {Function}
   * @see R.composeK
   * @example
   *
   *      //  parseJson :: String -> Maybe *
   *      //  get :: String -> Object -> Maybe *
   *
   *      //  getStateCode :: Maybe String -> Maybe String
   *      var getStateCode = R.pipeK(
   *        parseJson,
   *        get('user'),
   *        get('address'),
   *        get('state'),
   *        R.compose(Maybe.of, R.toUpper)
   *      );
   *
   *      getStateCode('{"user":{"address":{"state":"ny"}}}');
   *      //=> Just('NY')
   *      getStateCode('[Invalid JSON]');
   *      //=> Nothing()
   * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
   */
  module.exports = function pipeK() {
    if (arguments.length === 0) {
      throw new Error('pipeK requires at least one argument');
    }
    return composeK.apply(this, reverse(arguments));
  };
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_pipeP.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _pipeP(f, g) {
    return function () {
      var ctx = this;
      return f.apply(ctx, arguments).then(function (x) {
        return g.call(ctx, x);
      });
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/pipeP.js', ['./internal/_arity', './internal/_pipeP', './reduce', './tail'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _pipeP = $__require('./internal/_pipeP');
  var reduce = $__require('./reduce');
  var tail = $__require('./tail');

  /**
   * Performs left-to-right composition of one or more Promise-returning
   * functions. The leftmost function may have any arity; the remaining functions
   * must be unary.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.composeP
   * @example
   *
   *      //  followersForUser :: String -> Promise [User]
   *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
   */
  module.exports = function pipeP() {
    if (arguments.length === 0) {
      throw new Error('pipeP requires at least one argument');
    }
    return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/pluck.js', ['./internal/_curry2', './map', './prop'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var map = $__require('./map');
  var prop = $__require('./prop');

  /**
   * Returns a new list by plucking the same named property off all objects in
   * the list supplied.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig k -> [{k: v}] -> [v]
   * @param {Number|String} key The key name to pluck off of each object.
   * @param {Array} list The array to consider.
   * @return {Array} The list of values for the given key.
   * @see R.props
   * @example
   *
   *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
   *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
   * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
   * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
   */
  module.exports = _curry2(function pluck(p, list) {
    return map(prop(p), list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/multiply.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Multiplies two numbers. Equivalent to `a * b` but curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a * b`.
   * @see R.divide
   * @example
   *
   *      var double = R.multiply(2);
   *      var triple = R.multiply(3);
   *      double(3);       //=>  6
   *      triple(4);       //=> 12
   *      R.multiply(2, 5);  //=> 10
   */
  module.exports = _curry2(function multiply(a, b) {
    return a * b;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/product.js', ['./multiply', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var multiply = $__require('./multiply');
  var reduce = $__require('./reduce');

  /**
   * Multiplies together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The product of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.product([2,4,6,8,100,1]); //=> 38400
   */
  module.exports = reduce(multiply, 1);
});
System.registerDynamic('npm:ramda@0.23.0/src/pickAll.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Similar to `pick` except that this one includes a `key: undefined` pair for
   * properties that don't exist.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.pick
   * @example
   *
   *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
   */
  module.exports = _curry2(function pickAll(names, obj) {
    var result = {};
    var idx = 0;
    var len = names.length;
    while (idx < len) {
      var name = names[idx];
      result[name] = obj[name];
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/project.js', ['./internal/_map', './identity', './pickAll', './useWith'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _map = $__require('./internal/_map');
  var identity = $__require('./identity');
  var pickAll = $__require('./pickAll');
  var useWith = $__require('./useWith');

  /**
   * Reasonable analog to SQL `select` statement.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @category Relation
   * @sig [k] -> [{k: v}] -> [{k: v}]
   * @param {Array} props The property names to project
   * @param {Array} objs The objects to query
   * @return {Array} An array of objects with just the `props` properties.
   * @example
   *
   *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
   *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
   *      var kids = [abby, fred];
   *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
   */
  module.exports = useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity
});
System.registerDynamic('npm:ramda@0.23.0/src/prop.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a function that when supplied an object returns the indicated
   * property of that object, if it exists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig s -> {s: a} -> a | Undefined
   * @param {String} p The property name
   * @param {Object} obj The object to query
   * @return {*} The value at `obj.p`.
   * @see R.path
   * @example
   *
   *      R.prop('x', {x: 100}); //=> 100
   *      R.prop('x', {}); //=> undefined
   */
  module.exports = _curry2(function prop(p, obj) {
    return obj[p];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/propEq.js', ['./internal/_curry3', './equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var equals = $__require('./equals');

  /**
   * Returns `true` if the specified object property is equal, in `R.equals`
   * terms, to the given value; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig String -> a -> Object -> Boolean
   * @param {String} name
   * @param {*} val
   * @param {*} obj
   * @return {Boolean}
   * @see R.equals, R.propSatisfies
   * @example
   *
   *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
   *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
   *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
   *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
   *      var kids = [abby, fred, rusty, alois];
   *      var hasBrownHair = R.propEq('hair', 'brown');
   *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
   */
  module.exports = _curry3(function propEq(name, val, obj) {
    return equals(val, obj[name]);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/is.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * See if an object (`val`) is an instance of the supplied constructor. This
   * function will check up the inheritance chain, if any.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Type
   * @sig (* -> {*}) -> a -> Boolean
   * @param {Object} ctor A constructor
   * @param {*} val The value to test
   * @return {Boolean}
   * @example
   *
   *      R.is(Object, {}); //=> true
   *      R.is(Number, 1); //=> true
   *      R.is(Object, 1); //=> false
   *      R.is(String, 's'); //=> true
   *      R.is(String, new String('')); //=> true
   *      R.is(Object, new String('')); //=> true
   *      R.is(Object, 's'); //=> false
   *      R.is(Number, {}); //=> false
   */
  module.exports = _curry2(function is(Ctor, val) {
    return val != null && val.constructor === Ctor || val instanceof Ctor;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/propIs.js', ['./internal/_curry3', './is'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var is = $__require('./is');

  /**
   * Returns `true` if the specified object property is of the given type;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Type
   * @sig Type -> String -> Object -> Boolean
   * @param {Function} type
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.is, R.propSatisfies
   * @example
   *
   *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
   *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
   *      R.propIs(Number, 'x', {});            //=> false
   */
  module.exports = _curry3(function propIs(type, name, obj) {
    return is(type, obj[name]);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/propOr.js', ['./internal/_curry3', './internal/_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var _has = $__require('./internal/_has');

  /**
   * If the given, non-null object has an own property with the specified name,
   * returns the value of that property. Otherwise returns the provided default
   * value.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Object
   * @sig a -> String -> Object -> a
   * @param {*} val The default value.
   * @param {String} p The name of the property to return.
   * @param {Object} obj The object to query.
   * @return {*} The value of given property of the supplied object or the default value.
   * @example
   *
   *      var alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      var favorite = R.prop('favoriteLibrary');
   *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
   *
   *      favorite(alice);  //=> undefined
   *      favoriteWithDefault(alice);  //=> 'Ramda'
   */
  module.exports = _curry3(function propOr(val, p, obj) {
    return obj != null && _has(p, obj) ? obj[p] : val;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/propSatisfies.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Returns `true` if the specified object property satisfies the given
   * predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Logic
   * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
   * @param {Function} pred
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.propEq, R.propIs
   * @example
   *
   *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
   */
  module.exports = _curry3(function propSatisfies(pred, name, obj) {
    return pred(obj[name]);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/props.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Acts as multiple `prop`: array of keys in, array of values out. Preserves
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> [v]
   * @param {Array} ps The property names to fetch
   * @param {Object} obj The object to query
   * @return {Array} The corresponding values or partially applied function.
   * @example
   *
   *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
   *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
   *
   *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
   *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
   */
  module.exports = _curry2(function props(ps, obj) {
    var len = ps.length;
    var out = [];
    var idx = 0;

    while (idx < len) {
      out[idx] = obj[ps[idx]];
      idx += 1;
    }

    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/range.js', ['./internal/_curry2', './internal/_isNumber'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isNumber = $__require('./internal/_isNumber');

  /**
   * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> Number -> [Number]
   * @param {Number} from The first number in the list.
   * @param {Number} to One more than the last number in the list.
   * @return {Array} The list of numbers in tthe set `[a, b)`.
   * @example
   *
   *      R.range(1, 5);    //=> [1, 2, 3, 4]
   *      R.range(50, 53);  //=> [50, 51, 52]
   */
  module.exports = _curry2(function range(from, to) {
    if (!(_isNumber(from) && _isNumber(to))) {
      throw new TypeError('Both arguments to range must be numbers');
    }
    var result = [];
    var n = from;
    while (n < to) {
      result.push(n);
      n += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xreduceBy.js', ['./_curryN', './_has', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curryN = $__require('./_curryN');
  var _has = $__require('./_has');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XReduceBy(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }
    XReduceBy.prototype['@@transducer/init'] = _xfBase.init;
    XReduceBy.prototype['@@transducer/result'] = function (result) {
      var key;
      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf['@@transducer/step'](result, this.inputs[key]);
          if (result['@@transducer/reduced']) {
            result = result['@@transducer/value'];
            break;
          }
        }
      }
      this.inputs = null;
      return this.xf['@@transducer/result'](result);
    };
    XReduceBy.prototype['@@transducer/step'] = function (result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };

    return _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/reduceBy.js', ['./internal/_curryN', './internal/_dispatchable', './internal/_has', './internal/_reduce', './internal/_xreduceBy'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curryN = $__require('./internal/_curryN');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _has = $__require('./internal/_has');
  var _reduce = $__require('./internal/_reduce');
  var _xreduceBy = $__require('./internal/_xreduceBy');

  /**
   * Groups the elements of the list according to the result of calling
   * the String-returning function `keyFn` on each element and reduces the elements
   * of each group to a single value via the reducer function `valueFn`.
   *
   * This function is basically a more general `groupBy` function.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category List
   * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
   * @param {Function} valueFn The function that reduces the elements of each group to a single
   *        value. Receives two values, accumulator for a particular group and the current element.
   * @param {*} acc The (initial) accumulator value for each group.
   * @param {Function} keyFn The function that maps the list's element into a key.
   * @param {Array} list The array to group.
   * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
   *         `valueFn` for elements which produced that key when passed to `keyFn`.
   * @see R.groupBy, R.reduce
   * @example
   *
   *      var reduceToNamesBy = R.reduceBy((acc, student) => acc.concat(student.name), []);
   *      var namesByGrade = reduceToNamesBy(function(student) {
   *        var score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      var students = [{name: 'Lucy', score: 92},
   *                      {name: 'Drew', score: 85},
   *                      // ...
   *                      {name: 'Bart', score: 62}];
   *      namesByGrade(students);
   *      // {
   *      //   'A': ['Lucy'],
   *      //   'B': ['Drew']
   *      //   // ...,
   *      //   'F': ['Bart']
   *      // }
   */
  module.exports = _curryN(4, [], _dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
    return _reduce(function (acc, elt) {
      var key = keyFn(elt);
      acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
      return acc;
    }, {}, list);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/reduceWhile.js', ['./internal/_curryN', './internal/_reduce', './internal/_reduced'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curryN = $__require('./internal/_curryN');
  var _reduce = $__require('./internal/_reduce');
  var _reduced = $__require('./internal/_reduced');

  /**
   * Like `reduce`, `reduceWhile` returns a single item by iterating through
   * the list, successively calling the iterator function. `reduceWhile` also
   * takes a predicate that is evaluated before each step. If the predicate returns
   * `false`, it "short-circuits" the iteration and returns the current value
   * of the accumulator.
   *
   * @func
   * @memberOf R
   * @since v0.22.0
   * @category List
   * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} pred The predicate. It is passed the accumulator and the
   *        current element.
   * @param {Function} fn The iterator function. Receives two values, the
   *        accumulator and the current element.
   * @param {*} a The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced
   * @example
   *
   *      var isOdd = (acc, x) => x % 2 === 1;
   *      var xs = [1, 3, 5, 60, 777, 800];
   *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
   *
   *      var ys = [2, 4, 6]
   *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
   */
  module.exports = _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
    return _reduce(function (acc, x) {
      return pred(acc, x) ? fn(acc, x) : _reduced(acc);
    }, a, list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/reduced.js', ['./internal/_curry1', './internal/_reduced'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _reduced = $__require('./internal/_reduced');

  /**
   * Returns a value wrapped to indicate that it is the final value of the reduce
   * and transduce functions. The returned value should be considered a black
   * box: the internal structure is not guaranteed to be stable.
   *
   * Note: this optimization is unavailable to functions not explicitly listed
   * above. For instance, it is not currently supported by reduceRight.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category List
   * @sig a -> *
   * @param {*} x The final value of the reduce.
   * @return {*} The wrapped value.
   * @see R.reduce, R.transduce
   * @example
   *
   *      R.reduce(
   *        R.pipe(R.add, R.when(R.gte(R.__, 10), R.reduced)),
   *        0,
   *        [1, 2, 3, 4, 5]) // 10
   */

  module.exports = _curry1(_reduced);
});
System.registerDynamic('npm:ramda@0.23.0/src/remove.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Removes the sub-list of `list` starting at index `start` and containing
   * `count` elements. _Note that this is not destructive_: it returns a copy of
   * the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} start The position to start removing elements
   * @param {Number} count The number of elements to remove
   * @param {Array} list The list to remove from
   * @return {Array} A new Array with `count` elements from `start` removed.
   * @example
   *
   *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
   */
  module.exports = _curry3(function remove(start, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start, count);
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/repeat.js', ['./internal/_curry2', './always', './times'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var always = $__require('./always');
  var times = $__require('./times');

  /**
   * Returns a fixed list of size `n` containing a specified identical value.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig a -> n -> [a]
   * @param {*} value The value to repeat.
   * @param {Number} n The desired size of the output list.
   * @return {Array} A new array containing `n` `value`s.
   * @example
   *
   *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
   *
   *      var obj = {};
   *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
   *      repeatedObjs[0] === repeatedObjs[1]; //=> true
   * @symb R.repeat(a, 0) = []
   * @symb R.repeat(a, 1) = [a]
   * @symb R.repeat(a, 2) = [a, a]
   */
  module.exports = _curry2(function repeat(value, n) {
    return times(always(value), n);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/replace.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Replace a substring or regex match in a string with a replacement.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category String
   * @sig RegExp|String -> String -> String -> String
   * @param {RegExp|String} pattern A regular expression or a substring to match.
   * @param {String} replacement The string to replace the matches with.
   * @param {String} str The String to do the search and replacement in.
   * @return {String} The result.
   * @example
   *
   *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *
   *      // Use the "g" (global) flag to replace all occurrences:
   *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
   */
  module.exports = _curry3(function replace(regex, replacement, str) {
    return str.replace(regex, replacement);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/scan.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Scan is similar to reduce, but returns a list of successively reduced values
   * from the left
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (a,b -> a) -> a -> [b] -> [a]
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {Array} A list of all intermediately reduced values.
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
   * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
   */
  module.exports = _curry3(function scan(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [acc];
    while (idx < len) {
      acc = fn(acc, list[idx]);
      result[idx + 1] = acc;
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/over.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the result of applying the given function to
   * the focused value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> (a -> a) -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var headLens = R.lensIndex(0);
   *
   *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
   */
  module.exports = function () {
    // `Identity` is a functor that holds a single value, where `map` simply
    // transforms the held value with the provided function.
    var Identity = function (x) {
      return { value: x, map: function (f) {
          return Identity(f(x));
        } };
    };

    return _curry3(function over(lens, f, x) {
      // The value returned by the getter function is first transformed with `f`,
      // then set as the value of an `Identity`. This is then mapped over with the
      // setter function of the lens.
      return lens(function (y) {
        return Identity(f(y));
      })(x).value;
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/set.js', ['./internal/_curry3', './always', './over'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var always = $__require('./always');
  var over = $__require('./over');

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the given value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> a -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
   *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
   */
  module.exports = _curry3(function set(lens, v, x) {
    return over(lens, always(v), x);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/sort.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a copy of the list, sorted according to the comparator function,
   * which should accept two values at a time and return a negative number if the
   * first value is smaller, a positive number if it's larger, and zero if they
   * are equal. Please note that this is a **copy** of the list. It does not
   * modify the original.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a,a -> Number) -> [a] -> [a]
   * @param {Function} comparator A sorting function :: a -> b -> Int
   * @param {Array} list The list to sort
   * @return {Array} a new array with its elements sorted by the comparator function.
   * @example
   *
   *      var diff = function(a, b) { return a - b; };
   *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
   */
  module.exports = _curry2(function sort(comparator, list) {
    return Array.prototype.slice.call(list, 0).sort(comparator);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/sortBy.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Sorts the list according to the supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord b => (a -> b) -> [a] -> [a]
   * @param {Function} fn
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted by the keys generated by `fn`.
   * @example
   *
   *      var sortByFirstItem = R.sortBy(R.prop(0));
   *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
   *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
   *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
   *      var alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      var bob = {
   *        name: 'Bob',
   *        age: -10
   *      };
   *      var clara = {
   *        name: 'clara',
   *        age: 314.159
   *      };
   *      var people = [clara, bob, alice];
   *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
   */
  module.exports = _curry2(function sortBy(fn, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/sortWith.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Sorts a list according to a list of comparators.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Relation
   * @sig [a -> a -> Number] -> [a] -> [a]
   * @param {Array} functions A list of comparator functions.
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted according to the comarator functions.
   * @example
   *
   *      var alice = {
   *        name: 'alice',
   *        age: 40
   *      };
   *      var bob = {
   *        name: 'bob',
   *        age: 30
   *      };
   *      var clara = {
   *        name: 'clara',
   *        age: 40
   *      };
   *      var people = [clara, bob, alice];
   *      var ageNameSort = R.sortWith([
   *        R.descend(R.prop('age')),
   *        R.ascend(R.prop('name'))
   *      ]);
   *      ageNameSort(people); //=> [alice, clara, bob]
   */
  module.exports = _curry2(function sortWith(fns, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var result = 0;
      var i = 0;
      while (result === 0 && i < fns.length) {
        result = fns[i](a, b);
        i += 1;
      }
      return result;
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/split.js', ['./invoker'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var invoker = $__require('./invoker');

  /**
   * Splits a string into an array of strings based on the given
   * separator.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig (String | RegExp) -> String -> [String]
   * @param {String|RegExp} sep The pattern.
   * @param {String} str The string to separate into an array.
   * @return {Array} The array of strings from `str` separated by `str`.
   * @see R.join
   * @example
   *
   *      var pathComponents = R.split('/');
   *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
   *
   *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
   */
  module.exports = invoker(1, 'split');
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isNumber.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isNumber(x) {
    return Object.prototype.toString.call(x) === '[object Number]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/length.js', ['./internal/_curry1', './internal/_isNumber'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _isNumber = $__require('./internal/_isNumber');

  /**
   * Returns the number of elements in the array by returning `list.length`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [a] -> Number
   * @param {Array} list The array to inspect.
   * @return {Number} The length of the array.
   * @example
   *
   *      R.length([]); //=> 0
   *      R.length([1, 2, 3]); //=> 3
   */
  module.exports = _curry1(function length(list) {
    return list != null && _isNumber(list.length) ? list.length : NaN;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/splitAt.js', ['./internal/_curry2', './length', './slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var length = $__require('./length');
  var slice = $__require('./slice');

  /**
   * Splits a given list or string at a given index.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig Number -> [a] -> [[a], [a]]
   * @sig Number -> String -> [String, String]
   * @param {Number} index The index where the array/string is split.
   * @param {Array|String} array The array/string to be split.
   * @return {Array}
   * @example
   *
   *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
   *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
   *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
   */
  module.exports = _curry2(function splitAt(index, array) {
    return [slice(0, index, array), slice(index, length(array), array)];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/splitEvery.js', ['./internal/_curry2', './slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var slice = $__require('./slice');

  /**
   * Splits a collection into slices of the specified length.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @sig Number -> String -> [String]
   * @param {Number} n
   * @param {Array} list
   * @return {Array}
   * @example
   *
   *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
   *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
   */
  module.exports = _curry2(function splitEvery(n, list) {
    if (n <= 0) {
      throw new Error('First argument to splitEvery must be a positive integer');
    }
    var result = [];
    var idx = 0;
    while (idx < list.length) {
      result.push(slice(idx, idx += n, list));
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/splitWhen.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Takes a list and a predicate and returns a pair of lists with the following properties:
   *
   *  - the result of concatenating the two output lists is equivalent to the input list;
   *  - none of the elements of the first output list satisfies the predicate; and
   *  - if the second output list is non-empty, its first element satisfies the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a], [a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
   */
  module.exports = _curry2(function splitWhen(pred, list) {
    var idx = 0;
    var len = list.length;
    var prefix = [];

    while (idx < len && !pred(list[idx])) {
      prefix.push(list[idx]);
      idx += 1;
    }

    return [prefix, Array.prototype.slice.call(list, idx)];
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/subtract.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Subtracts its second argument from its first argument.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a - b`.
   * @see R.add
   * @example
   *
   *      R.subtract(10, 8); //=> 2
   *
   *      var minus5 = R.subtract(R.__, 5);
   *      minus5(17); //=> 12
   *
   *      var complementaryAngle = R.subtract(90);
   *      complementaryAngle(30); //=> 60
   *      complementaryAngle(72); //=> 18
   */
  module.exports = _curry2(function subtract(a, b) {
    return Number(a) - Number(b);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/add.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Adds two values.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a
   * @param {Number} b
   * @return {Number}
   * @see R.subtract
   * @example
   *
   *      R.add(2, 3);       //=>  5
   *      R.add(7)(10);      //=> 17
   */
  module.exports = _curry2(function add(a, b) {
    return Number(a) + Number(b);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/sum.js', ['./add', './reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var add = $__require('./add');
  var reduce = $__require('./reduce');

  /**
   * Adds together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The sum of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.sum([2,4,6,8,100,1]); //=> 121
   */
  module.exports = reduce(add, 0);
});
System.registerDynamic('npm:ramda@0.23.0/src/difference.js', ['./internal/_contains', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./internal/_contains');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Objects and Arrays are compared are compared
   * in terms of value equality, not reference equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith
   * @example
   *
   *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
   *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
   *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
   */
  module.exports = _curry2(function difference(first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    while (idx < firstLen) {
      if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
        out[out.length] = first[idx];
      }
      idx += 1;
    }
    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/symmetricDifference.js', ['./internal/_curry2', './concat', './difference'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var concat = $__require('./concat');
  var difference = $__require('./difference');

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
   * @example
   *
   *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
   *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
   */
  module.exports = _curry2(function symmetricDifference(list1, list2) {
    return concat(difference(list1, list2), difference(list2, list1));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/concat.js', ['./internal/_curry2', './internal/_isArray', './internal/_isFunction', './toString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isArray = $__require('./internal/_isArray');
  var _isFunction = $__require('./internal/_isFunction');
  var toString = $__require('./toString');

  /**
   * Returns the result of concatenating the given lists or strings.
   *
   * Note: `R.concat` expects both arguments to be of the same type,
   * unlike the native `Array.prototype.concat` method. It will throw
   * an error if you `concat` an Array with a non-Array value.
   *
   * Dispatches to the `concat` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @sig String -> String -> String
   * @param {Array|String} firstList The first list
   * @param {Array|String} secondList The second list
   * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
   * `secondList`.
   *
   * @example
   *
   *      R.concat('ABC', 'DEF'); // 'ABCDEF'
   *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   *      R.concat([], []); //=> []
   */
  module.exports = _curry2(function concat(a, b) {
    if (a == null || !_isFunction(a.concat)) {
      throw new TypeError(toString(a) + ' does not have a method named "concat"');
    }
    if (_isArray(a) && !_isArray(b)) {
      throw new TypeError(toString(b) + ' is not an array');
    }
    return a.concat(b);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/differenceWith.js', ['./internal/_containsWith', './internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _containsWith = $__require('./internal/_containsWith');
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Duplication is determined according to the
   * value returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
   * @example
   *
   *      var cmp = (x, y) => x.a === y.a;
   *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
   *      var l2 = [{a: 3}, {a: 4}];
   *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
   */
  module.exports = _curry3(function differenceWith(pred, first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    while (idx < firstLen) {
      if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
        out.push(first[idx]);
      }
      idx += 1;
    }
    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/symmetricDifferenceWith.js', ['./internal/_curry3', './concat', './differenceWith'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var concat = $__require('./concat');
  var differenceWith = $__require('./differenceWith');

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both. Duplication is determined according to the value
   * returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifference, R.difference, R.differenceWith
   * @example
   *
   *      var eqA = R.eqBy(R.prop('a'));
   *      var l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
   *      var l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
   *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
   */
  module.exports = _curry3(function symmetricDifferenceWith(pred, list1, list2) {
    return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xtake.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XTake(n, xf) {
      this.xf = xf;
      this.n = n;
      this.i = 0;
    }
    XTake.prototype['@@transducer/init'] = _xfBase.init;
    XTake.prototype['@@transducer/result'] = _xfBase.result;
    XTake.prototype['@@transducer/step'] = function (result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
      return this.i >= this.n ? _reduced(ret) : ret;
    };

    return _curry2(function _xtake(n, xf) {
      return new XTake(n, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/take.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xtake', './slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xtake = $__require('./internal/_xtake');
  var slice = $__require('./slice');

  /**
   * Returns the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `take` method).
   *
   * Dispatches to the `take` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*}
   * @see R.drop
   * @example
   *
   *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(3, 'ramda');               //=> 'ram'
   *
   *      var personnel = [
   *        'Dave Brubeck',
   *        'Paul Desmond',
   *        'Eugene Wright',
   *        'Joe Morello',
   *        'Gerry Mulligan',
   *        'Bob Bates',
   *        'Joe Dodge',
   *        'Ron Crotty'
   *      ];
   *
   *      var takeFive = R.take(5);
   *      takeFive(personnel);
   *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
   * @symb R.take(-1, [a, b]) = [a, b]
   * @symb R.take(0, [a, b]) = []
   * @symb R.take(1, [a, b]) = [a]
   * @symb R.take(2, [a, b]) = [a, b]
   */
  module.exports = _curry2(_dispatchable(['take'], _xtake, function take(n, xs) {
    return slice(0, n < 0 ? Infinity : n, xs);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xdrop.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XDrop(n, xf) {
      this.xf = xf;
      this.n = n;
    }
    XDrop.prototype['@@transducer/init'] = _xfBase.init;
    XDrop.prototype['@@transducer/result'] = _xfBase.result;
    XDrop.prototype['@@transducer/step'] = function (result, input) {
      if (this.n > 0) {
        this.n -= 1;
        return result;
      }
      return this.xf['@@transducer/step'](result, input);
    };

    return _curry2(function _xdrop(n, xf) {
      return new XDrop(n, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/drop.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xdrop', './slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xdrop = $__require('./internal/_xdrop');
  var slice = $__require('./slice');

  /**
   * Returns all but the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `drop` method).
   *
   * Dispatches to the `drop` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {[a]} list
   * @return {[a]} A copy of list without the first `n` elements
   * @see R.take, R.transduce, R.dropLast, R.dropWhile
   * @example
   *
   *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(3, 'ramda');               //=> 'da'
   */
  module.exports = _curry2(_dispatchable(['drop'], _xdrop, function drop(n, xs) {
    return slice(Math.max(0, n), Infinity, xs);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/takeLast.js', ['./internal/_curry2', './drop'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var drop = $__require('./drop');

  /**
   * Returns a new list containing the last `n` elements of the given list.
   * If `n > list.length`, returns a list of `list.length` elements.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements to return.
   * @param {Array} xs The collection to consider.
   * @return {Array}
   * @see R.dropLast
   * @example
   *
   *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(3, 'ramda');               //=> 'mda'
   */
  module.exports = _curry2(function takeLast(n, xs) {
    return drop(n >= 0 ? xs.length - n : 0, xs);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/takeLastWhile.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new list containing the last `n` elements of a given list, passing
   * each value to the supplied predicate function, and terminating when the
   * predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @param {Function} fn The function called per iteration.
   * @param {Array} list The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropLastWhile, R.addIndex
   * @example
   *
   *      var isNotOne = x => x !== 1;
   *
   *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
   */
  module.exports = _curry2(function takeLastWhile(fn, list) {
    var idx = list.length - 1;
    while (idx >= 0 && fn(list[idx])) {
      idx -= 1;
    }
    return Array.prototype.slice.call(list, idx + 1);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_reduced.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _reduced(x) {
    return x && x['@@transducer/reduced'] ? x : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xtakeWhile.js', ['./_curry2', './_reduced', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _reduced = $__require('./_reduced');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XTakeWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
    XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
    XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
    };

    return _curry2(function _xtakeWhile(f, xf) {
      return new XTakeWhile(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/takeWhile.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_xtakeWhile'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _xtakeWhile = $__require('./internal/_xtakeWhile');

  /**
   * Returns a new list containing the first `n` elements of a given list,
   * passing each value to the supplied predicate function, and terminating when
   * the predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * Dispatches to the `takeWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @param {Function} fn The function called per iteration.
   * @param {Array} list The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropWhile, R.transduce, R.addIndex
   * @example
   *
   *      var isNotFour = x => x !== 4;
   *
   *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
   */
  module.exports = _curry2(_dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len && fn(list[idx])) {
      idx += 1;
    }
    return Array.prototype.slice.call(list, 0, idx);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/tap.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Runs the given function with the supplied object, then returns the object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a -> *) -> a -> a
   * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
   * @param {*} x
   * @return {*} `x`.
   * @example
   *
   *      var sayX = x => console.log('x is ' + x);
   *      R.tap(sayX, 100); //=> 100
   *      // logs 'x is 100'
   * @symb R.tap(f, a) = a
   */
  module.exports = _curry2(function tap(fn, x) {
    fn(x);
    return x;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_cloneRegExp.js', [], true, function ($__require, exports, module) {
                                  var global = this || self,
                                      GLOBAL = global;
                                  module.exports = function _cloneRegExp(pattern) {
                                                                    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
                                  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isRegExp.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isRegExp(x) {
    return Object.prototype.toString.call(x) === '[object RegExp]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/test.js', ['./internal/_cloneRegExp', './internal/_curry2', './internal/_isRegExp', './toString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _cloneRegExp = $__require('./internal/_cloneRegExp');
  var _curry2 = $__require('./internal/_curry2');
  var _isRegExp = $__require('./internal/_isRegExp');
  var toString = $__require('./toString');

  /**
   * Determines whether a given string matches a given regular expression.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category String
   * @sig RegExp -> String -> Boolean
   * @param {RegExp} pattern
   * @param {String} str
   * @return {Boolean}
   * @see R.match
   * @example
   *
   *      R.test(/^x/, 'xyz'); //=> true
   *      R.test(/^y/, 'xyz'); //=> false
   */
  module.exports = _curry2(function test(pattern, str) {
    if (!_isRegExp(pattern)) {
      throw new TypeError('‘test’ requires a value of type RegExp as its first argument; received ' + toString(pattern));
    }
    return _cloneRegExp(pattern).test(str);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/times.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Calls an input function `n` times, returning an array containing the results
   * of those function calls.
   *
   * `fn` is passed one argument: The current value of `n`, which begins at `0`
   * and is gradually incremented to `n - 1`.
   *
   * @func
   * @memberOf R
   * @since v0.2.3
   * @category List
   * @sig (Number -> a) -> Number -> [a]
   * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
   * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
   * @return {Array} An array containing the return values of all calls to `fn`.
   * @example
   *
   *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
   * @symb R.times(f, 0) = []
   * @symb R.times(f, 1) = [f(0)]
   * @symb R.times(f, 2) = [f(0), f(1)]
   */
  module.exports = _curry2(function times(fn, n) {
    var len = Number(n);
    var idx = 0;
    var list;

    if (len < 0 || isNaN(len)) {
      throw new RangeError('n must be a non-negative number');
    }
    list = new Array(len);
    while (idx < len) {
      list[idx] = fn(idx);
      idx += 1;
    }
    return list;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/toLower.js', ['./invoker'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var invoker = $__require('./invoker');

  /**
   * The lower case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to lower case.
   * @return {String} The lower case version of `str`.
   * @see R.toUpper
   * @example
   *
   *      R.toLower('XYZ'); //=> 'xyz'
   */
  module.exports = invoker(0, 'toLowerCase');
});
System.registerDynamic('npm:ramda@0.23.0/src/toPairs.js', ['./internal/_curry1', './internal/_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _has = $__require('./internal/_has');

  /**
   * Converts an object into an array of key, value arrays. Only the object's
   * own properties are used.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own properties.
   * @see R.fromPairs
   * @example
   *
   *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
   */
  module.exports = _curry1(function toPairs(obj) {
    var pairs = [];
    for (var prop in obj) {
      if (_has(prop, obj)) {
        pairs[pairs.length] = [prop, obj[prop]];
      }
    }
    return pairs;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/toPairsIn.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Converts an object into an array of key, value arrays. The object's own
   * properties and prototype properties are used. Note that the order of the
   * output array is not guaranteed to be consistent across different JS
   * platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own
   *         and prototype properties.
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
   */
  module.exports = _curry1(function toPairsIn(obj) {
    var pairs = [];
    for (var prop in obj) {
      pairs[pairs.length] = [prop, obj[prop]];
    }
    return pairs;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isFunction.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isFunction(x) {
    return Object.prototype.toString.call(x) === '[object Function]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_quote.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _quote(s) {
    var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');

    return '"' + escaped.replace(/"/g, '\\"') + '"';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_toISOString.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
   */
  module.exports = function () {
    var pad = function pad(n) {
      return (n < 10 ? '0' : '') + n;
    };

    return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
      return d.toISOString();
    } : function _toISOString(d) {
      return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_toString.js', ['./_contains', './_map', './_quote', './_toISOString', '../keys', '../reject'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./_contains');
  var _map = $__require('./_map');
  var _quote = $__require('./_quote');
  var _toISOString = $__require('./_toISOString');
  var keys = $__require('../keys');
  var reject = $__require('../reject');

  module.exports = function _toString(x, seen) {
    var recur = function recur(y) {
      var xs = seen.concat([x]);
      return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
    };

    //  mapPairs :: (Object, [String]) -> [String]
    var mapPairs = function (obj, keys) {
      return _map(function (k) {
        return _quote(k) + ': ' + recur(obj[k]);
      }, keys.slice().sort());
    };

    switch (Object.prototype.toString.call(x)) {
      case '[object Arguments]':
        return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
      case '[object Array]':
        return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
          return (/^\d+$/.test(k)
          );
        }, keys(x)))).join(', ') + ']';
      case '[object Boolean]':
        return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
      case '[object Date]':
        return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
      case '[object Null]':
        return 'null';
      case '[object Number]':
        return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
      case '[object String]':
        return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
      case '[object Undefined]':
        return 'undefined';
      default:
        if (typeof x.toString === 'function') {
          var repr = x.toString();
          if (repr !== '[object Object]') {
            return repr;
          }
        }
        return '{' + mapPairs(x, keys(x)).join(', ') + '}';
    }
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/toString.js', ['./internal/_curry1', './internal/_toString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _toString = $__require('./internal/_toString');

  /**
   * Returns the string representation of the given value. `eval`'ing the output
   * should result in a value equivalent to the input value. Many of the built-in
   * `toString` methods do not satisfy this requirement.
   *
   * If the given value is an `[object Object]` with a `toString` method other
   * than `Object.prototype.toString`, this method is invoked with no arguments
   * to produce the return value. This means user-defined constructor functions
   * can provide a suitable `toString` method. For example:
   *
   *     function Point(x, y) {
   *       this.x = x;
   *       this.y = y;
   *     }
   *
   *     Point.prototype.toString = function() {
   *       return 'new Point(' + this.x + ', ' + this.y + ')';
   *     };
   *
   *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category String
   * @sig * -> String
   * @param {*} val
   * @return {String}
   * @example
   *
   *      R.toString(42); //=> '42'
   *      R.toString('abc'); //=> '"abc"'
   *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
   *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
   *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
   */
  module.exports = _curry1(function toString(val) {
    return _toString(val, []);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/invoker.js', ['./internal/_curry2', './internal/_isFunction', './curryN', './toString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _isFunction = $__require('./internal/_isFunction');
  var curryN = $__require('./curryN');
  var toString = $__require('./toString');

  /**
   * Turns a named method with a specified arity into a function that can be
   * called directly supplied with arguments and a target object.
   *
   * The returned function is curried and accepts `arity + 1` parameters where
   * the final parameter is the target object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
   * @param {Number} arity Number of arguments the returned function should take
   *        before the target object.
   * @param {String} method Name of the method to call.
   * @return {Function} A new curried function.
   * @example
   *
   *      var sliceFrom = R.invoker(1, 'slice');
   *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
   *      var sliceFrom6 = R.invoker(2, 'slice')(6);
   *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
   * @symb R.invoker(0, 'method')(o) = o['method']()
   * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
   * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
   */
  module.exports = _curry2(function invoker(arity, method) {
    return curryN(arity + 1, function () {
      var target = arguments[arity];
      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }
      throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/toUpper.js', ['./invoker'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var invoker = $__require('./invoker');

  /**
   * The upper case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to upper case.
   * @return {String} The upper case version of `str`.
   * @see R.toLower
   * @example
   *
   *      R.toUpper('abc'); //=> 'ABC'
   */
  module.exports = invoker(0, 'toUpperCase');
});
System.registerDynamic('npm:ramda@0.23.0/src/transduce.js', ['./internal/_reduce', './internal/_xwrap', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _reduce = $__require('./internal/_reduce');
  var _xwrap = $__require('./internal/_xwrap');
  var curryN = $__require('./curryN');

  /**
   * Initializes a transducer using supplied iterator function. Returns a single
   * item by iterating through the list, successively calling the transformed
   * iterator function and passing it an accumulator value and the current value
   * from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It will be
   * wrapped as a transformer to initialize the transducer. A transformer can be
   * passed directly in place of an iterator function. In both cases, iteration
   * may be stopped early with the `R.reduced` function.
   *
   * A transducer is a function that accepts a transformer and returns a
   * transformer and can be composed directly.
   *
   * A transformer is an an object that provides a 2-arity reducing iterator
   * function, step, 0-arity initial value function, init, and 1-arity result
   * extraction function, result. The step function is used as the iterator
   * function in reduce. The result function is used to convert the final
   * accumulator into the return type and in most cases is R.identity. The init
   * function can be used to provide an initial accumulator, but is ignored by
   * transduce.
   *
   * The iteration is performed with R.reduce after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array. Wrapped as transformer, if necessary, and used to
   *        initialize the transducer
   * @param {*} acc The initial accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced, R.into
   * @example
   *
   *      var numbers = [1, 2, 3, 4];
   *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
   */
  module.exports = curryN(4, function transduce(xf, fn, acc, list) {
    return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/transpose.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Transposes the rows and columns of a 2D list.
   * When passed a list of `n` lists of length `x`,
   * returns a list of `x` lists of length `n`.
   *
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [[a]] -> [[a]]
   * @param {Array} list A 2D list
   * @return {Array} A 2D list
   * @example
   *
   *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
   *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   *
   * If some of the rows are shorter than the following rows, their elements are skipped:
   *
   *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
   * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
   * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
   * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
   */
  module.exports = _curry1(function transpose(outerlist) {
    var i = 0;
    var result = [];
    while (i < outerlist.length) {
      var innerlist = outerlist[i];
      var j = 0;
      while (j < innerlist.length) {
        if (typeof result[j] === 'undefined') {
          result[j] = [];
        }
        result[j].push(innerlist[j]);
        j += 1;
      }
      i += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/ap.js', ['./internal/_concat', './internal/_curry2', './internal/_reduce', './map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry2 = $__require('./internal/_curry2');
  var _reduce = $__require('./internal/_reduce');
  var map = $__require('./map');

  /**
   * ap applies a list of functions to a list of values.
   *
   * Dispatches to the `ap` method of the second argument, if present. Also
   * treats curried functions as applicatives.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig [a -> b] -> [a] -> [b]
   * @sig Apply f => f (a -> b) -> f a -> f b
   * @param {Array} fns An array of functions
   * @param {Array} vs An array of values
   * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
   * @example
   *
   *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
   *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
   * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
   */
  module.exports = _curry2(function ap(applicative, fn) {
    return typeof applicative.ap === 'function' ? applicative.ap(fn) : typeof applicative === 'function' ? function (x) {
      return applicative(x)(fn(x));
    } :
    // else
    _reduce(function (acc, f) {
      return _concat(acc, map(f, fn));
    }, [], applicative);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/prepend.js', ['./internal/_concat', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new list with the given element at the front, followed by the
   * contents of the list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The item to add to the head of the output list.
   * @param {Array} list The array to add to the tail of the output list.
   * @return {Array} A new array.
   * @see R.append
   * @example
   *
   *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
   */
  module.exports = _curry2(function prepend(el, list) {
    return _concat([el], list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/reduceRight.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * Similar to `reduce`, except moves through the input list from the right to
   * the left.
   *
   * The iterator function receives two values: *(value, acc)*, while the arguments'
   * order of `reduce`'s iterator function is *(acc, value)*.
   *
   * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a, b -> b) -> b -> [a] -> b
   * @param {Function} fn The iterator function. Receives two values, the current element from the array
   *        and the accumulator.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.addIndex
   * @example
   *
   *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
   *          -               -2
   *         / \              / \
   *        1   -            1   3
   *           / \              / \
   *          2   -     ==>    2  -1
   *             / \              / \
   *            3   -            3   4
   *               / \              / \
   *              4   0            4   0
   *
   * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
   */
  module.exports = _curry3(function reduceRight(fn, acc, list) {
    var idx = list.length - 1;
    while (idx >= 0) {
      acc = fn(list[idx], acc);
      idx -= 1;
    }
    return acc;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/sequence.js', ['./internal/_curry2', './ap', './map', './prepend', './reduceRight'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var ap = $__require('./ap');
  var map = $__require('./map');
  var prepend = $__require('./prepend');
  var reduceRight = $__require('./reduceRight');

  /**
   * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
   * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
   * Applicative of Traversable.
   *
   * Dispatches to the `sequence` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
   * @param {Function} of
   * @param {*} traversable
   * @return {*}
   * @see R.traverse
   * @example
   *
   *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
   *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
   *
   *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
   *      R.sequence(R.of, Nothing());       //=> [Nothing()]
   */
  module.exports = _curry2(function sequence(of, traversable) {
    return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
      return ap(map(prepend, x), acc);
    }, of([]), traversable);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/traverse.js', ['./internal/_curry3', './map', './sequence'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var map = $__require('./map');
  var sequence = $__require('./sequence');

  /**
   * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
   * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
   * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
   * into an Applicative of Traversable.
   *
   * Dispatches to the `sequence` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
   * @param {Function} of
   * @param {Function} f
   * @param {*} traversable
   * @return {*}
   * @see R.sequence
   * @example
   *
   *      // Returns `Nothing` if the given divisor is `0`
   *      safeDiv = n => d => d === 0 ? Nothing() : Just(n / d)
   *
   *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Just([5, 2.5, 2])
   *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Nothing
   */
  module.exports = _curry3(function traverse(of, f, traversable) {
    return sequence(of, map(f, traversable));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/trim.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Removes (strips) whitespace from both ends of the string.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to trim.
   * @return {String} Trimmed version of `str`.
   * @example
   *
   *      R.trim('   xyz  '); //=> 'xyz'
   *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
   */
  module.exports = function () {
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var hasProtoTrim = typeof String.prototype.trim === 'function';
    if (!hasProtoTrim || ws.trim() || !zeroWidth.trim()) {
      return _curry1(function trim(str) {
        var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
        var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
        return str.replace(beginRx, '').replace(endRx, '');
      });
    } else {
      return _curry1(function trim(str) {
        return str.trim();
      });
    }
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/tryCatch.js', ['./internal/_arity', './internal/_concat', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _concat = $__require('./internal/_concat');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
   * function evaluates the `tryer`; if it does not throw, it simply returns the
   * result. If the `tryer` *does* throw, the returned function evaluates the
   * `catcher` function and returns its result. Note that for effective
   * composition with this function, both the `tryer` and `catcher` functions
   * must return the same type of results.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
   * @param {Function} tryer The function that may throw.
   * @param {Function} catcher The function that will be evaluated if `tryer` throws.
   * @return {Function} A new function that will catch exceptions and send then to the catcher.
   * @example
   *
   *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
   *      R.tryCatch(R.prop('x'), R.F)(null);      //=> false
   */
  module.exports = _curry2(function _tryCatch(tryer, catcher) {
    return _arity(tryer.length, function () {
      try {
        return tryer.apply(this, arguments);
      } catch (e) {
        return catcher.apply(this, _concat([e], arguments));
      }
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/unapply.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Takes a function `fn`, which takes a single array argument, and returns a
   * function which:
   *
   *   - takes any number of positional arguments;
   *   - passes these arguments to `fn` as an array; and
   *   - returns the result.
   *
   * In other words, R.unapply derives a variadic function from a function which
   * takes an array. R.unapply is the inverse of R.apply.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Function
   * @sig ([*...] -> a) -> (*... -> a)
   * @param {Function} fn
   * @return {Function}
   * @see R.apply
   * @example
   *
   *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
   * @symb R.unapply(f)(a, b) = f([a, b])
   */
  module.exports = _curry1(function unapply(fn) {
    return function () {
      return fn(Array.prototype.slice.call(arguments, 0));
    };
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/nAry.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly `n` parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} n The desired arity of the new function.
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity `n`.
   * @example
   *
   *      var takesTwoArgs = (a, b) => [a, b];
   *
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      var takesOneArg = R.nAry(1, takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only `n` arguments are passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.nAry(0, f)(a, b) = f()
   * @symb R.nAry(1, f)(a, b) = f(a)
   * @symb R.nAry(2, f)(a, b) = f(a, b)
   */
  module.exports = _curry2(function nAry(n, fn) {
    switch (n) {
      case 0:
        return function () {
          return fn.call(this);
        };
      case 1:
        return function (a0) {
          return fn.call(this, a0);
        };
      case 2:
        return function (a0, a1) {
          return fn.call(this, a0, a1);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.call(this, a0, a1, a2);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.call(this, a0, a1, a2, a3);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.call(this, a0, a1, a2, a3, a4);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.call(this, a0, a1, a2, a3, a4, a5);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
        };
      default:
        throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
    }
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/unary.js', ['./internal/_curry1', './nAry'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var nAry = $__require('./nAry');

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 1 parameter. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (* -> b) -> (a -> b)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 1.
   * @example
   *
   *      var takesTwoArgs = function(a, b) {
   *        return [a, b];
   *      };
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      var takesOneArg = R.unary(takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only 1 argument is passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.unary(f)(a, b, c) = f(a)
   */
  module.exports = _curry1(function unary(fn) {
    return nAry(1, fn);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/uncurryN.js', ['./internal/_curry2', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var curryN = $__require('./curryN');

  /**
   * Returns a function of arity `n` from a (manually) curried function.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Function
   * @sig Number -> (a -> b) -> (a -> c)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to uncurry.
   * @return {Function} A new function.
   * @see R.curry
   * @example
   *
   *      var addFour = a => b => c => d => a + b + c + d;
   *
   *      var uncurriedAddFour = R.uncurryN(4, addFour);
   *      uncurriedAddFour(1, 2, 3, 4); //=> 10
   */
  module.exports = _curry2(function uncurryN(depth, fn) {
    return curryN(depth, function () {
      var currentDepth = 1;
      var value = fn;
      var idx = 0;
      var endIdx;
      while (currentDepth <= depth && typeof value === 'function') {
        endIdx = currentDepth === depth ? arguments.length : idx + value.length;
        value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
        currentDepth += 1;
        idx = endIdx;
      }
      return value;
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/unfold.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Builds a list from a seed value. Accepts an iterator function, which returns
   * either false to stop iteration or an array of length 2 containing the value
   * to add to the resulting list and the seed to be used in the next call to the
   * iterator function.
   *
   * The iterator function receives one argument: *(seed)*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (a -> [b]) -> * -> [b]
   * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
   *        either false to quit iteration or an array of length two to proceed. The element
   *        at index 0 of this array will be added to the resulting array, and the element
   *        at index 1 will be passed to the next call to `fn`.
   * @param {*} seed The seed value.
   * @return {Array} The final list.
   * @example
   *
   *      var f = n => n > 50 ? false : [-n, n + 10];
   *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
   * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
   */
  module.exports = _curry2(function unfold(fn, seed) {
    var pair = fn(seed);
    var result = [];
    while (pair && pair.length) {
      result[result.length] = pair[0];
      pair = fn(pair[1]);
    }
    return result;
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_pipe.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/reduce.js', ['./internal/_curry3', './internal/_reduce'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var _reduce = $__require('./internal/_reduce');

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * `R.reduced` to shortcut the iteration.
   *
   * The arguments' order of `reduceRight`'s iterator function is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Dispatches to the `reduce` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *                -               -10
   *               / \              / \
   *              -   4           -6   4
   *             / \              / \
   *            -   3   ==>     -3   3
   *           / \              / \
   *          -   2           -1   2
   *         / \              / \
   *        0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */
  module.exports = _curry3(_reduce);
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_checkForMethod.js', ['./_isArray'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _isArray = $__require('./_isArray');

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implemtation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */
  module.exports = function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;
      if (length === 0) {
        return fn();
      }
      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/slice.js', ['./internal/_checkForMethod', './internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _checkForMethod = $__require('./internal/_checkForMethod');
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */
  module.exports = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/tail.js', ['./internal/_checkForMethod', './internal/_curry1', './slice'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _checkForMethod = $__require('./internal/_checkForMethod');
  var _curry1 = $__require('./internal/_curry1');
  var slice = $__require('./slice');

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */
  module.exports = _curry1(_checkForMethod('tail', slice(1, Infinity)));
});
System.registerDynamic('npm:ramda@0.23.0/src/pipe.js', ['./internal/_arity', './internal/_pipe', './reduce', './tail'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _pipe = $__require('./internal/_pipe');
  var reduce = $__require('./reduce');
  var tail = $__require('./tail');

  /**
   * Performs left-to-right function composition. The leftmost function may have
   * any arity; the remaining functions must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      var f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   */
  module.exports = function pipe() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }
    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/reverse.js', ['./internal/_curry1', './internal/_isString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _isString = $__require('./internal/_isString');

  /**
   * Returns a new list or string with the elements or characters in reverse
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {Array|String} list
   * @return {Array|String}
   * @example
   *
   *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
   *      R.reverse([1, 2]);     //=> [2, 1]
   *      R.reverse([1]);        //=> [1]
   *      R.reverse([]);         //=> []
   *
   *      R.reverse('abc');      //=> 'cba'
   *      R.reverse('ab');       //=> 'ba'
   *      R.reverse('a');        //=> 'a'
   *      R.reverse('');         //=> ''
   */
  module.exports = _curry1(function reverse(list) {
    return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/compose.js', ['./pipe', './reverse'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var pipe = $__require('./pipe');
  var reverse = $__require('./reverse');

  /**
   * Performs right-to-left function composition. The rightmost function may have
   * any arity; the remaining functions must be unary.
   *
   * **Note:** The result of compose is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipe
   * @example
   *
   *      var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
   *      var yellGreeting = R.compose(R.toUpper, classyGreeting);
   *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
   *
   * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
   */
  module.exports = function compose() {
    if (arguments.length === 0) {
      throw new Error('compose requires at least one argument');
    }
    return pipe.apply(this, reverse(arguments));
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/union.js', ['./internal/_concat', './internal/_curry2', './compose', './uniq'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry2 = $__require('./internal/_curry2');
  var compose = $__require('./compose');
  var uniq = $__require('./uniq');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @example
   *
   *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
   */
  module.exports = _curry2(compose(uniq, _concat));
});
System.registerDynamic('npm:ramda@0.23.0/src/unionWith.js', ['./internal/_concat', './internal/_curry3', './uniqWith'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry3 = $__require('./internal/_curry3');
  var uniqWith = $__require('./uniqWith');

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list. Duplication is determined according to the value returned by
   * applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig (a -> a -> Boolean) -> [*] -> [*] -> [*]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @see R.union
   * @example
   *
   *      var l1 = [{a: 1}, {a: 2}];
   *      var l2 = [{a: 1}, {a: 4}];
   *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
   */
  module.exports = _curry3(function unionWith(pred, list1, list2) {
    return uniqWith(pred, _concat(list1, list2));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/identity.js', ['./internal/_curry1', './internal/_identity'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _identity = $__require('./internal/_identity');

  /**
   * A function that does nothing but return the parameter supplied to it. Good
   * as a default or placeholder function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> a
   * @param {*} x The value to return.
   * @return {*} The input value, `x`.
   * @example
   *
   *      R.identity(1); //=> 1
   *
   *      var obj = {};
   *      R.identity(obj) === obj; //=> true
   * @symb R.identity(a) = a
   */
  module.exports = _curry1(_identity);
});
System.registerDynamic('npm:ramda@0.23.0/src/uniq.js', ['./identity', './uniqBy'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var identity = $__require('./identity');
  var uniqBy = $__require('./uniqBy');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list. `R.equals` is used to determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
   *      R.uniq([1, '1']);     //=> [1, '1']
   *      R.uniq([[42], [42]]); //=> [[42]]
   */
  module.exports = uniqBy(identity);
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_Set.js', ['./_contains'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./_contains');

  // A simple Set type that honours R.equals semantics
  module.exports = function () {
    function _Set() {
      /* globals Set */
      this._nativeSet = typeof Set === 'function' ? new Set() : null;
      this._items = {};
    }

    // until we figure out why jsdoc chokes on this
    // @param item The item to add to the Set
    // @returns {boolean} true if the item did not exist prior, otherwise false
    //
    _Set.prototype.add = function (item) {
      return !hasOrAdd(item, true, this);
    };

    //
    // @param item The item to check for existence in the Set
    // @returns {boolean} true if the item exists in the Set, otherwise false
    //
    _Set.prototype.has = function (item) {
      return hasOrAdd(item, false, this);
    };

    //
    // Combines the logic for checking whether an item is a member of the set and
    // for adding a new item to the set.
    //
    // @param item       The item to check or add to the Set instance.
    // @param shouldAdd  If true, the item will be added to the set if it doesn't
    //                   already exist.
    // @param set        The set instance to check or add to.
    // @return {boolean} true if the item already existed, otherwise false.
    //
    function hasOrAdd(item, shouldAdd, set) {
      var type = typeof item;
      var prevSize, newSize;
      switch (type) {
        case 'string':
        case 'number':
          // distinguish between +0 and -0
          if (item === 0 && 1 / item === -Infinity) {
            if (set._items['-0']) {
              return true;
            } else {
              if (shouldAdd) {
                set._items['-0'] = true;
              }
              return false;
            }
          }
          // these types can all utilise the native Set
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;
              set._nativeSet.add(item);
              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = {};
                set._items[type][item] = true;
              }
              return false;
            } else if (item in set._items[type]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][item] = true;
              }
              return false;
            }
          }

        case 'boolean':
          // set._items['boolean'] holds a two element array
          // representing [ falseExists, trueExists ]
          if (type in set._items) {
            var bIdx = item ? 1 : 0;
            if (set._items[type][bIdx]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][bIdx] = true;
              }
              return false;
            }
          } else {
            if (shouldAdd) {
              set._items[type] = item ? [false, true] : [true, false];
            }
            return false;
          }

        case 'function':
          // compare functions for reference equality
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;
              set._nativeSet.add(item);
              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = [item];
              }
              return false;
            }
            if (!_contains(item, set._items[type])) {
              if (shouldAdd) {
                set._items[type].push(item);
              }
              return false;
            }
            return true;
          }

        case 'undefined':
          if (set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type] = true;
            }
            return false;
          }

        case 'object':
          if (item === null) {
            if (!set._items['null']) {
              if (shouldAdd) {
                set._items['null'] = true;
              }
              return false;
            }
            return true;
          }
        /* falls through */
        default:
          // reduce the search size of heterogeneous sets by creating buckets
          // for each type.
          type = Object.prototype.toString.call(item);
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          // scan through all previously applied items
          if (!_contains(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
      }
    }
    return _Set;
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/uniqBy.js', ['./internal/_Set', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _Set = $__require('./internal/_Set');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied function to
   * each list element. Prefers the first item if the supplied function produces
   * the same value on two items. `R.equals` is used for comparison.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> b) -> [a] -> [a]
   * @param {Function} fn A function used to produce a value to use during comparisons.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
   */
  module.exports = _curry2(function uniqBy(fn, list) {
    var set = new _Set();
    var result = [];
    var idx = 0;
    var appliedItem, item;

    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);
      if (set.add(appliedItem)) {
        result.push(item);
      }
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_containsWith.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _containsWith(pred, x, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/uniqWith.js', ['./internal/_containsWith', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _containsWith = $__require('./internal/_containsWith');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied predicate to
   * two list elements. Prefers the first item if two items compare equal based
   * on the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category List
   * @sig (a, a -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      var strEq = R.eqBy(String);
   *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
   *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
   *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
   *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
   */
  module.exports = _curry2(function uniqWith(pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;
    while (idx < len) {
      item = list[idx];
      if (!_containsWith(pred, item, result)) {
        result[result.length] = item;
      }
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/unless.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is not satisfied, the function will return the result of
   * calling the `whenFalseFn` function with the same argument. If the predicate
   * is satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred        A predicate function
   * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
   *                               to a falsy value.
   * @param {*}        x           An object to test with the `pred` function and
   *                               pass to `whenFalseFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
   * @see R.ifElse, R.when
   * @example
   *
   *      // coerceArray :: (a|[a]) -> [a]
   *      var coerceArray = R.unless(R.isArrayLike, R.of);
   *      coerceArray([1, 2, 3]); //=> [1, 2, 3]
   *      coerceArray(1);         //=> [1]
   */
  module.exports = _curry3(function unless(pred, whenFalseFn, x) {
    return pred(x) ? x : whenFalseFn(x);
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_identity.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _identity(x) {
    return x;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_makeFlat.js', ['../isArrayLike'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var isArrayLike = $__require('../isArrayLike');

  /**
   * `_makeFlat` is a helper function that returns a one-level or fully recursive
   * function based on the flag passed in.
   *
   * @private
   */
  module.exports = function _makeFlat(recursive) {
    return function flatt(list) {
      var value, jlen, j;
      var result = [];
      var idx = 0;
      var ilen = list.length;

      while (idx < ilen) {
        if (isArrayLike(list[idx])) {
          value = recursive ? flatt(list[idx]) : list[idx];
          j = 0;
          jlen = value.length;
          while (j < jlen) {
            result[result.length] = value[j];
            j += 1;
          }
        } else {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
      return result;
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_forceReduced.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _forceReduced(x) {
    return {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_flatCat.js', ['./_forceReduced', './_reduce', './_xfBase', '../isArrayLike'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _forceReduced = $__require('./_forceReduced');
  var _reduce = $__require('./_reduce');
  var _xfBase = $__require('./_xfBase');
  var isArrayLike = $__require('../isArrayLike');

  module.exports = function () {
    var preservingReduced = function (xf) {
      return {
        '@@transducer/init': _xfBase.init,
        '@@transducer/result': function (result) {
          return xf['@@transducer/result'](result);
        },
        '@@transducer/step': function (result, input) {
          var ret = xf['@@transducer/step'](result, input);
          return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
        }
      };
    };

    return function _xcat(xf) {
      var rxf = preservingReduced(xf);
      return {
        '@@transducer/init': _xfBase.init,
        '@@transducer/result': function (result) {
          return rxf['@@transducer/result'](result);
        },
        '@@transducer/step': function (result, input) {
          return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
        }
      };
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xchain.js', ['./_curry2', './_flatCat', '../map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _flatCat = $__require('./_flatCat');
  var map = $__require('../map');

  module.exports = _curry2(function _xchain(f, xf) {
    return map(f, _flatCat(xf));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/chain.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_makeFlat', './internal/_xchain', './map'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _makeFlat = $__require('./internal/_makeFlat');
  var _xchain = $__require('./internal/_xchain');
  var map = $__require('./map');

  /**
   * `chain` maps a function over a list and concatenates the results. `chain`
   * is also known as `flatMap` in some libraries
   *
   * Dispatches to the `chain` method of the second argument, if present,
   * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain m => (a -> m b) -> m a -> m b
   * @param {Function} fn The function to map with
   * @param {Array} list The list to map over
   * @return {Array} The result of flat-mapping `list` with `fn`
   * @example
   *
   *      var duplicate = n => [n, n];
   *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
   *
   *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
   */
  module.exports = _curry2(_dispatchable(['chain'], _xchain, function chain(fn, monad) {
    if (typeof monad === 'function') {
      return function (x) {
        return fn(monad(x))(x);
      };
    }
    return _makeFlat(false)(map(fn, monad));
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/unnest.js', ['./internal/_identity', './chain'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _identity = $__require('./internal/_identity');
  var chain = $__require('./chain');

  /**
   * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
   * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain c => c (c a) -> c a
   * @param {*} list
   * @return {*}
   * @see R.flatten, R.chain
   * @example
   *
   *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
   *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
   */
  module.exports = chain(_identity);
});
System.registerDynamic('npm:ramda@0.23.0/src/until.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Takes a predicate, a transformation function, and an initial value,
   * and returns a value of the same type as the initial value.
   * It does so by applying the transformation until the predicate is satisfied,
   * at which point it returns the satisfactory value.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred A predicate function
   * @param {Function} fn The iterator function
   * @param {*} init Initial value
   * @return {*} Final value that satisfies predicate
   * @example
   *
   *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
   */
  module.exports = _curry3(function until(pred, fn, init) {
    var val = init;
    while (!pred(val)) {
      val = fn(val);
    }
    return val;
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_concat.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * Private `concat` function to merge two array-like objects.
   *
   * @private
   * @param {Array|Arguments} [set1=[]] An array-like object.
   * @param {Array|Arguments} [set2=[]] An array-like object.
   * @return {Array} A new, merged array.
   * @example
   *
   *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   */
  module.exports = function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];

    idx = 0;
    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }
    idx = 0;
    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }
    return result;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/adjust.js', ['./internal/_concat', './internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _concat = $__require('./internal/_concat');
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Applies a function to the value at the given index of an array, returning a
   * new copy of the array with the element at the given index replaced with the
   * result of the function application.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig (a -> a) -> Number -> [a] -> [a]
   * @param {Function} fn The function to apply.
   * @param {Number} idx The index.
   * @param {Array|Arguments} list An array-like object whose value
   *        at the supplied index will be replaced.
   * @return {Array} A copy of the supplied array-like object with
   *         the element at index `idx` replaced with the value
   *         returned by applying `fn` to the existing element.
   * @see R.update
   * @example
   *
   *      R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
   *      R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
   * @symb R.adjust(f, -1, [a, b]) = [a, f(b)]
   * @symb R.adjust(f, 0, [a, b]) = [f(a), b]
   */
  module.exports = _curry3(function adjust(fn, idx, list) {
    if (idx >= list.length || idx < -list.length) {
      return list;
    }
    var start = idx < 0 ? list.length : 0;
    var _idx = start + idx;
    var _list = _concat(list);
    _list[_idx] = fn(list[_idx]);
    return _list;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/always.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Returns a function that always returns the given value. Note that for
   * non-primitives the value returned is a reference to the original value.
   *
   * This function is known as `const`, `constant`, or `K` (for K combinator) in
   * other languages and libraries.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> (* -> a)
   * @param {*} val The value to wrap in a function
   * @return {Function} A Function :: * -> val.
   * @example
   *
   *      var t = R.always('Tee');
   *      t(); //=> 'Tee'
   */
  module.exports = _curry1(function always(val) {
    return function () {
      return val;
    };
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/update.js', ['./internal/_curry3', './adjust', './always'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');
  var adjust = $__require('./adjust');
  var always = $__require('./always');

  /**
   * Returns a new copy of the array with the element at the provided index
   * replaced with the given value.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} idx The index to update.
   * @param {*} x The value to exist at the given index of the returned array.
   * @param {Array|Arguments} list The source array-like object to be updated.
   * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
   * @see R.adjust
   * @example
   *
   *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
   *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
   * @symb R.update(-1, a, [b, c]) = [b, a]
   * @symb R.update(0, a, [b, c]) = [a, c]
   * @symb R.update(1, a, [b, c]) = [b, a]
   */
  module.exports = _curry3(function update(idx, x, list) {
    return adjust(always(x), idx, list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/useWith.js', ['./internal/_curry2', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var curryN = $__require('./curryN');

  /**
   * Accepts a function `fn` and a list of transformer functions and returns a
   * new curried function. When the new function is invoked, it calls the
   * function `fn` with parameters consisting of the result of calling each
   * supplied handler on successive arguments to the new function.
   *
   * If more arguments are passed to the returned function than transformer
   * functions, those arguments are passed directly to `fn` as additional
   * parameters. If you expect additional arguments that don't need to be
   * transformed, although you can ignore them, it's best to pass an identity
   * function so that the new function reports the correct arity.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (x1 -> x2 -> ... -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} fn The function to wrap.
   * @param {Array} transformers A list of transformer functions
   * @return {Function} The wrapped function.
   * @see R.converge
   * @example
   *
   *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
   *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
   *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
   *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
   * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
   */
  module.exports = _curry2(function useWith(fn, transformers) {
    return curryN(transformers.length, function () {
      var args = [];
      var idx = 0;
      while (idx < transformers.length) {
        args.push(transformers[idx].call(this, arguments[idx]));
        idx += 1;
      }
      return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/values.js', ['./internal/_curry1', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var keys = $__require('./keys');

  /**
   * Returns a list of all the enumerable own properties of the supplied object.
   * Note that the order of the output array is not guaranteed across different
   * JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own properties.
   * @example
   *
   *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
   */
  module.exports = _curry1(function values(obj) {
    var props = keys(obj);
    var len = props.length;
    var vals = [];
    var idx = 0;
    while (idx < len) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }
    return vals;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/valuesIn.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Returns a list of all the properties, including prototype properties, of the
   * supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own and prototype properties.
   * @example
   *
   *      var F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      var f = new F();
   *      R.valuesIn(f); //=> ['X', 'Y']
   */
  module.exports = _curry1(function valuesIn(obj) {
    var prop;
    var vs = [];
    for (prop in obj) {
      vs[vs.length] = obj[prop];
    }
    return vs;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/view.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns a "view" of the given data structure, determined by the given lens.
   * The lens's focus determines which portion of the data structure is visible.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> s -> a
   * @param {Lens} lens
   * @param {*} x
   * @return {*}
   * @see R.prop, R.lensIndex, R.lensProp
   * @example
   *
   *      var xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});  //=> 1
   *      R.view(xLens, {x: 4, y: 2});  //=> 4
   */
  module.exports = function () {
    // `Const` is a functor that effectively ignores the function given to `map`.
    var Const = function (x) {
      return { value: x, map: function () {
          return this;
        } };
    };

    return _curry2(function view(lens, x) {
      // Using `Const` effectively ignores the setter function of the `lens`,
      // leaving the value returned by the getter function unmodified.
      return lens(Const)(x).value;
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/when.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is satisfied, the function will return the result of calling
   * the `whenTrueFn` function with the same argument. If the predicate is not
   * satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred       A predicate function
   * @param {Function} whenTrueFn A function to invoke when the `condition`
   *                              evaluates to a truthy value.
   * @param {*}        x          An object to test with the `pred` function and
   *                              pass to `whenTrueFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
   * @see R.ifElse, R.unless
   * @example
   *
   *      // truncate :: String -> String
   *      var truncate = R.when(
   *        R.propSatisfies(R.gt(R.__, 10), 'length'),
   *        R.pipe(R.take(10), R.append('…'), R.join(''))
   *      );
   *      truncate('12345');         //=> '12345'
   *      truncate('0123456789ABC'); //=> '0123456789…'
   */
  module.exports = _curry3(function when(pred, whenTrueFn, x) {
    return pred(x) ? whenTrueFn(x) : x;
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_map.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);
    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xmap.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;
    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return _curry2(function _xmap(f, xf) {
      return new XMap(f, xf);
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/map.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_map', './internal/_reduce', './internal/_xmap', './curryN', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _map = $__require('./internal/_map');
  var _reduce = $__require('./internal/_reduce');
  var _xmap = $__require('./internal/_xmap');
  var curryN = $__require('./curryN');
  var keys = $__require('./keys');

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex
   * @example
   *
   *      var double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */
  module.exports = _curry2(_dispatchable(['map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });
      case '[object Object]':
        return _reduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));
      default:
        return _map(fn, functor);
    }
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/where.js', ['./internal/_curry2', './internal/_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _has = $__require('./internal/_has');

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec. Each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `where` returns true if all the predicates return true, false
   * otherwise.
   *
   * `where` is well suited to declaratively expressing constraints for other
   * functions such as `filter` and `find`.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @example
   *
   *      // pred :: Object -> Boolean
   *      var pred = R.where({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('bar')),
   *        x: R.gt(__, 10),
   *        y: R.lt(__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
   */
  module.exports = _curry2(function where(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && !spec[prop](testObj[prop])) {
        return false;
      }
    }
    return true;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/whereEq.js', ['./internal/_curry2', './equals', './map', './where'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var equals = $__require('./equals');
  var map = $__require('./map');
  var where = $__require('./where');

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec, false otherwise. An object satisfies the spec if, for each of the
   * spec's own properties, accessing that property of the object gives the same
   * value (in `R.equals` terms) as accessing that property of the spec.
   *
   * `whereEq` is a specialization of [`where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @sig {String: *} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      var pred = R.whereEq({a: 1, b: 2});
   *
   *      pred({a: 1});              //=> false
   *      pred({a: 1, b: 2});        //=> true
   *      pred({a: 1, b: 2, c: 3});  //=> true
   *      pred({a: 1, b: 1});        //=> false
   */
  module.exports = _curry2(function whereEq(spec, testObj) {
    return where(map(equals, spec), testObj);
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_arrayFromIterator.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_functionName.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _functionName(f) {
    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var match = String(f).match(/^function (\w*)/);
    return match == null ? '' : match[1];
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/identical.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Returns true if its arguments are identical, false otherwise. Values are
   * identical if they reference the same memory. `NaN` is identical to `NaN`;
   * `0` and `-0` are not identical.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      var o = {};
   *      R.identical(o, o); //=> true
   *      R.identical(1, 1); //=> true
   *      R.identical(1, '1'); //=> false
   *      R.identical([], []); //=> false
   *      R.identical(0, -0); //=> false
   *      R.identical(NaN, NaN); //=> true
   */
  module.exports = _curry2(function identical(a, b) {
    // SameValue algorithm
    if (a === b) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return a !== 0 || 1 / a === 1 / b;
    } else {
      // Step 6.a: NaN == NaN
      return a !== a && b !== b;
    }
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/type.js', ['./internal/_curry1'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig (* -> {*}) -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   */
  module.exports = _curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_equals.js', ['./_arrayFromIterator', './_functionName', './_has', '../identical', '../keys', '../type'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arrayFromIterator = $__require('./_arrayFromIterator');
  var _functionName = $__require('./_functionName');
  var _has = $__require('./_has');
  var identical = $__require('../identical');
  var keys = $__require('../keys');
  var type = $__require('../type');

  module.exports = function _equals(a, b, stackA, stackB) {
    if (identical(a, b)) {
      return true;
    }

    if (type(a) !== type(b)) {
      return false;
    }

    if (a == null || b == null) {
      return false;
    }

    if (typeof a.equals === 'function' || typeof b.equals === 'function') {
      return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
    }

    switch (type(a)) {
      case 'Arguments':
      case 'Array':
      case 'Object':
        if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
          return a === b;
        }
        break;
      case 'Boolean':
      case 'Number':
      case 'String':
        if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case 'Date':
        if (!identical(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case 'Error':
        return a.name === b.name && a.message === b.message;
      case 'RegExp':
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
      case 'Map':
      case 'Set':
        if (!_equals(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
          return false;
        }
        break;
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
        break;
      case 'ArrayBuffer':
        break;
      default:
        // Values of other types are only equal if identical.
        return false;
    }

    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }

    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }

    stackA.push(a);
    stackB.push(b);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], stackA, stackB))) {
        return false;
      }
      idx -= 1;
    }
    stackA.pop();
    stackB.pop();
    return true;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/equals.js', ['./internal/_curry2', './internal/_equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _equals = $__require('./internal/_equals');

  /**
   * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
   * cyclical data structures.
   *
   * Dispatches symmetrically to the `equals` methods of both arguments, if
   * present.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> b -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      R.equals(1, 1); //=> true
   *      R.equals(1, '1'); //=> false
   *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
   *
   *      var a = {}; a.v = a;
   *      var b = {}; b.v = b;
   *      R.equals(a, b); //=> true
   */
  module.exports = _curry2(function equals(a, b) {
    return _equals(a, b, [], []);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_indexOf.js', ['../equals'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var equals = $__require('../equals');

  module.exports = function _indexOf(list, a, idx) {
    var inf, item;
    // Array.prototype.indexOf doesn't exist below IE9
    if (typeof list.indexOf === 'function') {
      switch (typeof a) {
        case 'number':
          if (a === 0) {
            // manually crawl the list to distinguish between +0 and -0
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            // NaN
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === 'number' && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          // non-zero numbers can utilise Set
          return list.indexOf(a, idx);

        // all these types can utilise Set
        case 'string':
        case 'boolean':
        case 'function':
        case 'undefined':
          return list.indexOf(a, idx);

        case 'object':
          if (a === null) {
            // null can utilise Set
            return list.indexOf(a, idx);
          }
      }
    }
    // anything else not covered above, defer to R.equals
    while (idx < list.length) {
      if (equals(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_contains.js', ['./_indexOf'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _indexOf = $__require('./_indexOf');

  module.exports = function _contains(a, list) {
    return _indexOf(list, a, 0) >= 0;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_curryN.js', ['./_arity', './_isPlaceholder'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./_arity');
  var _isPlaceholder = $__require('./_isPlaceholder');

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  module.exports = function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        }
        combinedIdx += 1;
      }
      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/curryN.js', ['./internal/_arity', './internal/_curry1', './internal/_curry2', './internal/_curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _curry1 = $__require('./internal/_curry1');
  var _curry2 = $__require('./internal/_curry2');
  var _curryN = $__require('./internal/_curryN');

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value `R.__` may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is `R.__`, the
   * following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      var sumArgs = (...args) => R.sum(args);
   *
   *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      var f = curriedAddFourNumbers(1, 2);
   *      var g = f(3);
   *      g(4); //=> 10
   */
  module.exports = _curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }
    return _arity(length, _curryN(length, [], fn));
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/curry.js', ['./internal/_curry1', './curryN'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var curryN = $__require('./curryN');

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value `R.__` may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is `R.__`, the
   * following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN
   * @example
   *
   *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
   *
   *      var curriedAddFourNumbers = R.curry(addFourNumbers);
   *      var f = curriedAddFourNumbers(1, 2);
   *      var g = f(3);
   *      g(4); //=> 10
   */
  module.exports = _curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/flip.js', ['./internal/_curry1', './curry'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var curry = $__require('./curry');

  /**
   * Returns a new function much like the supplied one, except that the first two
   * arguments' order is reversed.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
   * @param {Function} fn The function to invoke with its first two parameters reversed.
   * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
   * @example
   *
   *      var mergeThree = (a, b, c) => [].concat(a, b, c);
   *
   *      mergeThree(1, 2, 3); //=> [1, 2, 3]
   *
   *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
   * @symb R.flip(f)(a, b, c) = f(b, a, c)
   */
  module.exports = _curry1(function flip(fn) {
    return curry(function (a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_complement.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _complement(f) {
    return function () {
      return !f.apply(this, arguments);
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isTransformer.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isTransformer(obj) {
    return typeof obj['@@transducer/step'] === 'function';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_dispatchable.js', ['./_isArray', './_isTransformer'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _isArray = $__require('./_isArray');
  var _isTransformer = $__require('./_isTransformer');

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer [xf] to return a new transformer (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} xf transducer to initialize if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */
  module.exports = function _dispatchable(methodNames, xf, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }
      var args = Array.prototype.slice.call(arguments, 0);
      var obj = args.pop();
      if (!_isArray(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, args);
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = xf.apply(null, args);
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  };
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_filter.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];

    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }
      idx += 1;
    }
    return result;
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isObject.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xwrap.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function () {
    function XWrap(fn) {
      this.f = fn;
    }
    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };
    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };
    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return function _xwrap(fn) {
      return new XWrap(fn);
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_arity.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };
      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/bind.js', ['./internal/_arity', './internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _arity = $__require('./internal/_arity');
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      var log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */
  module.exports = _curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isArray.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  module.exports = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isString.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/isArrayLike.js', ['./internal/_curry1', './internal/_isArray', './internal/_isString'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _isArray = $__require('./internal/_isArray');
  var _isString = $__require('./internal/_isString');

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @deprecated since v0.23.0
   * @example
   *
   *      R.isArrayLike([]); //=> true
   *      R.isArrayLike(true); //=> false
   *      R.isArrayLike({}); //=> false
   *      R.isArrayLike({length: 10}); //=> false
   *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   */
  module.exports = _curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }
    if (!x) {
      return false;
    }
    if (typeof x !== 'object') {
      return false;
    }
    if (_isString(x)) {
      return false;
    }
    if (x.nodeType === 1) {
      return !!x.length;
    }
    if (x.length === 0) {
      return true;
    }
    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }
    return false;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_reduce.js', ['./_xwrap', '../bind', '../isArrayLike'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _xwrap = $__require('./_xwrap');
  var bind = $__require('../bind');
  var isArrayLike = $__require('../isArrayLike');

  module.exports = function () {
    function _arrayReduce(xf, acc, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        acc = xf['@@transducer/step'](acc, list[idx]);
        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }
        idx += 1;
      }
      return xf['@@transducer/result'](acc);
    }

    function _iterableReduce(xf, acc, iter) {
      var step = iter.next();
      while (!step.done) {
        acc = xf['@@transducer/step'](acc, step.value);
        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }
        step = iter.next();
      }
      return xf['@@transducer/result'](acc);
    }

    function _methodReduce(xf, acc, obj) {
      return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
    }

    var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
    return function _reduce(fn, acc, list) {
      if (typeof fn === 'function') {
        fn = _xwrap(fn);
      }
      if (isArrayLike(list)) {
        return _arrayReduce(fn, acc, list);
      }
      if (typeof list.reduce === 'function') {
        return _methodReduce(fn, acc, list);
      }
      if (list[symIterator] != null) {
        return _iterableReduce(fn, acc, list[symIterator]());
      }
      if (typeof list.next === 'function') {
        return _iterableReduce(fn, acc, list);
      }
      throw new TypeError('reduce: list must be array or iterable');
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfBase.js', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_xfilter.js', ['./_curry2', './_xfBase'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./_curry2');
  var _xfBase = $__require('./_xfBase');

  module.exports = function () {
    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }
    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;
    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return _curry2(function _xfilter(f, xf) {
      return new XFilter(f, xf);
    });
  }();
});
System.registerDynamic("npm:ramda@0.23.0/src/internal/_has.js", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isArguments.js', ['./_has'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _has = $__require('./_has');

  module.exports = function () {
    var toString = Object.prototype.toString;
    return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/keys.js', ['./internal/_curry1', './internal/_has', './internal/_isArguments'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./internal/_curry1');
  var _has = $__require('./internal/_has');
  var _isArguments = $__require('./internal/_isArguments');

  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */
  module.exports = function () {
    // cover IE < 9 keys issues
    var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    // Safari bug
    var hasArgsEnumBug = function () {
      'use strict';

      return arguments.propertyIsEnumerable('length');
    }();

    var contains = function contains(list, item) {
      var idx = 0;
      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }
        idx += 1;
      }
      return false;
    };

    return typeof Object.keys === 'function' && !hasArgsEnumBug ? _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) : _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
  }();
});
System.registerDynamic('npm:ramda@0.23.0/src/filter.js', ['./internal/_curry2', './internal/_dispatchable', './internal/_filter', './internal/_isObject', './internal/_reduce', './internal/_xfilter', './keys'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');
  var _dispatchable = $__require('./internal/_dispatchable');
  var _filter = $__require('./internal/_filter');
  var _isObject = $__require('./internal/_isObject');
  var _reduce = $__require('./internal/_reduce');
  var _xfilter = $__require('./internal/_xfilter');
  var keys = $__require('./keys');

  /**
   * Takes a predicate and a "filterable", and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      var isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */
  module.exports = _curry2(_dispatchable(['filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _reduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }
      return acc;
    }, {}, keys(filterable)) :
    // else
    _filter(pred, filterable);
  }));
});
System.registerDynamic('npm:ramda@0.23.0/src/reject.js', ['./internal/_complement', './internal/_curry2', './filter'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _complement = $__require('./internal/_complement');
  var _curry2 = $__require('./internal/_curry2');
  var filter = $__require('./filter');

  /**
   * The complement of `filter`.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.filter, R.transduce, R.addIndex
   * @example
   *
   *      var isOdd = (n) => n % 2 === 1;
   *
   *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */
  module.exports = _curry2(function reject(pred, filterable) {
    return filter(_complement(pred), filterable);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/without.js', ['./internal/_contains', './internal/_curry2', './flip', './reject'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _contains = $__require('./internal/_contains');
  var _curry2 = $__require('./internal/_curry2');
  var flip = $__require('./flip');
  var reject = $__require('./reject');

  /**
   * Returns a new list without values in the first argument.
   * `R.equals` is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @param {Array} list1 The values to be removed from `list2`.
   * @param {Array} list2 The array to remove values from.
   * @return {Array} The new array without values in `list1`.
   * @see R.transduce
   * @example
   *
   *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
   */
  module.exports = _curry2(function (xs, list) {
    return reject(flip(_contains)(xs), list);
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/xprod.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a new list out of the two supplied by creating each possible pair
   * from the lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The list made by combining each possible pair from
   *         `as` and `bs` into pairs (`[a, b]`).
   * @example
   *
   *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
   * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
   */
  module.exports = _curry2(function xprod(a, b) {
    // = xprodWith(prepend); (takes about 3 times as long...)
    var idx = 0;
    var ilen = a.length;
    var j;
    var jlen = b.length;
    var result = [];
    while (idx < ilen) {
      j = 0;
      while (j < jlen) {
        result[result.length] = [a[idx], b[j]];
        j += 1;
      }
      idx += 1;
    }
    return result;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/zip.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a new list out of the two supplied by pairing up equally-positioned
   * items from both lists. The returned list is truncated to the length of the
   * shorter of the two input lists.
   * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
   * @example
   *
   *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
   */
  module.exports = _curry2(function zip(a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);
    while (idx < len) {
      rv[idx] = [a[idx], b[idx]];
      idx += 1;
    }
    return rv;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/zipObj.js', ['./internal/_curry2'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry2 = $__require('./internal/_curry2');

  /**
   * Creates a new object out of a list of keys and a list of values.
   * Key/value pairing is truncated to the length of the shorter of the two lists.
   * Note: `zipObj` is equivalent to `pipe(zipWith(pair), fromPairs)`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [String] -> [*] -> {String: *}
   * @param {Array} keys The array that will be properties on the output object.
   * @param {Array} values The list of values on the output object.
   * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
   * @example
   *
   *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
   */
  module.exports = _curry2(function zipObj(keys, values) {
    var idx = 0;
    var len = Math.min(keys.length, values.length);
    var out = {};
    while (idx < len) {
      out[keys[idx]] = values[idx];
      idx += 1;
    }
    return out;
  });
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_curry1.js', ['./_isPlaceholder'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _isPlaceholder = $__require('./_isPlaceholder');

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  module.exports = function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_curry2.js', ['./_curry1', './_isPlaceholder'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./_curry1');
  var _isPlaceholder = $__require('./_isPlaceholder');

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  module.exports = function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_isPlaceholder.js', [], true, function ($__require, exports, module) {
       var global = this || self,
           GLOBAL = global;
       module.exports = function _isPlaceholder(a) {
              return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
       };
});
System.registerDynamic('npm:ramda@0.23.0/src/internal/_curry3.js', ['./_curry1', './_curry2', './_isPlaceholder'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry1 = $__require('./_curry1');
  var _curry2 = $__require('./_curry2');
  var _isPlaceholder = $__require('./_isPlaceholder');

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */
  module.exports = function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  };
});
System.registerDynamic('npm:ramda@0.23.0/src/zipWith.js', ['./internal/_curry3'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  var _curry3 = $__require('./internal/_curry3');

  /**
   * Creates a new list out of the two supplied by applying the function to each
   * equally-positioned pair in the lists. The returned list is truncated to the
   * length of the shorter of the two input lists.
   *
   * @function
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a,b -> c) -> [a] -> [b] -> [c]
   * @param {Function} fn The function used to combine the two elements into one value.
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
   *         using `fn`.
   * @example
   *
   *      var f = (x, y) => {
   *        // ...
   *      };
   *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
   *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
   * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
   */
  module.exports = _curry3(function zipWith(fn, a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);
    while (idx < len) {
      rv[idx] = fn(a[idx], b[idx]);
      idx += 1;
    }
    return rv;
  });
});
System.registerDynamic("npm:ramda@0.23.0.json", [], true, function() {
  return {
    "main": "index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      },
      "tmp-test-bundle.js": {
        "cjsRequireDetection": false
      }
    }
  };
});

System.registerDynamic('npm:ramda@0.23.0/index.js', ['./src/F', './src/T', './src/__', './src/add', './src/addIndex', './src/adjust', './src/all', './src/allPass', './src/always', './src/and', './src/any', './src/anyPass', './src/ap', './src/aperture', './src/append', './src/apply', './src/applySpec', './src/ascend', './src/assoc', './src/assocPath', './src/binary', './src/bind', './src/both', './src/call', './src/chain', './src/clamp', './src/clone', './src/comparator', './src/complement', './src/compose', './src/composeK', './src/composeP', './src/concat', './src/cond', './src/construct', './src/constructN', './src/contains', './src/converge', './src/countBy', './src/curry', './src/curryN', './src/dec', './src/descend', './src/defaultTo', './src/difference', './src/differenceWith', './src/dissoc', './src/dissocPath', './src/divide', './src/drop', './src/dropLast', './src/dropLastWhile', './src/dropRepeats', './src/dropRepeatsWith', './src/dropWhile', './src/either', './src/empty', './src/eqBy', './src/eqProps', './src/equals', './src/evolve', './src/filter', './src/find', './src/findIndex', './src/findLast', './src/findLastIndex', './src/flatten', './src/flip', './src/forEach', './src/forEachObjIndexed', './src/fromPairs', './src/groupBy', './src/groupWith', './src/gt', './src/gte', './src/has', './src/hasIn', './src/head', './src/identical', './src/identity', './src/ifElse', './src/inc', './src/indexBy', './src/indexOf', './src/init', './src/insert', './src/insertAll', './src/intersection', './src/intersectionWith', './src/intersperse', './src/into', './src/invert', './src/invertObj', './src/invoker', './src/is', './src/isArrayLike', './src/isEmpty', './src/isNil', './src/join', './src/juxt', './src/keys', './src/keysIn', './src/last', './src/lastIndexOf', './src/length', './src/lens', './src/lensIndex', './src/lensPath', './src/lensProp', './src/lift', './src/liftN', './src/lt', './src/lte', './src/map', './src/mapAccum', './src/mapAccumRight', './src/mapObjIndexed', './src/match', './src/mathMod', './src/max', './src/maxBy', './src/mean', './src/median', './src/memoize', './src/merge', './src/mergeAll', './src/mergeWith', './src/mergeWithKey', './src/min', './src/minBy', './src/modulo', './src/multiply', './src/nAry', './src/negate', './src/none', './src/not', './src/nth', './src/nthArg', './src/objOf', './src/of', './src/omit', './src/once', './src/or', './src/over', './src/pair', './src/partial', './src/partialRight', './src/partition', './src/path', './src/pathEq', './src/pathOr', './src/pathSatisfies', './src/pick', './src/pickAll', './src/pickBy', './src/pipe', './src/pipeK', './src/pipeP', './src/pluck', './src/prepend', './src/product', './src/project', './src/prop', './src/propEq', './src/propIs', './src/propOr', './src/propSatisfies', './src/props', './src/range', './src/reduce', './src/reduceBy', './src/reduceRight', './src/reduceWhile', './src/reduced', './src/reject', './src/remove', './src/repeat', './src/replace', './src/reverse', './src/scan', './src/sequence', './src/set', './src/slice', './src/sort', './src/sortBy', './src/sortWith', './src/split', './src/splitAt', './src/splitEvery', './src/splitWhen', './src/subtract', './src/sum', './src/symmetricDifference', './src/symmetricDifferenceWith', './src/tail', './src/take', './src/takeLast', './src/takeLastWhile', './src/takeWhile', './src/tap', './src/test', './src/times', './src/toLower', './src/toPairs', './src/toPairsIn', './src/toString', './src/toUpper', './src/transduce', './src/transpose', './src/traverse', './src/trim', './src/tryCatch', './src/type', './src/unapply', './src/unary', './src/uncurryN', './src/unfold', './src/union', './src/unionWith', './src/uniq', './src/uniqBy', './src/uniqWith', './src/unless', './src/unnest', './src/until', './src/update', './src/useWith', './src/values', './src/valuesIn', './src/view', './src/when', './src/where', './src/whereEq', './src/without', './src/xprod', './src/zip', './src/zipObj', './src/zipWith'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = {
    F: $__require('./src/F'),
    T: $__require('./src/T'),
    __: $__require('./src/__'),
    add: $__require('./src/add'),
    addIndex: $__require('./src/addIndex'),
    adjust: $__require('./src/adjust'),
    all: $__require('./src/all'),
    allPass: $__require('./src/allPass'),
    always: $__require('./src/always'),
    and: $__require('./src/and'),
    any: $__require('./src/any'),
    anyPass: $__require('./src/anyPass'),
    ap: $__require('./src/ap'),
    aperture: $__require('./src/aperture'),
    append: $__require('./src/append'),
    apply: $__require('./src/apply'),
    applySpec: $__require('./src/applySpec'),
    ascend: $__require('./src/ascend'),
    assoc: $__require('./src/assoc'),
    assocPath: $__require('./src/assocPath'),
    binary: $__require('./src/binary'),
    bind: $__require('./src/bind'),
    both: $__require('./src/both'),
    call: $__require('./src/call'),
    chain: $__require('./src/chain'),
    clamp: $__require('./src/clamp'),
    clone: $__require('./src/clone'),
    comparator: $__require('./src/comparator'),
    complement: $__require('./src/complement'),
    compose: $__require('./src/compose'),
    composeK: $__require('./src/composeK'),
    composeP: $__require('./src/composeP'),
    concat: $__require('./src/concat'),
    cond: $__require('./src/cond'),
    construct: $__require('./src/construct'),
    constructN: $__require('./src/constructN'),
    contains: $__require('./src/contains'),
    converge: $__require('./src/converge'),
    countBy: $__require('./src/countBy'),
    curry: $__require('./src/curry'),
    curryN: $__require('./src/curryN'),
    dec: $__require('./src/dec'),
    descend: $__require('./src/descend'),
    defaultTo: $__require('./src/defaultTo'),
    difference: $__require('./src/difference'),
    differenceWith: $__require('./src/differenceWith'),
    dissoc: $__require('./src/dissoc'),
    dissocPath: $__require('./src/dissocPath'),
    divide: $__require('./src/divide'),
    drop: $__require('./src/drop'),
    dropLast: $__require('./src/dropLast'),
    dropLastWhile: $__require('./src/dropLastWhile'),
    dropRepeats: $__require('./src/dropRepeats'),
    dropRepeatsWith: $__require('./src/dropRepeatsWith'),
    dropWhile: $__require('./src/dropWhile'),
    either: $__require('./src/either'),
    empty: $__require('./src/empty'),
    eqBy: $__require('./src/eqBy'),
    eqProps: $__require('./src/eqProps'),
    equals: $__require('./src/equals'),
    evolve: $__require('./src/evolve'),
    filter: $__require('./src/filter'),
    find: $__require('./src/find'),
    findIndex: $__require('./src/findIndex'),
    findLast: $__require('./src/findLast'),
    findLastIndex: $__require('./src/findLastIndex'),
    flatten: $__require('./src/flatten'),
    flip: $__require('./src/flip'),
    forEach: $__require('./src/forEach'),
    forEachObjIndexed: $__require('./src/forEachObjIndexed'),
    fromPairs: $__require('./src/fromPairs'),
    groupBy: $__require('./src/groupBy'),
    groupWith: $__require('./src/groupWith'),
    gt: $__require('./src/gt'),
    gte: $__require('./src/gte'),
    has: $__require('./src/has'),
    hasIn: $__require('./src/hasIn'),
    head: $__require('./src/head'),
    identical: $__require('./src/identical'),
    identity: $__require('./src/identity'),
    ifElse: $__require('./src/ifElse'),
    inc: $__require('./src/inc'),
    indexBy: $__require('./src/indexBy'),
    indexOf: $__require('./src/indexOf'),
    init: $__require('./src/init'),
    insert: $__require('./src/insert'),
    insertAll: $__require('./src/insertAll'),
    intersection: $__require('./src/intersection'),
    intersectionWith: $__require('./src/intersectionWith'),
    intersperse: $__require('./src/intersperse'),
    into: $__require('./src/into'),
    invert: $__require('./src/invert'),
    invertObj: $__require('./src/invertObj'),
    invoker: $__require('./src/invoker'),
    is: $__require('./src/is'),
    isArrayLike: $__require('./src/isArrayLike'),
    isEmpty: $__require('./src/isEmpty'),
    isNil: $__require('./src/isNil'),
    join: $__require('./src/join'),
    juxt: $__require('./src/juxt'),
    keys: $__require('./src/keys'),
    keysIn: $__require('./src/keysIn'),
    last: $__require('./src/last'),
    lastIndexOf: $__require('./src/lastIndexOf'),
    length: $__require('./src/length'),
    lens: $__require('./src/lens'),
    lensIndex: $__require('./src/lensIndex'),
    lensPath: $__require('./src/lensPath'),
    lensProp: $__require('./src/lensProp'),
    lift: $__require('./src/lift'),
    liftN: $__require('./src/liftN'),
    lt: $__require('./src/lt'),
    lte: $__require('./src/lte'),
    map: $__require('./src/map'),
    mapAccum: $__require('./src/mapAccum'),
    mapAccumRight: $__require('./src/mapAccumRight'),
    mapObjIndexed: $__require('./src/mapObjIndexed'),
    match: $__require('./src/match'),
    mathMod: $__require('./src/mathMod'),
    max: $__require('./src/max'),
    maxBy: $__require('./src/maxBy'),
    mean: $__require('./src/mean'),
    median: $__require('./src/median'),
    memoize: $__require('./src/memoize'),
    merge: $__require('./src/merge'),
    mergeAll: $__require('./src/mergeAll'),
    mergeWith: $__require('./src/mergeWith'),
    mergeWithKey: $__require('./src/mergeWithKey'),
    min: $__require('./src/min'),
    minBy: $__require('./src/minBy'),
    modulo: $__require('./src/modulo'),
    multiply: $__require('./src/multiply'),
    nAry: $__require('./src/nAry'),
    negate: $__require('./src/negate'),
    none: $__require('./src/none'),
    not: $__require('./src/not'),
    nth: $__require('./src/nth'),
    nthArg: $__require('./src/nthArg'),
    objOf: $__require('./src/objOf'),
    of: $__require('./src/of'),
    omit: $__require('./src/omit'),
    once: $__require('./src/once'),
    or: $__require('./src/or'),
    over: $__require('./src/over'),
    pair: $__require('./src/pair'),
    partial: $__require('./src/partial'),
    partialRight: $__require('./src/partialRight'),
    partition: $__require('./src/partition'),
    path: $__require('./src/path'),
    pathEq: $__require('./src/pathEq'),
    pathOr: $__require('./src/pathOr'),
    pathSatisfies: $__require('./src/pathSatisfies'),
    pick: $__require('./src/pick'),
    pickAll: $__require('./src/pickAll'),
    pickBy: $__require('./src/pickBy'),
    pipe: $__require('./src/pipe'),
    pipeK: $__require('./src/pipeK'),
    pipeP: $__require('./src/pipeP'),
    pluck: $__require('./src/pluck'),
    prepend: $__require('./src/prepend'),
    product: $__require('./src/product'),
    project: $__require('./src/project'),
    prop: $__require('./src/prop'),
    propEq: $__require('./src/propEq'),
    propIs: $__require('./src/propIs'),
    propOr: $__require('./src/propOr'),
    propSatisfies: $__require('./src/propSatisfies'),
    props: $__require('./src/props'),
    range: $__require('./src/range'),
    reduce: $__require('./src/reduce'),
    reduceBy: $__require('./src/reduceBy'),
    reduceRight: $__require('./src/reduceRight'),
    reduceWhile: $__require('./src/reduceWhile'),
    reduced: $__require('./src/reduced'),
    reject: $__require('./src/reject'),
    remove: $__require('./src/remove'),
    repeat: $__require('./src/repeat'),
    replace: $__require('./src/replace'),
    reverse: $__require('./src/reverse'),
    scan: $__require('./src/scan'),
    sequence: $__require('./src/sequence'),
    set: $__require('./src/set'),
    slice: $__require('./src/slice'),
    sort: $__require('./src/sort'),
    sortBy: $__require('./src/sortBy'),
    sortWith: $__require('./src/sortWith'),
    split: $__require('./src/split'),
    splitAt: $__require('./src/splitAt'),
    splitEvery: $__require('./src/splitEvery'),
    splitWhen: $__require('./src/splitWhen'),
    subtract: $__require('./src/subtract'),
    sum: $__require('./src/sum'),
    symmetricDifference: $__require('./src/symmetricDifference'),
    symmetricDifferenceWith: $__require('./src/symmetricDifferenceWith'),
    tail: $__require('./src/tail'),
    take: $__require('./src/take'),
    takeLast: $__require('./src/takeLast'),
    takeLastWhile: $__require('./src/takeLastWhile'),
    takeWhile: $__require('./src/takeWhile'),
    tap: $__require('./src/tap'),
    test: $__require('./src/test'),
    times: $__require('./src/times'),
    toLower: $__require('./src/toLower'),
    toPairs: $__require('./src/toPairs'),
    toPairsIn: $__require('./src/toPairsIn'),
    toString: $__require('./src/toString'),
    toUpper: $__require('./src/toUpper'),
    transduce: $__require('./src/transduce'),
    transpose: $__require('./src/transpose'),
    traverse: $__require('./src/traverse'),
    trim: $__require('./src/trim'),
    tryCatch: $__require('./src/tryCatch'),
    type: $__require('./src/type'),
    unapply: $__require('./src/unapply'),
    unary: $__require('./src/unary'),
    uncurryN: $__require('./src/uncurryN'),
    unfold: $__require('./src/unfold'),
    union: $__require('./src/union'),
    unionWith: $__require('./src/unionWith'),
    uniq: $__require('./src/uniq'),
    uniqBy: $__require('./src/uniqBy'),
    uniqWith: $__require('./src/uniqWith'),
    unless: $__require('./src/unless'),
    unnest: $__require('./src/unnest'),
    until: $__require('./src/until'),
    update: $__require('./src/update'),
    useWith: $__require('./src/useWith'),
    values: $__require('./src/values'),
    valuesIn: $__require('./src/valuesIn'),
    view: $__require('./src/view'),
    when: $__require('./src/when'),
    where: $__require('./src/where'),
    whereEq: $__require('./src/whereEq'),
    without: $__require('./src/without'),
    xprod: $__require('./src/xprod'),
    zip: $__require('./src/zip'),
    zipObj: $__require('./src/zipObj'),
    zipWith: $__require('./src/zipWith')
  };
});
System.registerDynamic('npm:esutils@2.0.2/lib/ast.js', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */

    (function () {
        'use strict';

        function isExpression(node) {
            if (node == null) {
                return false;
            }
            switch (node.type) {
                case 'ArrayExpression':
                case 'AssignmentExpression':
                case 'BinaryExpression':
                case 'CallExpression':
                case 'ConditionalExpression':
                case 'FunctionExpression':
                case 'Identifier':
                case 'Literal':
                case 'LogicalExpression':
                case 'MemberExpression':
                case 'NewExpression':
                case 'ObjectExpression':
                case 'SequenceExpression':
                case 'ThisExpression':
                case 'UnaryExpression':
                case 'UpdateExpression':
                    return true;
            }
            return false;
        }

        function isIterationStatement(node) {
            if (node == null) {
                return false;
            }
            switch (node.type) {
                case 'DoWhileStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'WhileStatement':
                    return true;
            }
            return false;
        }

        function isStatement(node) {
            if (node == null) {
                return false;
            }
            switch (node.type) {
                case 'BlockStatement':
                case 'BreakStatement':
                case 'ContinueStatement':
                case 'DebuggerStatement':
                case 'DoWhileStatement':
                case 'EmptyStatement':
                case 'ExpressionStatement':
                case 'ForInStatement':
                case 'ForStatement':
                case 'IfStatement':
                case 'LabeledStatement':
                case 'ReturnStatement':
                case 'SwitchStatement':
                case 'ThrowStatement':
                case 'TryStatement':
                case 'VariableDeclaration':
                case 'WhileStatement':
                case 'WithStatement':
                    return true;
            }
            return false;
        }

        function isSourceElement(node) {
            return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
        }

        function trailingStatement(node) {
            switch (node.type) {
                case 'IfStatement':
                    if (node.alternate != null) {
                        return node.alternate;
                    }
                    return node.consequent;

                case 'LabeledStatement':
                case 'ForStatement':
                case 'ForInStatement':
                case 'WhileStatement':
                case 'WithStatement':
                    return node.body;
            }
            return null;
        }

        function isProblematicIfStatement(node) {
            var current;

            if (node.type !== 'IfStatement') {
                return false;
            }
            if (node.alternate == null) {
                return false;
            }
            current = node.consequent;
            do {
                if (current.type === 'IfStatement') {
                    if (current.alternate == null) {
                        return true;
                    }
                }
                current = trailingStatement(current);
            } while (current);

            return false;
        }

        module.exports = {
            isExpression: isExpression,
            isStatement: isStatement,
            isIterationStatement: isIterationStatement,
            isSourceElement: isSourceElement,
            isProblematicIfStatement: isProblematicIfStatement,

            trailingStatement: trailingStatement
        };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */
});
System.registerDynamic('npm:esutils@2.0.2/lib/code.js', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /*
      Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */

    (function () {
        'use strict';

        var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

        // See `tools/generate-identifier-regex.js`.
        ES5Regex = {
            // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
        };

        ES6Regex = {
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
            // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
        };

        function isDecimalDigit(ch) {
            return 0x30 <= ch && ch <= 0x39; // 0..9
        }

        function isHexDigit(ch) {
            return 0x30 <= ch && ch <= 0x39 || // 0..9
            0x61 <= ch && ch <= 0x66 || // a..f
            0x41 <= ch && ch <= 0x46; // A..F
        }

        function isOctalDigit(ch) {
            return ch >= 0x30 && ch <= 0x37; // 0..7
        }

        // 7.2 White Space

        NON_ASCII_WHITESPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

        function isWhiteSpace(ch) {
            return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
        }

        // 7.3 Line Terminators

        function isLineTerminator(ch) {
            return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
        }

        // 7.6 Identifier Names and Identifiers

        function fromCodePoint(cp) {
            if (cp <= 0xFFFF) {
                return String.fromCharCode(cp);
            }
            var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
            var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
            return cu1 + cu2;
        }

        IDENTIFIER_START = new Array(0x80);
        for (ch = 0; ch < 0x80; ++ch) {
            IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
            ch >= 0x41 && ch <= 0x5A || // A..Z
            ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
        }

        IDENTIFIER_PART = new Array(0x80);
        for (ch = 0; ch < 0x80; ++ch) {
            IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
            ch >= 0x41 && ch <= 0x5A || // A..Z
            ch >= 0x30 && ch <= 0x39 || // 0..9
            ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
        }

        function isIdentifierStartES5(ch) {
            return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }

        function isIdentifierPartES5(ch) {
            return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }

        function isIdentifierStartES6(ch) {
            return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }

        function isIdentifierPartES6(ch) {
            return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
        }

        module.exports = {
            isDecimalDigit: isDecimalDigit,
            isHexDigit: isHexDigit,
            isOctalDigit: isOctalDigit,
            isWhiteSpace: isWhiteSpace,
            isLineTerminator: isLineTerminator,
            isIdentifierStartES5: isIdentifierStartES5,
            isIdentifierPartES5: isIdentifierPartES5,
            isIdentifierStartES6: isIdentifierStartES6,
            isIdentifierPartES6: isIdentifierPartES6
        };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */
});
System.registerDynamic('npm:esutils@2.0.2/lib/keyword.js', ['./code'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */

    (function () {
        'use strict';

        var code = $__require('./code');

        function isStrictModeReservedWordES6(id) {
            switch (id) {
                case 'implements':
                case 'interface':
                case 'package':
                case 'private':
                case 'protected':
                case 'public':
                case 'static':
                case 'let':
                    return true;
                default:
                    return false;
            }
        }

        function isKeywordES5(id, strict) {
            // yield should not be treated as keyword under non-strict mode.
            if (!strict && id === 'yield') {
                return false;
            }
            return isKeywordES6(id, strict);
        }

        function isKeywordES6(id, strict) {
            if (strict && isStrictModeReservedWordES6(id)) {
                return true;
            }

            switch (id.length) {
                case 2:
                    return id === 'if' || id === 'in' || id === 'do';
                case 3:
                    return id === 'var' || id === 'for' || id === 'new' || id === 'try';
                case 4:
                    return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
                case 5:
                    return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
                case 6:
                    return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
                case 7:
                    return id === 'default' || id === 'finally' || id === 'extends';
                case 8:
                    return id === 'function' || id === 'continue' || id === 'debugger';
                case 10:
                    return id === 'instanceof';
                default:
                    return false;
            }
        }

        function isReservedWordES5(id, strict) {
            return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
        }

        function isReservedWordES6(id, strict) {
            return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
        }

        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }

        function isIdentifierNameES5(id) {
            var i, iz, ch;

            if (id.length === 0) {
                return false;
            }

            ch = id.charCodeAt(0);
            if (!code.isIdentifierStartES5(ch)) {
                return false;
            }

            for (i = 1, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (!code.isIdentifierPartES5(ch)) {
                    return false;
                }
            }
            return true;
        }

        function decodeUtf16(lead, trail) {
            return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
        }

        function isIdentifierNameES6(id) {
            var i, iz, ch, lowCh, check;

            if (id.length === 0) {
                return false;
            }

            check = code.isIdentifierStartES6;
            for (i = 0, iz = id.length; i < iz; ++i) {
                ch = id.charCodeAt(i);
                if (0xD800 <= ch && ch <= 0xDBFF) {
                    ++i;
                    if (i >= iz) {
                        return false;
                    }
                    lowCh = id.charCodeAt(i);
                    if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                        return false;
                    }
                    ch = decodeUtf16(ch, lowCh);
                }
                if (!check(ch)) {
                    return false;
                }
                check = code.isIdentifierPartES6;
            }
            return true;
        }

        function isIdentifierES5(id, strict) {
            return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
        }

        function isIdentifierES6(id, strict) {
            return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
        }

        module.exports = {
            isKeywordES5: isKeywordES5,
            isKeywordES6: isKeywordES6,
            isReservedWordES5: isReservedWordES5,
            isReservedWordES6: isReservedWordES6,
            isRestrictedWord: isRestrictedWord,
            isIdentifierNameES5: isIdentifierNameES5,
            isIdentifierNameES6: isIdentifierNameES6,
            isIdentifierES5: isIdentifierES5,
            isIdentifierES6: isIdentifierES6
        };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */
});
System.registerDynamic("npm:esutils@2.0.2.json", [], true, function() {
  return {
    "main": "lib/utils.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic('npm:esutils@2.0.2/lib/utils.js', ['./ast', './code', './keyword'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /*
    Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
  
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
  
      * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */

  (function () {
    'use strict';

    exports.ast = $__require('./ast');
    exports.code = $__require('./code');
    exports.keyword = $__require('./keyword');
  })();
  /* vim: set sw=4 ts=4 et tw=80 : */
});
System.registerDynamic("npm:shift-parser@5.0.2/dist/utils.js", ["esutils"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isDecimalDigit = exports.isLineTerminator = exports.isWhiteSpace = exports.isIdentifierPart = exports.isIdentifierStart = exports.isRestrictedWord = undefined;
  exports.isStrictModeReservedWord = isStrictModeReservedWord;
  exports.getHexValue = getHexValue;

  var _esutils = $__require("esutils");

  var isReservedWordES6 = _esutils.keyword.isReservedWordES6; /**
                                                               * Copyright 2014 Shape Security, Inc.
                                                               *
                                                               * Licensed under the Apache License, Version 2.0 (the "License")
                                                               * you may not use this file except in compliance with the License.
                                                               * You may obtain a copy of the License at
                                                               *
                                                               *     http://www.apache.org/licenses/LICENSE-2.0
                                                               *
                                                               * Unless required by applicable law or agreed to in writing, software
                                                               * distributed under the License is distributed on an "AS IS" BASIS,
                                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                               * See the License for the specific language governing permissions and
                                                               * limitations under the License.
                                                               */

  var isRestrictedWord = _esutils.keyword.isRestrictedWord;
  var isIdentifierStartES6 = _esutils.code.isIdentifierStartES6;
  var isIdentifierPartES6 = _esutils.code.isIdentifierPartES6;
  var isWhiteSpace = _esutils.code.isWhiteSpace;
  var isLineTerminator = _esutils.code.isLineTerminator;
  var isDecimalDigit = _esutils.code.isDecimalDigit;
  exports.isRestrictedWord = isRestrictedWord;
  exports.isIdentifierStart = isIdentifierStartES6;
  exports.isIdentifierPart = isIdentifierPartES6;
  exports.isWhiteSpace = isWhiteSpace;
  exports.isLineTerminator = isLineTerminator;
  exports.isDecimalDigit = isDecimalDigit;
  function isStrictModeReservedWord(id) {
    return isReservedWordES6(id, true);
  }

  function getHexValue(rune) {
    if ("0" <= rune && rune <= "9") {
      return rune.charCodeAt(0) - 48;
    }
    if ("a" <= rune && rune <= "f") {
      return rune.charCodeAt(0) - 87;
    }
    if ("A" <= rune && rune <= "F") {
      return rune.charCodeAt(0) - 55;
    }
    return -1;
  }
});
System.registerDynamic("npm:shift-parser@5.0.2/dist/errors.js", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Copyright 2014 Shape Security, Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License")
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var ErrorMessages = exports.ErrorMessages = {
    UNEXPECTED_TOKEN: "Unexpected token {0}",
    UNEXPECTED_ILLEGAL_TOKEN: "Unexpected {0}",
    UNEXPECTED_NUMBER: "Unexpected number",
    UNEXPECTED_STRING: "Unexpected string",
    UNEXPECTED_IDENTIFIER: "Unexpected identifier",
    UNEXPECTED_RESERVED_WORD: "Unexpected reserved word",
    UNEXPECTED_TEMPLATE: "Unexpected template",
    UNEXPECTED_EOS: "Unexpected end of input",
    UNEXPECTED_LINE_TERMINATOR: "Unexpected line terminator",
    UNEXPECTED_COMMA_AFTER_REST: "Unexpected comma after rest",
    NEWLINE_AFTER_THROW: "Illegal newline after throw",
    UNTERMINATED_REGEXP: "Invalid regular expression: missing /",
    INVALID_REGEXP_FLAGS: "Invalid regular expression flags",
    INVALID_LHS_IN_ASSIGNMENT: "Invalid left-hand side in assignment",
    INVALID_LHS_IN_BINDING: "Invalid left-hand side in binding", // todo collapse messages?
    INVALID_LHS_IN_FOR_IN: "Invalid left-hand side in for-in",
    INVALID_LHS_IN_FOR_OF: "Invalid left-hand side in for-of",
    INVALID_UPDATE_OPERAND: "Increment/decrement target must be an identifier or member expression",
    MULTIPLE_DEFAULTS_IN_SWITCH: "More than one default clause in switch statement",
    NO_CATCH_OR_FINALLY: "Missing catch or finally after try",
    ILLEGAL_RETURN: "Illegal return statement",
    ILLEGAL_ARROW_FUNCTION_PARAMS: "Illegal arrow function parameter list",
    INVALID_VAR_INIT_FOR_IN: "Invalid variable declaration in for-in statement",
    INVALID_VAR_INIT_FOR_OF: "Invalid variable declaration in for-of statement",
    ILLEGAL_PROPERTY: "Illegal property initializer"
  };
});
System.registerDynamic("npm:shift-parser@5.0.2.json", [], true, function() {
  return {
    "main": "dist/index.js",
    "format": "cjs",
    "meta": {
      "*.json": {
        "format": "json"
      }
    },
    "map": {
      "./dist": "./dist/index.js"
    }
  };
});

System.registerDynamic("npm:shift-parser@5.0.2/dist/tokenizer.js", ["./utils", "./errors"], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.JsError = exports.TokenType = exports.TokenClass = undefined;

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _utils = $__require("./utils");

  var _errors = $__require("./errors");

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  } /**
     * Copyright 2014 Shape Security, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License")
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

  var TokenClass = exports.TokenClass = {
    Eof: { name: "<End>" },
    Ident: { name: "Identifier", isIdentifierName: true },
    Keyword: { name: "Keyword", isIdentifierName: true },
    NumericLiteral: { name: "Numeric" },
    TemplateElement: { name: "Template" },
    Punctuator: { name: "Punctuator" },
    StringLiteral: { name: "String" },
    RegularExpression: { name: "RegularExpression" },
    Illegal: { name: "Illegal" }
  };

  var TokenType = exports.TokenType = {
    EOS: { klass: TokenClass.Eof, name: "EOS" },
    LPAREN: { klass: TokenClass.Punctuator, name: "(" },
    RPAREN: { klass: TokenClass.Punctuator, name: ")" },
    LBRACK: { klass: TokenClass.Punctuator, name: "[" },
    RBRACK: { klass: TokenClass.Punctuator, name: "]" },
    LBRACE: { klass: TokenClass.Punctuator, name: "{" },
    RBRACE: { klass: TokenClass.Punctuator, name: "}" },
    COLON: { klass: TokenClass.Punctuator, name: ":" },
    SEMICOLON: { klass: TokenClass.Punctuator, name: ";" },
    PERIOD: { klass: TokenClass.Punctuator, name: "." },
    ELLIPSIS: { klass: TokenClass.Punctuator, name: "..." },
    ARROW: { klass: TokenClass.Punctuator, name: "=>" },
    CONDITIONAL: { klass: TokenClass.Punctuator, name: "?" },
    INC: { klass: TokenClass.Punctuator, name: "++" },
    DEC: { klass: TokenClass.Punctuator, name: "--" },
    ASSIGN: { klass: TokenClass.Punctuator, name: "=" },
    ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: "|=" },
    ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: "^=" },
    ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: "&=" },
    ASSIGN_SHL: { klass: TokenClass.Punctuator, name: "<<=" },
    ASSIGN_SHR: { klass: TokenClass.Punctuator, name: ">>=" },
    ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>=" },
    ASSIGN_ADD: { klass: TokenClass.Punctuator, name: "+=" },
    ASSIGN_SUB: { klass: TokenClass.Punctuator, name: "-=" },
    ASSIGN_MUL: { klass: TokenClass.Punctuator, name: "*=" },
    ASSIGN_DIV: { klass: TokenClass.Punctuator, name: "/=" },
    ASSIGN_MOD: { klass: TokenClass.Punctuator, name: "%=" },
    ASSIGN_EXP: { klass: TokenClass.Punctuator, name: "**=" },
    COMMA: { klass: TokenClass.Punctuator, name: "," },
    OR: { klass: TokenClass.Punctuator, name: "||" },
    AND: { klass: TokenClass.Punctuator, name: "&&" },
    BIT_OR: { klass: TokenClass.Punctuator, name: "|" },
    BIT_XOR: { klass: TokenClass.Punctuator, name: "^" },
    BIT_AND: { klass: TokenClass.Punctuator, name: "&" },
    SHL: { klass: TokenClass.Punctuator, name: "<<" },
    SHR: { klass: TokenClass.Punctuator, name: ">>" },
    SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>" },
    ADD: { klass: TokenClass.Punctuator, name: "+" },
    SUB: { klass: TokenClass.Punctuator, name: "-" },
    MUL: { klass: TokenClass.Punctuator, name: "*" },
    DIV: { klass: TokenClass.Punctuator, name: "/" },
    MOD: { klass: TokenClass.Punctuator, name: "%" },
    EXP: { klass: TokenClass.Punctuator, name: "**" },
    EQ: { klass: TokenClass.Punctuator, name: "==" },
    NE: { klass: TokenClass.Punctuator, name: "!=" },
    EQ_STRICT: { klass: TokenClass.Punctuator, name: "===" },
    NE_STRICT: { klass: TokenClass.Punctuator, name: "!==" },
    LT: { klass: TokenClass.Punctuator, name: "<" },
    GT: { klass: TokenClass.Punctuator, name: ">" },
    LTE: { klass: TokenClass.Punctuator, name: "<=" },
    GTE: { klass: TokenClass.Punctuator, name: ">=" },
    INSTANCEOF: { klass: TokenClass.Keyword, name: "instanceof" },
    IN: { klass: TokenClass.Keyword, name: "in" },
    NOT: { klass: TokenClass.Punctuator, name: "!" },
    BIT_NOT: { klass: TokenClass.Punctuator, name: "~" },
    AWAIT: { klass: TokenClass.Keyword, name: "await" },
    DELETE: { klass: TokenClass.Keyword, name: "delete" },
    TYPEOF: { klass: TokenClass.Keyword, name: "typeof" },
    VOID: { klass: TokenClass.Keyword, name: "void" },
    BREAK: { klass: TokenClass.Keyword, name: "break" },
    CASE: { klass: TokenClass.Keyword, name: "case" },
    CATCH: { klass: TokenClass.Keyword, name: "catch" },
    CLASS: { klass: TokenClass.Keyword, name: "class" },
    CONTINUE: { klass: TokenClass.Keyword, name: "continue" },
    DEBUGGER: { klass: TokenClass.Keyword, name: "debugger" },
    DEFAULT: { klass: TokenClass.Keyword, name: "default" },
    DO: { klass: TokenClass.Keyword, name: "do" },
    ELSE: { klass: TokenClass.Keyword, name: "else" },
    EXPORT: { klass: TokenClass.Keyword, name: "export" },
    EXTENDS: { klass: TokenClass.Keyword, name: "extends" },
    FINALLY: { klass: TokenClass.Keyword, name: "finally" },
    FOR: { klass: TokenClass.Keyword, name: "for" },
    FUNCTION: { klass: TokenClass.Keyword, name: "function" },
    IF: { klass: TokenClass.Keyword, name: "if" },
    IMPORT: { klass: TokenClass.Keyword, name: "import" },
    LET: { klass: TokenClass.Keyword, name: "let" },
    NEW: { klass: TokenClass.Keyword, name: "new" },
    RETURN: { klass: TokenClass.Keyword, name: "return" },
    SUPER: { klass: TokenClass.Keyword, name: "super" },
    SWITCH: { klass: TokenClass.Keyword, name: "switch" },
    THIS: { klass: TokenClass.Keyword, name: "this" },
    THROW: { klass: TokenClass.Keyword, name: "throw" },
    TRY: { klass: TokenClass.Keyword, name: "try" },
    VAR: { klass: TokenClass.Keyword, name: "var" },
    WHILE: { klass: TokenClass.Keyword, name: "while" },
    WITH: { klass: TokenClass.Keyword, name: "with" },
    NULL: { klass: TokenClass.Keyword, name: "null" },
    TRUE: { klass: TokenClass.Keyword, name: "true" },
    FALSE: { klass: TokenClass.Keyword, name: "false" },
    YIELD: { klass: TokenClass.Keyword, name: "yield" },
    NUMBER: { klass: TokenClass.NumericLiteral, name: "" },
    STRING: { klass: TokenClass.StringLiteral, name: "" },
    REGEXP: { klass: TokenClass.RegularExpression, name: "" },
    IDENTIFIER: { klass: TokenClass.Ident, name: "" },
    CONST: { klass: TokenClass.Keyword, name: "const" },
    TEMPLATE: { klass: TokenClass.TemplateElement, name: "" },
    ILLEGAL: { klass: TokenClass.Illegal, name: "" }
  };

  var TT = TokenType;
  var I = TT.ILLEGAL;
  var F = false;
  var T = true;

  var ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];

  var PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];

  var JsError = exports.JsError = function (_Error) {
    _inherits(JsError, _Error);

    function JsError(index, line, column, msg) {
      _classCallCheck(this, JsError);

      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(JsError).call(this, msg));

      _this.index = index;
      // Safari defines these properties as non-writable and non-configurable on Error objects
      try {
        _this.line = line;
        _this.column = column;
      } catch (e) {}
      // define these as well so Safari still has access to this info
      _this.parseErrorLine = line;
      _this.parseErrorColumn = column;
      _this.description = msg;
      _this.message = "[" + line + ":" + column + "]: " + msg;
      return _this;
    }

    return JsError;
  }(Error);

  function fromCodePoint(cp) {
    if (cp <= 0xFFFF) return String.fromCharCode(cp);
    var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
    var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
    return cu1 + cu2;
  }

  function decodeUtf16(lead, trail) {
    return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  }

  var Tokenizer = function () {
    function Tokenizer(source) {
      _classCallCheck(this, Tokenizer);

      this.source = source;
      this.index = 0;
      this.line = 0;
      this.lineStart = 0;
      this.startIndex = 0;
      this.startLine = 0;
      this.startLineStart = 0;
      this.lastIndex = 0;
      this.lastLine = 0;
      this.lastLineStart = 0;
      this.hasLineTerminatorBeforeNext = false;
      this.tokenIndex = 0;
    }

    _createClass(Tokenizer, [{
      key: "saveLexerState",
      value: function saveLexerState() {
        return {
          source: this.source,
          index: this.index,
          line: this.line,
          lineStart: this.lineStart,
          startIndex: this.startIndex,
          startLine: this.startLine,
          startLineStart: this.startLineStart,
          lastIndex: this.lastIndex,
          lastLine: this.lastLine,
          lastLineStart: this.lastLineStart,
          lookahead: this.lookahead,
          hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,
          tokenIndex: this.tokenIndex
        };
      }
    }, {
      key: "restoreLexerState",
      value: function restoreLexerState(state) {
        this.source = state.source;
        this.index = state.index;
        this.line = state.line;
        this.lineStart = state.lineStart;
        this.startIndex = state.startIndex;
        this.startLine = state.startLine;
        this.startLineStart = state.startLineStart;
        this.lastIndex = state.lastIndex;
        this.lastLine = state.lastLine;
        this.lastLineStart = state.lastLineStart;
        this.lookahead = state.lookahead;
        this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;
        this.tokenIndex = state.tokenIndex;
      }
    }, {
      key: "createILLEGAL",
      value: function createILLEGAL() {
        this.startIndex = this.index;
        this.startLine = this.line;
        this.startLineStart = this.lineStart;
        return this.index < this.source.length ? this.createError(_errors.ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index)) : this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
      }
    }, {
      key: "createUnexpected",
      value: function createUnexpected(token) {
        switch (token.type.klass) {
          case TokenClass.Eof:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_EOS);
          case TokenClass.Ident:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_IDENTIFIER);
          case TokenClass.Keyword:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);
          case TokenClass.NumericLiteral:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_NUMBER);
          case TokenClass.TemplateElement:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_TEMPLATE);
          case TokenClass.Punctuator:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
          case TokenClass.StringLiteral:
            return this.createError(_errors.ErrorMessages.UNEXPECTED_STRING);
          // the other token classes are RegularExpression and Illegal, but they cannot reach here
        }
      }
    }, {
      key: "createError",
      value: function createError(message) {
        var _arguments = arguments;

        /* istanbul ignore next */
        var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
          return JSON.stringify(_arguments[+n + 1]);
        });
        return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);
      }
    }, {
      key: "createErrorWithLocation",
      value: function createErrorWithLocation(location, message) {
        var _arguments2 = arguments;

        /* istanbul ignore next */
        var msg = message.replace(/\{(\d+)\}/g, function (_, n) {
          return JSON.stringify(_arguments2[+n + 2]);
        });
        if (location.slice && location.slice.startLocation) {
          location = location.slice.startLocation;
        }
        return new JsError(location.offset, location.line, location.column + 1, msg);
      }
    }, {
      key: "getKeyword",
      value: function getKeyword(id) {
        if (id.length === 1 || id.length > 10) {
          return TokenType.IDENTIFIER;
        }

        /* istanbul ignore next */
        switch (id.length) {
          case 2:
            switch (id.charAt(0)) {
              case "i":
                switch (id.charAt(1)) {
                  case "f":
                    return TokenType.IF;
                  case "n":
                    return TokenType.IN;
                  default:
                    break;
                }
                break;
              case "d":
                if (id.charAt(1) === "o") {
                  return TokenType.DO;
                }
                break;
            }
            break;
          case 3:
            switch (id.charAt(0)) {
              case "v":
                if (Tokenizer.cse2(id, "a", "r")) {
                  return TokenType.VAR;
                }
                break;
              case "f":
                if (Tokenizer.cse2(id, "o", "r")) {
                  return TokenType.FOR;
                }
                break;
              case "n":
                if (Tokenizer.cse2(id, "e", "w")) {
                  return TokenType.NEW;
                }
                break;
              case "t":
                if (Tokenizer.cse2(id, "r", "y")) {
                  return TokenType.TRY;
                }
                break;
              case "l":
                if (Tokenizer.cse2(id, "e", "t")) {
                  return TokenType.LET;
                }
                break;
            }
            break;
          case 4:
            switch (id.charAt(0)) {
              case "t":
                if (Tokenizer.cse3(id, "h", "i", "s")) {
                  return TokenType.THIS;
                } else if (Tokenizer.cse3(id, "r", "u", "e")) {
                  return TokenType.TRUE;
                }
                break;
              case "n":
                if (Tokenizer.cse3(id, "u", "l", "l")) {
                  return TokenType.NULL;
                }
                break;
              case "e":
                if (Tokenizer.cse3(id, "l", "s", "e")) {
                  return TokenType.ELSE;
                }
                break;
              case "c":
                if (Tokenizer.cse3(id, "a", "s", "e")) {
                  return TokenType.CASE;
                }
                break;
              case "v":
                if (Tokenizer.cse3(id, "o", "i", "d")) {
                  return TokenType.VOID;
                }
                break;
              case "w":
                if (Tokenizer.cse3(id, "i", "t", "h")) {
                  return TokenType.WITH;
                }
                break;
            }
            break;
          case 5:
            switch (id.charAt(0)) {
              case "a":
                if (this.moduleIsTheGoalSymbol && Tokenizer.cse4(id, "w", "a", "i", "t")) {
                  return TokenType.AWAIT;
                }
                break;
              case "w":
                if (Tokenizer.cse4(id, "h", "i", "l", "e")) {
                  return TokenType.WHILE;
                }
                break;
              case "b":
                if (Tokenizer.cse4(id, "r", "e", "a", "k")) {
                  return TokenType.BREAK;
                }
                break;
              case "f":
                if (Tokenizer.cse4(id, "a", "l", "s", "e")) {
                  return TokenType.FALSE;
                }
                break;
              case "c":
                if (Tokenizer.cse4(id, "a", "t", "c", "h")) {
                  return TokenType.CATCH;
                } else if (Tokenizer.cse4(id, "o", "n", "s", "t")) {
                  return TokenType.CONST;
                } else if (Tokenizer.cse4(id, "l", "a", "s", "s")) {
                  return TokenType.CLASS;
                }
                break;
              case "t":
                if (Tokenizer.cse4(id, "h", "r", "o", "w")) {
                  return TokenType.THROW;
                }
                break;
              case "y":
                if (Tokenizer.cse4(id, "i", "e", "l", "d")) {
                  return TokenType.YIELD;
                }
                break;
              case "s":
                if (Tokenizer.cse4(id, "u", "p", "e", "r")) {
                  return TokenType.SUPER;
                }
                break;
            }
            break;
          case 6:
            switch (id.charAt(0)) {
              case "r":
                if (Tokenizer.cse5(id, "e", "t", "u", "r", "n")) {
                  return TokenType.RETURN;
                }
                break;
              case "t":
                if (Tokenizer.cse5(id, "y", "p", "e", "o", "f")) {
                  return TokenType.TYPEOF;
                }
                break;
              case "d":
                if (Tokenizer.cse5(id, "e", "l", "e", "t", "e")) {
                  return TokenType.DELETE;
                }
                break;
              case "s":
                if (Tokenizer.cse5(id, "w", "i", "t", "c", "h")) {
                  return TokenType.SWITCH;
                }
                break;
              case "e":
                if (Tokenizer.cse5(id, "x", "p", "o", "r", "t")) {
                  return TokenType.EXPORT;
                }
                break;
              case "i":
                if (Tokenizer.cse5(id, "m", "p", "o", "r", "t")) {
                  return TokenType.IMPORT;
                }
                break;
            }
            break;
          case 7:
            switch (id.charAt(0)) {
              case "d":
                if (Tokenizer.cse6(id, "e", "f", "a", "u", "l", "t")) {
                  return TokenType.DEFAULT;
                }
                break;
              case "f":
                if (Tokenizer.cse6(id, "i", "n", "a", "l", "l", "y")) {
                  return TokenType.FINALLY;
                }
                break;
              case "e":
                if (Tokenizer.cse6(id, "x", "t", "e", "n", "d", "s")) {
                  return TokenType.EXTENDS;
                }
                break;
            }
            break;
          case 8:
            switch (id.charAt(0)) {
              case "f":
                if (Tokenizer.cse7(id, "u", "n", "c", "t", "i", "o", "n")) {
                  return TokenType.FUNCTION;
                }
                break;
              case "c":
                if (Tokenizer.cse7(id, "o", "n", "t", "i", "n", "u", "e")) {
                  return TokenType.CONTINUE;
                }
                break;
              case "d":
                if (Tokenizer.cse7(id, "e", "b", "u", "g", "g", "e", "r")) {
                  return TokenType.DEBUGGER;
                }
                break;
            }
            break;
          case 10:
            if (id === "instanceof") {
              return TokenType.INSTANCEOF;
            }
            break;
        }
        return TokenType.IDENTIFIER;
      }
    }, {
      key: "skipSingleLineComment",
      value: function skipSingleLineComment(offset) {
        this.index += offset;
        while (this.index < this.source.length) {
          /**
           * @type {Number}
           */
          var chCode = this.source.charCodeAt(this.index);
          this.index++;
          if ((0, _utils.isLineTerminator)(chCode)) {
            this.hasLineTerminatorBeforeNext = true;
            if (chCode === 0xD /* "\r" */ && this.source.charCodeAt(this.index) === 0xA /*"\n" */) {
                this.index++;
              }
            this.lineStart = this.index;
            this.line++;
            return;
          }
        }
      }
    }, {
      key: "skipMultiLineComment",
      value: function skipMultiLineComment() {
        this.index += 2;
        var length = this.source.length;
        var isLineStart = false;
        while (this.index < length) {
          var chCode = this.source.charCodeAt(this.index);
          if (chCode < 0x80) {
            switch (chCode) {
              case 42:
                // "*"
                // Block comment ends with "*/".
                if (this.source.charAt(this.index + 1) === "/") {
                  this.index = this.index + 2;
                  return isLineStart;
                }
                this.index++;
                break;
              case 10:
                // "\n"
                isLineStart = true;
                this.hasLineTerminatorBeforeNext = true;
                this.index++;
                this.lineStart = this.index;
                this.line++;
                break;
              case 13:
                // "\r":
                isLineStart = true;
                this.hasLineTerminatorBeforeNext = true;
                if (this.source.charAt(this.index + 1) === "\n") {
                  this.index++;
                }
                this.index++;
                this.lineStart = this.index;
                this.line++;
                break;
              default:
                this.index++;
            }
          } else if (chCode === 0x2028 || chCode === 0x2029) {
            isLineStart = true;
            this.hasLineTerminatorBeforeNext = true;
            this.index++;
            this.lineStart = this.index;
            this.line++;
          } else {
            this.index++;
          }
        }
        throw this.createILLEGAL();
      }
    }, {
      key: "skipComment",
      value: function skipComment() {
        this.hasLineTerminatorBeforeNext = false;

        var isLineStart = this.index === 0;
        var length = this.source.length;

        while (this.index < length) {
          var chCode = this.source.charCodeAt(this.index);
          if ((0, _utils.isWhiteSpace)(chCode)) {
            this.index++;
          } else if ((0, _utils.isLineTerminator)(chCode)) {
            this.hasLineTerminatorBeforeNext = true;
            this.index++;
            if (chCode === 13 /* "\r" */ && this.source.charAt(this.index) === "\n") {
              this.index++;
            }
            this.lineStart = this.index;
            this.line++;
            isLineStart = true;
          } else if (chCode === 47 /* "/" */) {
              if (this.index + 1 >= length) {
                break;
              }
              chCode = this.source.charCodeAt(this.index + 1);
              if (chCode === 47 /* "/" */) {
                  this.skipSingleLineComment(2);
                  isLineStart = true;
                } else if (chCode === 42 /* "*" */) {
                  isLineStart = this.skipMultiLineComment() || isLineStart;
                } else {
                break;
              }
            } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* "-" */) {
              if (this.index + 2 >= length) {
                break;
              }
              // U+003E is ">"
              if (this.source.charAt(this.index + 1) === "-" && this.source.charAt(this.index + 2) === ">") {
                // "-->" is a single-line comment
                this.skipSingleLineComment(3);
              } else {
                break;
              }
            } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* "<" */) {
              if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                this.skipSingleLineComment(4);
              } else {
                break;
              }
            } else {
            break;
          }
        }
      }
    }, {
      key: "scanHexEscape2",
      value: function scanHexEscape2() {
        if (this.index + 2 > this.source.length) {
          return -1;
        }
        var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
        if (r1 === -1) {
          return -1;
        }
        var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
        if (r2 === -1) {
          return -1;
        }
        this.index += 2;
        return r1 << 4 | r2;
      }
    }, {
      key: "scanUnicode",
      value: function scanUnicode() {
        if (this.source.charAt(this.index) === "{") {
          //\u{HexDigits}
          var i = this.index + 1;
          var hexDigits = 0,
              ch = void 0;
          while (i < this.source.length) {
            ch = this.source.charAt(i);
            var hex = (0, _utils.getHexValue)(ch);
            if (hex === -1) {
              break;
            }
            hexDigits = hexDigits << 4 | hex;
            if (hexDigits > 0x10FFFF) {
              throw this.createILLEGAL();
            }
            i++;
          }
          if (ch !== "}") {
            throw this.createILLEGAL();
          }
          if (i === this.index + 1) {
            ++this.index; // This is so that the error is 'Unexpected "}"' instead of 'Unexpected "{"'.
            throw this.createILLEGAL();
          }
          this.index = i + 1;
          return hexDigits;
        } else {
          //\uHex4Digits
          if (this.index + 4 > this.source.length) {
            return -1;
          }
          var r1 = (0, _utils.getHexValue)(this.source.charAt(this.index));
          if (r1 === -1) {
            return -1;
          }
          var r2 = (0, _utils.getHexValue)(this.source.charAt(this.index + 1));
          if (r2 === -1) {
            return -1;
          }
          var r3 = (0, _utils.getHexValue)(this.source.charAt(this.index + 2));
          if (r3 === -1) {
            return -1;
          }
          var r4 = (0, _utils.getHexValue)(this.source.charAt(this.index + 3));
          if (r4 === -1) {
            return -1;
          }
          this.index += 4;
          return r1 << 12 | r2 << 8 | r3 << 4 | r4;
        }
      }
    }, {
      key: "getEscapedIdentifier",
      value: function getEscapedIdentifier() {
        var id = "";
        var check = _utils.isIdentifierStart;

        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          var code = ch.charCodeAt(0);
          var start = this.index;
          ++this.index;
          if (ch === "\\") {
            if (this.index >= this.source.length) {
              throw this.createILLEGAL();
            }
            if (this.source.charAt(this.index) !== "u") {
              throw this.createILLEGAL();
            }
            ++this.index;
            code = this.scanUnicode();
            if (code < 0) {
              throw this.createILLEGAL();
            }
            ch = fromCodePoint(code);
          } else if (0xD800 <= code && code <= 0xDBFF) {
            if (this.index >= this.source.length) {
              throw this.createILLEGAL();
            }
            var lowSurrogateCode = this.source.charCodeAt(this.index);
            ++this.index;
            if (!(0xDC00 <= lowSurrogateCode && lowSurrogateCode <= 0xDFFF)) {
              throw this.createILLEGAL();
            }
            code = decodeUtf16(code, lowSurrogateCode);
            ch = fromCodePoint(code);
          }
          if (!check(code)) {
            if (id.length < 1) {
              throw this.createILLEGAL();
            }
            this.index = start;
            return id;
          }
          check = _utils.isIdentifierPart;
          id += ch;
        }
        return id;
      }
    }, {
      key: "getIdentifier",
      value: function getIdentifier() {
        var start = this.index;
        var l = this.source.length;
        var i = this.index;
        var check = _utils.isIdentifierStart;
        while (i < l) {
          var ch = this.source.charAt(i);
          var code = ch.charCodeAt(0);
          if (ch === "\\" || 0xD800 <= code && code <= 0xDBFF) {
            // Go back and try the hard one.
            this.index = start;
            return this.getEscapedIdentifier();
          }
          if (!check(code)) {
            this.index = i;
            return this.source.slice(start, i);
          }
          ++i;
          check = _utils.isIdentifierPart;
        }
        this.index = i;
        return this.source.slice(start, i);
      }
    }, {
      key: "scanIdentifier",
      value: function scanIdentifier() {
        var startLocation = this.getLocation();
        var start = this.index;

        // Backslash (U+005C) starts an escaped character.
        var id = this.source.charAt(this.index) === "\\" ? this.getEscapedIdentifier() : this.getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        var slice = this.getSlice(start, startLocation);
        slice.text = id;

        return { type: this.getKeyword(id), value: id, slice: slice };
      }
    }, {
      key: "getLocation",
      value: function getLocation() {
        return {
          line: this.startLine + 1,
          column: this.startIndex - this.startLineStart,
          offset: this.startIndex
        };
      }
    }, {
      key: "getSlice",
      value: function getSlice(start, startLocation) {
        return { text: this.source.slice(start, this.index), start: start, startLocation: startLocation, end: this.index };
      }
    }, {
      key: "scanPunctuatorHelper",
      value: function scanPunctuatorHelper() {
        var ch1 = this.source.charAt(this.index);

        switch (ch1) {
          // Check for most common single-character punctuators.
          case ".":
            var ch2 = this.source.charAt(this.index + 1);
            if (ch2 !== ".") return TokenType.PERIOD;
            var ch3 = this.source.charAt(this.index + 2);
            if (ch3 !== ".") return TokenType.PERIOD;
            return TokenType.ELLIPSIS;
          case "(":
            return TokenType.LPAREN;
          case ")":
          case ";":
          case ",":
            return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
          case "{":
            return TokenType.LBRACE;
          case "}":
          case "[":
          case "]":
          case ":":
          case "?":
          case "~":
            return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
          default:
            // "=" (U+003D) marks an assignment or comparison operator.
            if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === "=") {
              switch (ch1) {
                case "=":
                  if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
                    return TokenType.EQ_STRICT;
                  }
                  return TokenType.EQ;
                case "!":
                  if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
                    return TokenType.NE_STRICT;
                  }
                  return TokenType.NE;
                case "|":
                  return TokenType.ASSIGN_BIT_OR;
                case "+":
                  return TokenType.ASSIGN_ADD;
                case "-":
                  return TokenType.ASSIGN_SUB;
                case "*":
                  return TokenType.ASSIGN_MUL;
                case "<":
                  return TokenType.LTE;
                case ">":
                  return TokenType.GTE;
                case "/":
                  return TokenType.ASSIGN_DIV;
                case "%":
                  return TokenType.ASSIGN_MOD;
                case "^":
                  return TokenType.ASSIGN_BIT_XOR;
                case "&":
                  return TokenType.ASSIGN_BIT_AND;
                // istanbul ignore next
                default:
                  break; //failed
              }
            }
        }

        if (this.index + 1 < this.source.length) {
          var _ch = this.source.charAt(this.index + 1);
          if (ch1 === _ch) {
            if (this.index + 2 < this.source.length) {
              var _ch2 = this.source.charAt(this.index + 2);
              if (ch1 === ">" && _ch2 === ">") {
                // 4-character punctuator: >>>=
                if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === "=") {
                  return TokenType.ASSIGN_SHR_UNSIGNED;
                }
                return TokenType.SHR_UNSIGNED;
              }

              if (ch1 === "<" && _ch2 === "=") {
                return TokenType.ASSIGN_SHL;
              }

              if (ch1 === ">" && _ch2 === "=") {
                return TokenType.ASSIGN_SHR;
              }

              if (ch1 === "*" && _ch2 === "=") {
                return TokenType.ASSIGN_EXP;
              }
            }
            // Other 2-character punctuators: ++ -- << >> && ||
            switch (ch1) {
              case "*":
                return TokenType.EXP;
              case "+":
                return TokenType.INC;
              case "-":
                return TokenType.DEC;
              case "<":
                return TokenType.SHL;
              case ">":
                return TokenType.SHR;
              case "&":
                return TokenType.AND;
              case "|":
                return TokenType.OR;
              // istanbul ignore next
              default:
                break; //failed
            }
          } else if (ch1 === "=" && _ch === ">") {
            return TokenType.ARROW;
          }
        }

        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
      }

      // 7.7 Punctuators

    }, {
      key: "scanPunctuator",
      value: function scanPunctuator() {
        var startLocation = this.getLocation();
        var start = this.index;
        var subType = this.scanPunctuatorHelper();
        this.index += subType.name.length;
        return { type: subType, value: subType.name, slice: this.getSlice(start, startLocation) };
      }
    }, {
      key: "scanHexLiteral",
      value: function scanHexLiteral(start, startLocation) {
        var i = this.index;
        while (i < this.source.length) {
          var ch = this.source.charAt(i);
          var hex = (0, _utils.getHexValue)(ch);
          if (hex === -1) {
            break;
          }
          i++;
        }

        if (this.index === i) {
          throw this.createILLEGAL();
        }

        if (i < this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(i))) {
          throw this.createILLEGAL();
        }

        this.index = i;

        var slice = this.getSlice(start, startLocation);
        return { type: TokenType.NUMBER, value: parseInt(slice.text.substr(2), 16), slice: slice };
      }
    }, {
      key: "scanBinaryLiteral",
      value: function scanBinaryLiteral(start, startLocation) {
        var offset = this.index - start;

        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          if (ch !== "0" && ch !== "1") {
            break;
          }
          this.index++;
        }

        if (this.index - start <= offset) {
          throw this.createILLEGAL();
        }

        if (this.index < this.source.length && ((0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index)) || (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index)))) {
          throw this.createILLEGAL();
        }

        return {
          type: TokenType.NUMBER,
          value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),
          slice: this.getSlice(start, startLocation),
          octal: false,
          noctal: false
        };
      }
    }, {
      key: "scanOctalLiteral",
      value: function scanOctalLiteral(start, startLocation) {
        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          if ("0" <= ch && ch <= "7") {
            this.index++;
          } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
            throw this.createILLEGAL();
          } else {
            break;
          }
        }

        if (this.index - start === 2) {
          throw this.createILLEGAL();
        }

        return {
          type: TokenType.NUMBER,
          value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),
          slice: this.getSlice(start, startLocation),
          octal: false,
          noctal: false
        };
      }
    }, {
      key: "scanLegacyOctalLiteral",
      value: function scanLegacyOctalLiteral(start, startLocation) {
        var isOctal = true;

        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          if ("0" <= ch && ch <= "7") {
            this.index++;
          } else if (ch === "8" || ch === "9") {
            isOctal = false;
            this.index++;
          } else if ((0, _utils.isIdentifierPart)(ch.charCodeAt(0))) {
            throw this.createILLEGAL();
          } else {
            break;
          }
        }

        var slice = this.getSlice(start, startLocation);
        if (!isOctal) {
          this.eatDecimalLiteralSuffix();
          return {
            type: TokenType.NUMBER,
            slice: slice,
            value: +slice.text,
            octal: true,
            noctal: !isOctal
          };
        }

        return {
          type: TokenType.NUMBER,
          slice: slice,
          value: parseInt(slice.text.substr(1), 8),
          octal: true,
          noctal: !isOctal
        };
      }
    }, {
      key: "scanNumericLiteral",
      value: function scanNumericLiteral() {
        var ch = this.source.charAt(this.index);
        // assert(ch === "." || "0" <= ch && ch <= "9")
        var startLocation = this.getLocation();
        var start = this.index;

        if (ch === "0") {
          this.index++;
          if (this.index < this.source.length) {
            ch = this.source.charAt(this.index);
            if (ch === "x" || ch === "X") {
              this.index++;
              return this.scanHexLiteral(start, startLocation);
            } else if (ch === "b" || ch === "B") {
              this.index++;
              return this.scanBinaryLiteral(start, startLocation);
            } else if (ch === "o" || ch === "O") {
              this.index++;
              return this.scanOctalLiteral(start, startLocation);
            } else if ("0" <= ch && ch <= "9") {
              return this.scanLegacyOctalLiteral(start, startLocation);
            }
          } else {
            var _slice = this.getSlice(start, startLocation);
            return {
              type: TokenType.NUMBER,
              value: +_slice.text,
              slice: _slice,
              octal: false,
              noctal: false
            };
          }
        } else if (ch !== ".") {
          // Must be "1".."9"
          ch = this.source.charAt(this.index);
          while ("0" <= ch && ch <= "9") {
            this.index++;
            if (this.index === this.source.length) {
              var _slice2 = this.getSlice(start, startLocation);
              return {
                type: TokenType.NUMBER,
                value: +_slice2.text,
                slice: _slice2,
                octal: false,
                noctal: false
              };
            }
            ch = this.source.charAt(this.index);
          }
        }

        this.eatDecimalLiteralSuffix();

        if (this.index !== this.source.length && (0, _utils.isIdentifierStart)(this.source.charCodeAt(this.index))) {
          throw this.createILLEGAL();
        }

        var slice = this.getSlice(start, startLocation);
        return {
          type: TokenType.NUMBER,
          value: +slice.text,
          slice: slice,
          octal: false,
          noctal: false
        };
      }
    }, {
      key: "eatDecimalLiteralSuffix",
      value: function eatDecimalLiteralSuffix() {
        var ch = this.source.charAt(this.index);
        if (ch === ".") {
          this.index++;
          if (this.index === this.source.length) {
            return;
          }

          ch = this.source.charAt(this.index);
          while ("0" <= ch && ch <= "9") {
            this.index++;
            if (this.index === this.source.length) {
              return;
            }
            ch = this.source.charAt(this.index);
          }
        }

        // EOF not reached here
        if (ch === "e" || ch === "E") {
          this.index++;
          if (this.index === this.source.length) {
            throw this.createILLEGAL();
          }

          ch = this.source.charAt(this.index);
          if (ch === "+" || ch === "-") {
            this.index++;
            if (this.index === this.source.length) {
              throw this.createILLEGAL();
            }
            ch = this.source.charAt(this.index);
          }

          if ("0" <= ch && ch <= "9") {
            while ("0" <= ch && ch <= "9") {
              this.index++;
              if (this.index === this.source.length) {
                break;
              }
              ch = this.source.charAt(this.index);
            }
          } else {
            throw this.createILLEGAL();
          }
        }
      }
    }, {
      key: "scanStringEscape",
      value: function scanStringEscape(str, octal) {
        this.index++;
        if (this.index === this.source.length) {
          throw this.createILLEGAL();
        }
        var ch = this.source.charAt(this.index);
        if (!(0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
          switch (ch) {
            case "n":
              str += "\n";
              this.index++;
              break;
            case "r":
              str += "\r";
              this.index++;
              break;
            case "t":
              str += "\t";
              this.index++;
              break;
            case "u":
            case "x":
              var unescaped = void 0;
              this.index++;
              if (this.index >= this.source.length) {
                throw this.createILLEGAL();
              }
              unescaped = ch === "u" ? this.scanUnicode() : this.scanHexEscape2();
              if (unescaped < 0) {
                throw this.createILLEGAL();
              }
              str += fromCodePoint(unescaped);
              break;
            case "b":
              str += "\b";
              this.index++;
              break;
            case "f":
              str += "\f";
              this.index++;
              break;
            case "v":
              str += "\u000b";
              this.index++;
              break;
            default:
              if ("0" <= ch && ch <= "7") {
                var octalStart = this.index;
                var octLen = 1;
                // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3
                if ("0" <= ch && ch <= "3") {
                  octLen = 0;
                }
                var code = 0;
                while (octLen < 3 && "0" <= ch && ch <= "7") {
                  this.index++;
                  if (octLen > 0 || ch !== "0") {
                    octal = this.source.slice(octalStart, this.index);
                  }
                  code *= 8;
                  code += ch - "0";
                  octLen++;
                  if (this.index === this.source.length) {
                    throw this.createILLEGAL();
                  }
                  ch = this.source.charAt(this.index);
                }
                str += String.fromCharCode(code);
              } else if (ch === "8" || ch === "9") {
                throw this.createILLEGAL();
              } else {
                str += ch;
                this.index++;
              }
          }
        } else {
          this.index++;
          if (ch === "\r" && this.source.charAt(this.index) === "\n") {
            this.index++;
          }
          this.lineStart = this.index;
          this.line++;
        }
        return [str, octal];
      }
      // 7.8.4 String Literals

    }, {
      key: "scanStringLiteral",
      value: function scanStringLiteral() {
        var str = "";

        var quote = this.source.charAt(this.index);
        //  assert((quote === "\"" || quote === """), "String literal must starts with a quote")

        var startLocation = this.getLocation();
        var start = this.index;
        this.index++;

        var octal = null;
        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          if (ch === quote) {
            this.index++;
            return { type: TokenType.STRING, slice: this.getSlice(start, startLocation), str: str, octal: octal };
          } else if (ch === "\\") {
            var _scanStringEscape = this.scanStringEscape(str, octal);

            var _scanStringEscape2 = _slicedToArray(_scanStringEscape, 2);

            str = _scanStringEscape2[0];
            octal = _scanStringEscape2[1];
          } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
            throw this.createILLEGAL();
          } else {
            str += ch;
            this.index++;
          }
        }

        throw this.createILLEGAL();
      }
    }, {
      key: "scanTemplateElement",
      value: function scanTemplateElement() {
        var startLocation = this.getLocation();
        var start = this.index;
        this.index++;
        while (this.index < this.source.length) {
          var ch = this.source.charCodeAt(this.index);
          switch (ch) {
            case 0x60:
              // `
              this.index++;
              return { type: TokenType.TEMPLATE, tail: true, slice: this.getSlice(start, startLocation) };
            case 0x24:
              // $
              if (this.source.charCodeAt(this.index + 1) === 0x7B) {
                // {
                this.index += 2;
                return { type: TokenType.TEMPLATE, tail: false, slice: this.getSlice(start, startLocation) };
              }
              this.index++;
              break;
            case 0x5C:
              // \\
              {
                var octal = this.scanStringEscape("", null)[1];
                if (octal != null) {
                  throw this.createILLEGAL();
                }
                break;
              }
            default:
              this.index++;
          }
        }

        throw this.createILLEGAL();
      }
    }, {
      key: "scanRegExp",
      value: function scanRegExp(str) {
        var startLocation = this.getLocation();
        var start = this.index;

        var terminated = false;
        var classMarker = false;
        while (this.index < this.source.length) {
          var ch = this.source.charAt(this.index);
          if (ch === "\\") {
            str += ch;
            this.index++;
            ch = this.source.charAt(this.index);
            // ECMA-262 7.8.5
            if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
              throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
            }
            str += ch;
            this.index++;
          } else if ((0, _utils.isLineTerminator)(ch.charCodeAt(0))) {
            throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
          } else {
            if (classMarker) {
              if (ch === "]") {
                classMarker = false;
              }
            } else {
              if (ch === "/") {
                terminated = true;
                str += ch;
                this.index++;
                break;
              } else if (ch === "[") {
                classMarker = true;
              }
            }
            str += ch;
            this.index++;
          }
        }

        if (!terminated) {
          throw this.createError(_errors.ErrorMessages.UNTERMINATED_REGEXP);
        }

        while (this.index < this.source.length) {
          var _ch3 = this.source.charAt(this.index);
          if (_ch3 === "\\") {
            throw this.createError(_errors.ErrorMessages.INVALID_REGEXP_FLAGS);
          }
          if (!(0, _utils.isIdentifierPart)(_ch3.charCodeAt(0))) {
            break;
          }
          this.index++;
          str += _ch3;
        }
        return { type: TokenType.REGEXP, value: str, slice: this.getSlice(start, startLocation) };
      }
    }, {
      key: "advance",
      value: function advance() {
        var startLocation = this.getLocation();

        this.lastIndex = this.index;
        this.lastLine = this.line;
        this.lastLineStart = this.lineStart;

        this.skipComment();

        this.startIndex = this.index;
        this.startLine = this.line;
        this.startLineStart = this.lineStart;

        if (this.lastIndex === 0) {
          this.lastIndex = this.index;
          this.lastLine = this.line;
          this.lastLineStart = this.lineStart;
        }

        if (this.index >= this.source.length) {
          return { type: TokenType.EOS, slice: this.getSlice(this.index, startLocation) };
        }

        var charCode = this.source.charCodeAt(this.index);

        if (charCode < 0x80) {
          if (PUNCTUATOR_START[charCode]) {
            return this.scanPunctuator();
          }

          if ((0, _utils.isIdentifierStart)(charCode) || charCode === 0x5C /* backslash (\) */) {
              return this.scanIdentifier();
            }

          // Dot (.) U+002E can also start a floating-point number, hence the need
          // to check the next character.
          if (charCode === 0x2E) {
            if (this.index + 1 < this.source.length && (0, _utils.isDecimalDigit)(this.source.charCodeAt(this.index + 1))) {
              return this.scanNumericLiteral();
            }
            return this.scanPunctuator();
          }

          // String literal starts with single quote (U+0027) or double quote (U+0022).
          if (charCode === 0x27 || charCode === 0x22) {
            return this.scanStringLiteral();
          }

          // Template literal starts with back quote (U+0060)
          if (charCode === 0x60) {
            return this.scanTemplateElement();
          }

          if (0x30 /* "0" */ <= charCode && charCode <= 0x39 /* "9" */) {
              return this.scanNumericLiteral();
            }

          // Slash (/) U+002F can also start a regex.
          throw this.createILLEGAL();
        } else {
          if ((0, _utils.isIdentifierStart)(charCode) || 0xD800 <= charCode && charCode <= 0xDBFF) {
            return this.scanIdentifier();
          }

          throw this.createILLEGAL();
        }
      }
    }, {
      key: "eof",
      value: function eof() {
        return this.lookahead.type === TokenType.EOS;
      }
    }, {
      key: "lex",
      value: function lex() {
        var prevToken = this.lookahead;
        this.lookahead = this.advance();
        this.tokenIndex++;
        return prevToken;
      }
    }], [{
      key: "cse2",
      value: function cse2(id, ch1, ch2) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2;
      }
    }, {
      key: "cse3",
      value: function cse3(id, ch1, ch2, ch3) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;
      }
    }, {
      key: "cse4",
      value: function cse4(id, ch1, ch2, ch3, ch4) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;
      }
    }, {
      key: "cse5",
      value: function cse5(id, ch1, ch2, ch3, ch4, ch5) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;
      }
    }, {
      key: "cse6",
      value: function cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;
      }
    }, {
      key: "cse7",
      value: function cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {
        return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;
      }
    }]);

    return Tokenizer;
  }();

  exports.default = Tokenizer;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/syntax.js", ["immutable", "./errors", "./binding-map", "ramda-fantasy", "ramda", "shift-parser/dist/tokenizer", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ALL_PHASES = exports.Types = void 0;var _immutable = $__require("immutable"),
      _errors = $__require("./errors"),
      _bindingMap = $__require("./binding-map"),
      _bindingMap2 = _interopRequireDefault(_bindingMap),
      _ramdaFantasy = $__require("ramda-fantasy"),
      _ramda = $__require("ramda"),
      _ = _interopRequireWildcard(_ramda),
      _tokenizer = $__require("shift-parser/dist/tokenizer");function _interopRequireWildcard(c) {
    if (c && c.__esModule) return c;var d = {};if (null != c) for (var e in c) Object.prototype.hasOwnProperty.call(c, e) && (d[e] = c[e]);return d.default = c, d;
  }function _interopRequireDefault(c) {
    return c && c.__esModule ? c : { default: c };
  }function getFirstSlice(c) {
    return c && "function" == typeof c.isDelimiter ? c.isDelimiter() ? c.token.get(0).token.slice : c.token.slice : null;
  }function sizeDecending(c, d) {
    return c.scopes.size > d.scopes.size ? -1 : d.scopes.size > c.scopes.size ? 1 : 0;
  }let Types = exports.Types = { null: { match: c => !Types.delimiter.match(c) && c.type === _tokenizer.TokenType.NULL, create: (c, d) => new Syntax({ type: _tokenizer.TokenType.NULL, value: null }, d) }, number: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.NumericLiteral, create: (c, d) => new Syntax({ type: _tokenizer.TokenType.NUMBER, value: c }, d) }, string: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.StringLiteral, create: (c, d) => new Syntax({ type: _tokenizer.TokenType.STRING, str: c }, d) }, punctuator: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.Punctuator, create: (c, d) => new Syntax({ type: { klass: _tokenizer.TokenClass.Punctuator, name: c }, value: c }, d) }, keyword: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.Keyword, create: (c, d) => new Syntax({ type: { klass: _tokenizer.TokenClass.Keyword, name: c }, value: c }, d) }, identifier: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.Ident, create: (c, d) => new Syntax({ type: _tokenizer.TokenType.IDENTIFIER, value: c }, d) }, regularExpression: { match: c => !Types.delimiter.match(c) && c.type.klass === _tokenizer.TokenClass.RegularExpression, create: (c, d) => new Syntax({ type: _tokenizer.TokenType.REGEXP, value: c }, d) }, braces: { match: c => Types.delimiter.match(c) && c.get(0).token.type === _tokenizer.TokenType.LBRACE, create: (c, d) => {
        let e = new Syntax({ type: _tokenizer.TokenType.LBRACE, value: "{", slice: getFirstSlice(d) }),
            f = new Syntax({ type: _tokenizer.TokenType.RBRACE, value: "}", slice: getFirstSlice(d) });return new Syntax(_immutable.List.of(e).concat(c).push(f), d);
      } }, brackets: { match: c => Types.delimiter.match(c) && c.get(0).token.type === _tokenizer.TokenType.LBRACK, create: (c, d) => {
        let e = new Syntax({ type: _tokenizer.TokenType.LBRACK, value: "[", slice: getFirstSlice(d) }),
            f = new Syntax({ type: _tokenizer.TokenType.RBRACK, value: "]", slice: getFirstSlice(d) });return new Syntax(_immutable.List.of(e).concat(c).push(f), d);
      } }, parens: { match: c => Types.delimiter.match(c) && c.get(0).token.type === _tokenizer.TokenType.LPAREN, create: (c, d) => {
        let e = new Syntax({ type: _tokenizer.TokenType.LPAREN, value: "(", slice: getFirstSlice(d) }),
            f = new Syntax({ type: _tokenizer.TokenType.RPAREN, value: ")", slice: getFirstSlice(d) });return new Syntax(_immutable.List.of(e).concat(c).push(f), d);
      } }, assign: { match: c => {
        if (Types.punctuator.match(c)) switch (c.value) {case "=":case "|=":case "^=":case "&=":case "<<=":case ">>=":case ">>>=":case "+=":case "-=":case "*=":case "/=":case "%=":
            return !0;default:
            return !1;}return !1;
      } }, boolean: { match: c => !Types.delimiter.match(c) && c.type === _tokenizer.TokenType.TRUE || c.type === _tokenizer.TokenType.FALSE }, template: { match: c => !Types.delimiter.match(c) && c.type === _tokenizer.TokenType.TEMPLATE }, delimiter: { match: c => _immutable.List.isList(c) }, syntaxTemplate: { match: c => Types.delimiter.match(c) && "#`" === c.get(0).val() }, eof: { match: c => !Types.delimiter.match(c) && c.type === _tokenizer.TokenType.EOS } };const ALL_PHASES = exports.ALL_PHASES = {};class Syntax {
    constructor(c, d) {
      this.token = c, this.bindings = d && null != d.bindings ? d.bindings : new _bindingMap2.default(), this.scopesets = d && null != d.scopesets ? d.scopesets : { all: (0, _immutable.List)(), phase: (0, _immutable.Map)() }, Object.freeze(this);
    }static of(c, d) {
      return new Syntax(c, d);
    }static from(c, d, e) {
      if (!Types[c]) throw new Error(c + " is not a valid type");else if (!Types[c].create) throw new Error("Cannot create a syntax from type " + c);let f = Types[c].create(d, e),
          g = getFirstSlice(e);return null != g && (f.token.slice = g), f;
    }from(c, d) {
      return Syntax.from(c, d, this);
    }fromNull() {
      return this.from("null", null);
    }fromNumber(c) {
      return this.from("number", c);
    }fromString(c) {
      return this.from("string", c);
    }fromPunctuator(c) {
      return this.from("punctuator", c);
    }fromKeyword(c) {
      return this.from("keyword", c);
    }fromIdentifier(c) {
      return this.from("identifier", c);
    }fromRegularExpression(c) {
      return this.from("regularExpression", c);
    }fromBraces(c) {
      return this.from("braces", c);
    }fromBrackets(c) {
      return this.from("brackets", c);
    }fromParens(c) {
      return this.from("parens", c);
    }static fromNull(c) {
      return Syntax.from("null", null, c);
    }static fromNumber(c, d) {
      return Syntax.from("number", c, d);
    }static fromString(c, d) {
      return Syntax.from("string", c, d);
    }static fromPunctuator(c, d) {
      return Syntax.from("punctuator", c, d);
    }static fromKeyword(c, d) {
      return Syntax.from("keyword", c, d);
    }static fromIdentifier(c, d) {
      return Syntax.from("identifier", c, d);
    }static fromRegularExpression(c, d) {
      return Syntax.from("regularExpression", c, d);
    }static fromBraces(c, d) {
      return Syntax.from("braces", c, d);
    }static fromBrackets(c, d) {
      return Syntax.from("brackets", c, d);
    }static fromParens(c, d) {
      return Syntax.from("parens", c, d);
    }resolve(c) {
      (0, _errors.assert)(null != c, "must provide a phase to resolve");let d = this.scopesets.all,
          e = this.scopesets.phase.has(c) ? this.scopesets.phase.get(c) : (0, _immutable.List)();if (e = d.concat(e), 0 === e.size || !(this.match("identifier") || this.match("keyword"))) return this.token.value;let f = e.last(),
          g = this.bindings;if (f) {
        let h = g.get(this);if (h) {
          let i = h.filter(j => {
            let k = j.scopes;return k.isSubset(e);
          }).sort(sizeDecending);if (2 <= i.size && i.get(0).scopes.size === i.get(1).scopes.size) {
            let j = "{" + e.map(l => l.toString()).join(", ") + "}",
                k = i.map(l => {
              let m = l.scopes;return "{" + m.map(n => n.toString()).join(", ") + "}";
            }).join(", ");throw new Error("Scopeset " + j + " has ambiguous subsets " + k);
          } else if (0 !== i.size) {
            let j = i.get(0).binding.toString();return _ramdaFantasy.Maybe.isJust(i.get(0).alias) ? i.get(0).alias.getOrElse(null).resolve(c) : j;
          }
        }
      }return this.token.value;
    }val() {
      return (0, _errors.assert)(!this.match("delimiter"), "cannot get the val of a delimiter"), this.match("string") ? this.token.str : this.match("template") ? this.token.items.map(c => {
        return "function" == typeof c.match && c.match("delimiter") ? "${...}" : c.slice.text;
      }).join("") : this.token.value;
    }lineNumber() {
      return this.match("delimiter") ? this.token.get(0).lineNumber() : this.token.slice.startLocation.line;
    }setLineNumber(c) {
      let d = {};if (this.isDelimiter()) d = this.token.map(e => e.setLineNumber(c));else {
        for (let e of Object.keys(this.token)) d[e] = this.token[e];(0, _errors.assert)(d.slice && d.slice.startLocation, "all tokens must have line info"), d.slice.startLocation.line = c;
      }return new Syntax(d, this);
    }inner() {
      return (0, _errors.assert)(this.match("delimiter"), "can only get the inner of a delimiter"), this.token.slice(1, this.token.size - 1);
    }addScope(c, d, e) {
      let f = 3 >= arguments.length || void 0 === arguments[3] ? { flip: !1 } : arguments[3],
          g = this.match("delimiter") ? this.token.map(k => k.addScope(c, d, e, f)) : this.token;this.match("template") && (g = _.merge(g, { items: g.items.map(k => {
          return k instanceof Syntax && k.match("delimiter") ? k.addScope(c, d, e, f) : k;
        }) }));let h = e === ALL_PHASES ? this.scopesets.all : this.scopesets.phase.has(e) ? this.scopesets.phase.get(e) : (0, _immutable.List)();let i;if (f.flip) {
        let k = h.indexOf(c);i = -1 === k ? h.push(c) : h.remove(k);
      } else i = h.push(c);let j = { bindings: d, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } };return e === ALL_PHASES ? j.scopesets.all = i : j.scopesets.phase = j.scopesets.phase.set(e, i), new Syntax(g, j);
    }removeScope(c, d) {
      let e = this.match("delimiter") ? this.token.map(k => k.removeScope(c, d)) : this.token,
          f = this.scopesets.phase.has(d) ? this.scopesets.phase.get(d) : (0, _immutable.List)(),
          g = this.scopesets.all,
          h = { bindings: this.bindings, scopesets: { all: this.scopesets.all, phase: this.scopesets.phase } },
          i = f.indexOf(c),
          j = g.indexOf(c);return -1 === i ? -1 !== j && (h.scopesets.all = g.remove(j)) : h.scopesets.phase = this.scopesets.phase.set(d, f.remove(i)), new Syntax(e, h);
    }match(c, d) {
      if (!Types[c]) throw new Error(c + " is an invalid type");return Types[c].match(this.token) && (null == d || (d instanceof RegExp ? d.test(this.val()) : this.val() == d));
    }isIdentifier(c) {
      return this.match("identifier", c);
    }isAssign(c) {
      return this.match("assign", c);
    }isBooleanLiteral(c) {
      return this.match("boolean", c);
    }isKeyword(c) {
      return this.match("keyword", c);
    }isNullLiteral(c) {
      return this.match("null", c);
    }isNumericLiteral(c) {
      return this.match("number", c);
    }isPunctuator(c) {
      return this.match("punctuator", c);
    }isStringLiteral(c) {
      return this.match("string", c);
    }isRegularExpression(c) {
      return this.match("regularExpression", c);
    }isTemplate(c) {
      return this.match("template", c);
    }isDelimiter(c) {
      return this.match("delimiter", c);
    }isParens(c) {
      return this.match("parens", c);
    }isBraces(c) {
      return this.match("braces", c);
    }isBrackets(c) {
      return this.match("brackets", c);
    }isSyntaxTemplate(c) {
      return this.match("syntaxTemplate", c);
    }isEOF(c) {
      return this.match("eof", c);
    }toString() {
      return this.match("delimiter") ? this.token.map(c => c.toString()).join(" ") : this.match("string") ? "'" + this.token.str : this.match("template") ? this.val() : this.token.value;
    }
  }exports.default = Syntax;
});
System.registerDynamic("npm:sweetjs-min@2.2.3/dist/modules.js", ["immutable", "./env", "./store", "./shift-reader", "ramda", "./symbol", "./terms", "./load-syntax", "./compiler", "./transforms", "./scope", "./errors", "./hygiene-utils", "./syntax", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.Modules = exports.Module = void 0;var _immutable = $__require("immutable"),
      _env = $__require("./env"),
      _env2 = _interopRequireDefault(_env),
      _store = $__require("./store"),
      _store2 = _interopRequireDefault(_store),
      _shiftReader = $__require("./shift-reader"),
      _shiftReader2 = _interopRequireDefault(_shiftReader),
      _ramda = $__require("ramda"),
      _ = _interopRequireWildcard(_ramda),
      _symbol = $__require("./symbol"),
      _terms = $__require("./terms"),
      T = _interopRequireWildcard(_terms),
      _loadSyntax = $__require("./load-syntax"),
      _compiler = $__require("./compiler"),
      _compiler2 = _interopRequireDefault(_compiler),
      _transforms = $__require("./transforms"),
      _scope = $__require("./scope"),
      _errors = $__require("./errors"),
      _hygieneUtils = $__require("./hygiene-utils"),
      _syntax = $__require("./syntax");function _interopRequireWildcard(a) {
    if (a && a.__esModule) return a;var b = {};if (null != a) for (var c in a) Object.prototype.hasOwnProperty.call(a, c) && (b[c] = a[c]);return b.default = a, b;
  }function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }class Module {
    constructor(a, b, c, d, e, f) {
      this.moduleSpecifier = a, this.isNative = b, this.importEntries = c, this.exportEntries = d, this.pragmas = e, this.body = f;
    }
  }exports.Module = Module;const findBindingIdentifierName = a => {
    return (0, _errors.assert)(a.name, `not implemented yet for type ${a.type}`), a.name;
  },
        convertExport = a => {
    let b = a.declaration,
        c = [];T.isVariableDeclaration(b) ? c = b.declarators.map(e => findBindingIdentifierName(e.binding)) : (T.isFunctionDeclaration(b) || T.isClassDeclaration(b)) && c.push(findBindingIdentifierName(b.name));let d = c.map(e => {
      return new T.default("ExportSpecifier", { name: null, exportedName: e });
    });return new T.default("ExportFrom", { moduleSpecifier: null, namedExports: (0, _immutable.List)(d) });
  },
        pragmaRegep = /^\s*#\w*/;class Modules {
    constructor(a) {
      this.compiledModules = new Map(), this.context = a, this.context.modules = this;
    }loadString(a) {
      let b = 1 >= arguments.length || arguments[1] === void 0 || arguments[1],
          c = pragmaRegep.test(a);return b && !c ? { isNative: !0, body: (0, _immutable.List)() } : { isNative: !c, body: new _shiftReader2.default(a).read() };
    }load(a) {
      return this.loadString(this.context.moduleLoader(a));
    }compile(a, b) {
      let c = a.body,
          d = (0, _scope.freshScope)("outsideEdge"),
          e = (0, _scope.freshScope)(`insideEdge0`),
          f = new _compiler2.default(0, new _env2.default(), new _store2.default(), _.merge(this.context, { currentScope: [d, e], cwd: "<<entrypoint>>" === b ? this.context.cwd : (0, _utilsDirname2.default)(b) })),
          g = f.compile(c.map(l => l.addScope(d, this.context.bindings, _syntax.ALL_PHASES).addScope(e, this.context.bindings, 0))),
          h = [],
          i = [],
          j = [],
          k = g.reduce((l, m) => {
        return _.cond([[T.isImport, n => {
          return h.push(n), l;
        }], [T.isExport, n => {
          return n.declaration ? (i.push(convertExport(n)), T.isVariableDeclaration(n.declaration) ? l.concat(new T.default("VariableDeclarationStatement", { declaration: n.declaration })) : l.concat(n.declaration)) : (i.push(n), l);
        }], [T.isPragma, n => {
          return j.push(n), l;
        }], [_.T, n => l.concat(n)]])(m);
      }, (0, _immutable.List)());return new Module(b, a.isNative, (0, _immutable.List)(h), (0, _immutable.List)(i), (0, _immutable.List)(j), k);
    }compileEntrypoint(a, b) {
      let c = 2 >= arguments.length || arguments[2] === void 0 ? !1 : arguments[2],
          d = this.loadString(a, !1);if (c && d.isNative) throw new Error(`Entrypoint ${b} must begin with #lang pragma`);return this.getAtPhase("<<entrypoint>>", 0, this.context.cwd, d);
    }getAtPhase(a, b, c) {
      let d = 3 >= arguments.length || arguments[3] === void 0 ? null : arguments[3],
          e = "<<entrypoint>>" === a ? a : this.context.moduleResolver(a, c),
          f = `${e}:${b}`;if (!this.compiledModules.has(f)) if (0 === b) {
        let g = null == d ? this.load(e) : d;this.compiledModules.set(f, this.compile(g, e));
      } else {
        let g = this.getAtPhase(a, 0, c, d),
            h = (0, _scope.freshScope)(`insideEdge${b}`);this.compiledModules.set(f, new Module(g.moduleSpecifier, !1, g.importEntries.map(i => i.addScope(h, this.context.bindings, b)), g.exportEntries.map(i => i.addScope(h, this.context.bindings, b)), g.pragmas, g.body.map(i => i.addScope(h, this.context.bindings, b))));
      }return this.compiledModules.get(f);
    }has(a) {
      let b = 1 >= arguments.length || arguments[1] === void 0 ? 0 : arguments[1],
          c = "<<entrypoint>>" === a ? a : this.context.moduleResolver(a, this.context.cwd),
          d = `${c}:${b}`;return this.compiledModules.has(d) && !this.compiledModules.get(d).isNative;
    }registerSyntaxDeclaration(a, b, c) {
      a.declarators.forEach(d => {
        let e = (0, _loadSyntax.evalCompiletimeValue)(d.init.gen(), _.merge(this.context, { phase: b + 1, store: c }));(0, _hygieneUtils.collectBindings)(d.binding).forEach(f => {
          if (0 !== b) {
            let h = (0, _symbol.gensym)(f.val());this.context.bindings.add(f, { binding: h, phase: b, skipDup: !1 });
          }let g = f.resolve(b);c.set(g, new _transforms.CompiletimeTransform(e));
        });
      });
    }registerVariableDeclaration(a, b, c) {
      a.declarators.forEach(d => {
        (0, _hygieneUtils.collectBindings)(d.binding).forEach(e => {
          if (0 !== b) {
            let g = (0, _symbol.gensym)(e.val());this.context.bindings.add(e, { binding: g, phase: b, skipDup: "var" === a.kind });
          }let f = e.resolve(b);c.set(f, new _transforms.VarBindingTransform(e));
        });
      });
    }registerFunctionOrClass(a, b, c) {
      (0, _hygieneUtils.collectBindings)(a.name).forEach(d => {
        if (0 !== b) {
          let f = (0, _symbol.gensym)(d.val());this.context.bindings.add(d, { binding: f, phase: b, skipDup: !1 });
        }let e = d.resolve(b);c.set(e, new _transforms.VarBindingTransform(d));
      });
    }visit(a, b, c) {
      return a.body.forEach(d => {
        T.isSyntaxDeclarationStatement(d) && this.registerSyntaxDeclaration(d.declaration, b, c);
      }), c;
    }invoke(a, b, c) {
      let d = a.body.filter(_.complement(T.isCompiletimeStatement)).map(e => {
        return e = e.gen(), T.isVariableDeclarationStatement(e) ? this.registerVariableDeclaration(e.declaration, b, c) : T.isFunctionDeclaration(e) && this.registerFunctionOrClass(e, b, c), e;
      });return (0, _loadSyntax.evalRuntimeValues)(d, _.merge(this.context, { store: c, phase: b })), c;
    }
  }exports.Modules = Modules;
});
System.registerDynamic("npm:jspm-nodelibs-process@0.2.0.json", [], true, function() {
  return {
    "main": "./process.js"
  };
});

System.registerDynamic('npm:jspm-nodelibs-process@0.2.0/process.js', ['@system-env'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // From https://github.com/defunctzombie/node-process/blob/master/browser.js
    // shim for using process in browser

    var productionEnv = $__require('@system-env').production;

    var process = module.exports = {};
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = setTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        clearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            setTimeout(drainQueue, 0);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {
        NODE_ENV: productionEnv ? 'production' : 'development'
    };
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
System.registerDynamic("npm:sweetjs-min@2.2.3.json", [], true, function() {
  return {
    "main": "dist/sweet.js",
    "format": "cjs",
    "meta": {
      "*": {
        "globals": {
          "process": "process"
        }
      },
      "*.json": {
        "format": "json"
      }
    }
  };
});

System.registerDynamic("npm:sweetjs-min@2.2.3/dist/sweet.js", ["immutable", "shift-reducer", "./parse-reducer", "shift-codegen", "./binding-map.js", "./terms", "./modules", "process"], true, function ($__require, exports, module) {
  "use strict";
  var process = $__require("process");
  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.expand = expand, exports.parse = parse, exports.compile = compile;var _immutable = $__require("immutable"),
      _shiftReducer = $__require("shift-reducer"),
      _shiftReducer2 = _interopRequireDefault(_shiftReducer),
      _parseReducer = $__require("./parse-reducer"),
      _parseReducer2 = _interopRequireDefault(_parseReducer),
      _shiftCodegen = $__require("shift-codegen"),
      _shiftCodegen2 = _interopRequireDefault(_shiftCodegen),
      _bindingMap = $__require("./binding-map.js"),
      _bindingMap2 = _interopRequireDefault(_bindingMap),
      _terms = $__require("./terms"),
      _terms2 = _interopRequireDefault(_terms),
      _modules = $__require("./modules");function _interopRequireDefault(a) {
    return a && a.__esModule ? a : { default: a };
  }function expand(a) {
    let b = 1 >= arguments.length || arguments[1] === void 0 ? {} : arguments[1],
        d = new _bindingMap2.default(),
        e = new _modules.Modules({ bindings: d, cwd: b.cwd || process.cwd(), filename: b.filename, transform: b.transform || function (h) {
        return { code: h };
      } }),
        f = e.compileEntrypoint(a, b.filename, b.enforcePragma),
        g = f.importEntries.filter(h => !e.has(h.moduleSpecifier.val()));return new _terms2.default("Module", { directives: (0, _immutable.List)(), items: g.concat(f.body).concat(f.exportEntries.interpose(new _terms2.default("EmptyStatement", {}))) });
  }function parse(a, b) {
    let d = 2 >= arguments.length || arguments[2] === void 0 || arguments[2];return (0, _shiftReducer2.default)(new _parseReducer2.default({ phase: 0 }), expand(a, b).gen(d));
  }function compile(a) {
    let b = 1 >= arguments.length || arguments[1] === void 0 ? {} : arguments[1],
        d = parse(a, b, b.includeImports),
        e = (0, _shiftCodegen2.default)(d, new _shiftCodegen.FormattedCodeGen());return { code: e };
  }
});
//# sourceMappingURL=build.js.map